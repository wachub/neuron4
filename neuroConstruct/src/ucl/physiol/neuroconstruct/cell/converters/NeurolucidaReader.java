/**
 *  neuroConstruct
 *  Software for developing large scale 3D networks of biologically realistic neurons
 * 
 *  Copyright (c) 2009 Padraig Gleeson
 *  UCL Department of Neuroscience, Physiology and Pharmacology
 *
 *  Development of this software was made possible with funding from the
 *  Medical Research Council and the Wellcome Trust
 *  
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package ucl.physiol.neuroconstruct.cell.converters;

import java.io.*;
import java.util.*;
import javax.vecmath.*;

import java.awt.*;

import ucl.physiol.neuroconstruct.cell.*;
import ucl.physiol.neuroconstruct.cell.utils.*;
import ucl.physiol.neuroconstruct.gui.*;
import ucl.physiol.neuroconstruct.utils.*;

/**
 *
 * A class for importing Neurolucida morphology files (.asc files), and creating Cells
 * which can be used by the rest of the application
 *
 * @author Padraig Gleeson
 *  
 *
 */

public class NeurolucidaReader extends FormatImporter
{
    private static ClassLogger logger = new ClassLogger("NeurolucidaReader");

    private int uniqueId = 10000;

    private boolean includeSomaOutline = true;
    private boolean daughtersInherit = false;


    public NeurolucidaReader()
    {
        super("NeurolucidaReader",
                            "Importer of ASC (Neurolucida format) files",
                            new String[]{".asc"});
    }


    public Cell loadFromMorphologyFile(File morphologyFile, String name) throws MorphologyException
    {
        logger.logComment("Parsing file: " + morphologyFile);
        Cell cell = new Cell();
        cell.setInstanceName(name);

        /**
         * needed for default root segment
         */
        float defaultRadius = 5;
        float defaultLength = 10;

        try
        {
            Reader in = new FileReader(morphologyFile);

            BufferedReader lineReader = new BufferedReader(in);

            StringBuffer description = new StringBuffer("Cell morphology generated by neuroConstruct from file: "
                                                        + morphologyFile.getName()
                                                        + "\n");

            /**
             * Will contain any lines not recognised
             */
            Vector<String> unknownLines = new Vector<String>();

            String nextLine = null;
            int lineCount = 0;

            /**
             * As there is no realistic soma segment in the file, this can be used as
             * the basis for (manually) building one. No functionality is present (yet)
             * to generate one on the basis of the soma outline.
             */
            Segment rootSegment = null;

            String somaOutlineName = null;

            ASCInfo ascInfo = new ASCInfo();

            while ( (nextLine = lineReader.readLine()) != null)
            {
                lineCount++;
                logger.logComment("");
                logger.logComment("------      Line number: "+lineCount+": "+nextLine);

                ASCLine ascLine = new ASCLine(nextLine);

                logger.logComment("+ State of line: "+ ascLine.getState());


                switch (ascLine.getState())
                {
                    case UNKNOWN:
                        logger.logComment("Unknown line");

                        if (!unknownLines.contains(nextLine.trim())&& nextLine.indexOf("Thumbnail")<0)
                            unknownLines.add(nextLine.trim()); // no need to repeat identical unknown lines...
                        break;

                    case EMPTY_LINE:
                        // Ignoring...
                        break;

                    case SPLIT_MARK:
                        // Ignoring...
                        break;

                    case COMMENT_ONLY:
                        description.append(ascLine.getComment() + "\n");
                        break;

                    case ANGLE_BRACKETED:
                        logger.logComment("Ignoring angle bracketed line: "+ nextLine); // usually a spine
                        break;


                    case BRACKETED_DIRECTIVE:
                        logger.logComment("Bracketed Directive: " + ascLine.getDirective() + "\n");

                        if (ascLine.getDirective().equals(ASCInfo.CELL_BODY)) // as there are often 2 or more cell bodies in a file...
                        {
                            // The ("CellBody" line sets the state and the (CellBody) line
                            // causes the root segment to be added
                            if (rootSegment==null)
                            {
                                rootSegment = cell.addFirstSomaSegment(defaultRadius,
                                                                       defaultRadius,
                                                                       "RootSegment",
                                                                       new Point3f(0, 0, 0),
                                                                       new Point3f(0, defaultLength, 0),
                                                                       new Section("Soma"));

                                rootSegment.setComment("Root Segment, parent of all dendrites, etc. Should be edited to create biologically accurate soma based on soma outline");
                            }
                        }

                        else if ((ascInfo.getState().equals(ASC_State.NEURITE) ||
                                 ascInfo.getState().equals(ASC_State.CELL_BODY)) &&
                                ascLine.getDirective().startsWith("Color "))
                        {
                            String colour = ascLine.getDirective().substring(6);
                            colour = GeneralUtils.replaceAllTokens(colour, " ", "");
                            colour = GeneralUtils.replaceAllTokens(colour, "(", "");
                            colour = GeneralUtils.replaceAllTokens(colour, ",", "_");

                            ascInfo.setPreferredColour(colour);
                        }

                        else if (ascLine.getDirective().equals(ASCInfo.DENDRITE) ||
                                 ascLine.getDirective().equals(ASCInfo.APICAL) ||
                                 ascLine.getDirective().equals(ASCInfo.AXON))
                        {
                            ascInfo.setState(ASC_State.NEURITE);
                            ascInfo.setSubClass(ascLine.getDirective());

                            logger.logComment("Subclass: "+ ascInfo.getSubClass());

                            String namePrefix = ascInfo.getSubClass();

                            if (ascInfo.getPreferredColour()!=null)
                                namePrefix = ascInfo.getSubClass()+ascInfo.getPreferredColour();

                            ascInfo.setPrefix(namePrefix);

                            ascInfo.getLowerBranchEndSegs().clear();
                            ascInfo.getLowerBranchEndSegs().add(rootSegment);
                        }

                        else if ((ascInfo.getState().equals(ASC_State.UNSUPPORTED_ELEMENT)))
                        {
                            logger.logComment("Unsupported element, ignoring line");
                        }

                        else
                        {
                            boolean recognised = false;
                            String[] shapes = ascInfo.getShapes();

                            for (int i = 0; i < shapes.length; i++)
                            {
                                if (ascLine.getDirective().equals(shapes[i]))
                                {
                                    logger.logComment("Ignoring shape element: "+ shapes[i]);
                                    recognised = true;
                                }
                            }

                            String[] reservedWords = ascInfo.getReservedWords();

                            for (int i = 0; i < reservedWords.length; i++)
                            {
                                if (ascLine.getDirective().equals(reservedWords[i]))
                                {
                                    logger.logComment("Ignoring reserved word: "+ reservedWords[i]);
                                    recognised = true;
                                }
                            }
                            if (!recognised)
                            {
                                logger.logComment("Adding to unknown words...");

                                if (!unknownLines.contains(nextLine.trim())&& nextLine.indexOf("Thumbnail")<0)
                                    unknownLines.add(nextLine.trim()); // no need to repeat identical unknown lines...
                            }
                        }


                        break;


                    case OPENING_BRACKET_DIRECTIVE:
                        logger.logComment("Opening Directive: " + ascLine.getDirective() + "\n");

                        if (ascLine.getDirective().equals(ASCInfo.CELL_BODY))
                        {
                            // The ("CellBody" line sets the state and the (CellBody) line
                            // causes the root segment to be added
                            ascInfo.setState(ASC_State.CELL_BODY);

                            if (somaOutlineName == null)
                            {
                                somaOutlineName = "SomaOutline";
                            }
                            else
                            {
                                somaOutlineName = GeneralUtils.incrementName(somaOutlineName);
                            }
                        }
                        else if (ascLine.getDirective().startsWith("Color "))
                        {
                            // RGB (123, 34, 34) is changed to RGB123_34_34

                            String colour = ascLine.getDirective().substring(6);
                            colour = GeneralUtils.replaceAllTokens(colour, " ", "");
                            colour = GeneralUtils.replaceAllTokens(colour, "(", "");
                            colour = GeneralUtils.replaceAllTokens(colour, ")", "");
                            colour = GeneralUtils.replaceAllTokens(colour, ",", "_");

                            ascInfo.setPreferredColour(colour);
                        }
                        else
                        {
                            boolean recognised = false;

                            String[] shapes = ascInfo.getShapes();

                            for (int i = 0; i < shapes.length; i++)
                            {
                                if (ascLine.getDirective().equals(shapes[i]))
                                {
                                    ascInfo.setState(ASC_State.UNSUPPORTED_ELEMENT);
                                    logger.logComment("Ignoring shape element: "+ shapes[i]);
                                    recognised = true;
                                }
                            }
                            if (ascLine.getDirective().equals("Thumbnail"))
                            {
                                ascInfo.setState(ASC_State.UNSUPPORTED_ELEMENT);
                                logger.logComment("Ignoring element: "+ ascLine.getDirective());
                                recognised = true;
                            }
                            if (!recognised)
                            {
                                if (!unknownLines.contains(nextLine.trim())&& nextLine.indexOf("Thumbnail")<0)
                                    unknownLines.add(nextLine.trim()); // no need to repeat identical unknown lines...

                                logger.logComment("Unknown line: " + nextLine + ", assuming unsupported element");
                                ascInfo.setState(ASC_State.UNSUPPORTED_ELEMENT);
                            }
                        }

                        break;


                    case OPENING_BRACKET:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            if (ascInfo.getLowerBranchEndSegs().size()==0)
                            {
                                ascInfo.getLowerBranchEndSegs().add(rootSegment);
                            }
                            else
                            {
                                ascInfo.getLowerBranchEndSegs().add(ascInfo.getLastSegThisBranch());
                            }

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;


                    case NORMAL:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;

                    case INCOMPLETE:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.getLastSegThisBranch().setComment("Branch marked as Incomplete");

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;


                    case GENERATED:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.getLastSegThisBranch().setComment("Branch marked as Generated");

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;

                    case HIGH:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.getLastSegThisBranch().setComment("Branch marked as High");

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;

                    case LOW:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.getLastSegThisBranch().setComment("Branch marked as Low");

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;

                    case ORIGIN:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.getLastSegThisBranch().setComment("Branch marked as Origin");

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;

                    case MIDDLE:
                        if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            ascInfo.getLastSegThisBranch().setComment("Branch marked as Middle");

                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                        }
                        break;


                    case CLOSING_BRACKET:
                        if (ascInfo.getState().equals(ASC_State.CELL_BODY))
                        {
                            ascInfo.setState(ASC_State.ROOT);
                            ascInfo.setLastSegThisBranch(null);
                            ascInfo.setStartPointBranch(null);
                            ascInfo.setPreferredColour(null);
                        }
                        else if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            if (ascInfo.getLowerBranchEndSegs().size()==1) // just rootSegment
                            {
                                ascInfo.getLowerBranchEndSegs().clear();
                                ascInfo.setState(ASC_State.ROOT);

                                ascInfo.setLastSegThisBranch(null);
                                ascInfo.setStartPointBranch(null);
                                ascInfo.setPreferredColour(null);

                                ascInfo.setSubClass(null);
                                ascInfo.setPrefix(null);
                            }
                            else
                            {
                                ascInfo.getLowerBranchEndSegs().removeLast(); // decend one in tree

                                ascInfo.setLastSegThisBranch(null);
                                ascInfo.setStartPointBranch(null);

                            }
                        }
                        else if (ascInfo.getState().equals(ASC_State.UNSUPPORTED_ELEMENT))
                        {
                            logger.logComment("End of UNSUPPORTED_ELEMENT...");

                            // Only case I've seen is filledcircle inside dend spec...
                            if (ascInfo.getLowerBranchEndSegs().size()>0)
                            {
                                ascInfo.setState(ASC_State.NEURITE);
                            }
                            else
                            {
                                logger.logComment("Unable to determine what state the asc file should be in, assuming root");
                                ascInfo.setState(ASC_State.ROOT);
                            }
                        }
                        break;


                    case POINT_SPEC:
                        logger.logComment("Found point: " + ascLine.getPoint() + "\n");

                        if (ascInfo.getState().equals(ASC_State.CELL_BODY))
                        {
                            logger.logComment("Point belongs on cell body details.");
                            
                            if (this.includeSomaOutline)
                            {
                                Segment lastSegThisBranch = ascInfo.getLastSegThisBranch();
                                String namePrefix = somaOutlineName + "Seg_";

                                if (ascInfo.getStartPointBranch() == null && lastSegThisBranch == null)
                                {
                                    logger.logComment("Found first point of cell body: " + ascLine.getPoint());
                                    ascInfo.setStartPointBranch(ascLine.getPoint());
                                }
                                else if (lastSegThisBranch == null)
                                {
                                    logger.logComment("Found a point on cell body: " + ascLine.getPoint());

                                    PointInfo start = ascInfo.getStartPointBranch();

                                    String suggestedName = namePrefix + cleanUpCommentForID(ascLine.getComment(), false);

                                    /**
                                     * Note, dend seg added aot soma seg, as the root will be in the soma_group
                                     *
                                     */
                                    Segment newSeg =
                                        cell.addDendriticSegment(ascLine.getPoint().diam / 2,
                                                                 suggestedName,
                                                                 ascLine.getPoint().getPoint3f(),
                                                                 rootSegment,
                                                                 0,
                                                                 somaOutlineName,
                                                                 false);

                                    newSeg.getSection().setStartPointPositionX(start.x);
                                    newSeg.getSection().setStartPointPositionY(start.y);
                                    newSeg.getSection().setStartPointPositionZ(start.z);
                                    newSeg.getSection().setStartRadius(start.diam / 2);

                                    ascInfo.setLastSegThisBranch(newSeg);

                                    if (ascInfo.getPreferredColour() != null)
                                        newSeg.getSection().addToGroup("colour_" + ascInfo.getPreferredColour());

                                    newSeg.getSection().addToGroup("SomaOutlineGroup");

                                }
                                else
                                {
                                    String suggestedName = namePrefix + cleanUpCommentForID(ascLine.getComment(), false);

                                    Segment newSeg =
                                        cell.addDendriticSegment(ascLine.getPoint().diam / 2,
                                                                 suggestedName,
                                                                 ascLine.getPoint().getPoint3f(),
                                                                 lastSegThisBranch,
                                                                 1,
                                                                 somaOutlineName,
                                                                 true);

                                    ascInfo.setLastSegThisBranch(newSeg);

                                }
                            }
                            else
                            {
                                logger.logComment("Not adding point as soma outline is to be ignored");
                            }
                        }

                        else if (ascInfo.getState().equals(ASC_State.NEURITE))
                        {
                            logger.logComment("Adding point to neurite...");
                            // If colour is Yellow and comment after point info is R-1, 4
                            // segName will be DendriteYellow_R_1_4
                            // secName will be SecDendriteYellow_R_1


                            String segName = ascInfo.getPrefix() + "_" + cleanUpCommentForID(ascLine.getComment(), false);

                            String secRef = ascLine.getComment();

                            String secName = "Sec"+ascInfo.getPrefix() + "_" + cleanUpCommentForID(secRef, true);


                            logger.logComment("Adding neurite with prefix: "+ ascInfo.getPrefix());
                            logger.logComment("Subclass: "+ ascInfo.getSubClass());
                            logger.logComment("Sec name: "+ secName+", segname: "+ segName);


                            if (ascInfo.getStartPointBranch()==null && ascInfo.getLastSegThisBranch() == null)
                            {
                                logger.logComment("Found first point on subbranch");

                                ascInfo.setStartPointBranch(ascLine.getPoint());

                                Segment parent = ascInfo.getLowerBranchEndSegs().getLast();

                                if (parent==null)
                                {
                                    logger.logComment("Parent is null so far");
                                    // May mean that the previous branch had only one point,
                                    // which was the same point as ITS parent's end point, i.e.
                                    // we were waiting for 2nd point to form first seg of that
                                    // branches section.
                                    try
                                    {
                                        ascInfo.getLowerBranchEndSegs().removeLast();
                                        parent = ascInfo.getLowerBranchEndSegs().getLast();
                                    }
                                    catch(NoSuchElementException ex)
                                    {
                                        throw new MorphologyException("There was an error importing the Neurolucida morphology.\n"
                                                +"Note that the present implementation assumes a CellBody outline at the start of the file.\n"
                                                +"If none is present, adding a dummy CellBody (from another Neurolucida file) may help the problem.");
                                    }
                                    
                                }

                                float fractAlong = 1;


                                logger.logComment("Branches so far: ");
                                LinkedList<Segment> ll = ascInfo.getLowerBranchEndSegs();

                                for (int i = 0; i < ll.size(); i++)
                                {
                                    logger.logComment("Branch number: "+ i+": "+ ll.get(i).getSegmentName()+"/"+ ll.get(i).getSection().getSectionName()+" ends at: "+ ll.get(i).getEndPointPosition());
                                }

                                /**
                                 * Will be true if first point on subbranch is not same as last point on parent branch.
                                 * Both options are found, some files repeat the parent end point on the new branch, but not
                                 * all files do.
                                 */
                                boolean addConnectingSegment = ascInfo.getLowerBranchEndSegs().size()!=1    // i.e. not root seg, as this is at (0,0,0) anyway
                                    && parent.getEndPointPosition().distance(ascLine.getPoint().getPoint3f())!=0;

                                if (addConnectingSegment)
                                {
                                    logger.logComment("Adding conn seg in the section.: "+secName);

                                    Segment connectingSeg =
                                        cell.addDendriticSegment(ascLine.getPoint().diam / 2,
                                                                 segName,
                                                                 ascLine.getPoint().getPoint3f(),
                                                                 parent,
                                                                 fractAlong,
                                                                 secName,
                                                                 daughtersInherit);

                                    connectingSeg.getSection().setStartPointPositionX(parent.getEndPointPositionX());
                                    connectingSeg.getSection().setStartPointPositionY(parent.getEndPointPositionY());
                                    connectingSeg.getSection().setStartPointPositionZ(parent.getEndPointPositionZ());

                                    if (this.daughtersInherit)
                                    {
                                        logger.logComment("   Using parent start radius");
                                        connectingSeg.getSection().setStartRadius(parent.getRadius());
                                    }
                                    else
                                    {
                                        logger.logComment("   Using same start and end radius");
                                        connectingSeg.getSection().setStartRadius(ascLine.getPoint().diam / 2);
                                    }
                                    connectingSeg.setComment("Segment joining to parent segment endpoint");

                                    ascInfo.setLastSegThisBranch(connectingSeg);

                                    if (ascInfo.getPreferredColour()!=null)
                                        connectingSeg.getSection().addToGroup("colour_"+ ascInfo.getPreferredColour());

                                    if (ascInfo.getSubClass() != null)
                                    {
                                        if (ascInfo.getSubClass().equals(ASCInfo.DENDRITE))
                                        {
                                            // Not interesting subclass...
                                        }
                                        else if (ascInfo.getSubClass().equals(ASCInfo.AXON))
                                        {
                                            connectingSeg.getSection().addToGroup(Section.AXONAL_GROUP);
                                        }
                                        else
                                        {
                                            connectingSeg.getSection().addToGroup(ascInfo.getSubClass());
                                        }
                                    }
                                    logger.logComment("Added Connecting seg: " + connectingSeg);
                                }
                                else
                                {
                                    logger.logComment("First point on new branch is same as parent endpoint (or connected to root seg). "
                                        +"Waiting for second point to add first segment...");
                                    ascInfo.setLastSegThisBranch(null);
                                }
                            }
                            else if (ascInfo.getLastSegThisBranch() == null) // New (sub) branch
                            {
                                logger.logComment("Case: first point was same as parent endpoint (or parent is root), adding first seg");

                                PointInfo start = ascInfo.getStartPointBranch();

                                logger.logComment("Start point: "+ start);

                                if (start.equals(ascLine.getPoint()))
                                {
                                    logger.logComment("Same x,y,z,diam as parent point! Ignoring!!");
                                }
                                else
                                {

                                    Segment parent = null;

                                    parent = ascInfo.getLowerBranchEndSegs().getLast();

                                    float fractAlong = 1;

                                    logger.logComment("Branches so far: " + ascInfo.getLowerBranchEndSegs());

                                    boolean addConnectingSegment = ascInfo.getLowerBranchEndSegs().size() != 1 // not root seg
                                        && parent.getEndPointPosition().distance(start.getPoint3f()) != 0;

                                    Segment newSeg =
                                        cell.addDendriticSegment(ascLine.getPoint().diam / 2,
                                                                 segName,
                                                                 ascLine.getPoint().getPoint3f(),
                                                                 parent,
                                                                 fractAlong,
                                                                 secName,
                                                                 daughtersInherit);

                                    newSeg.setComment("First segment of new sub branch");

                                    if (!addConnectingSegment)
                                    {
                                        newSeg.getSection().setStartPointPositionX(start.x);
                                        newSeg.getSection().setStartPointPositionY(start.y);
                                        newSeg.getSection().setStartPointPositionZ(start.z);
                                        newSeg.getSection().setStartRadius(start.diam / 2);
                                    }

                                    ascInfo.setLastSegThisBranch(newSeg);

                                    if (ascInfo.getPreferredColour() != null)
                                        newSeg.getSection().addToGroup("colour_" + ascInfo.getPreferredColour());

                                    if (ascInfo.getSubClass() != null)
                                    {
                                        if (ascInfo.getSubClass().equals(ASCInfo.DENDRITE))
                                        {
                                            logger.logComment("It's a dendrite...");
                                            // Not interesting subclass...
                                        }
                                        else if (ascInfo.getSubClass().equals(ASCInfo.AXON))
                                        {
                                            logger.logComment("It's an axon...");
                                            newSeg.getSection().addToGroup(Section.AXONAL_GROUP);
                                        }
                                        else
                                        {
                                            logger.logComment("It seems it's a " + ascInfo.getSubClass() + "...");
                                            newSeg.getSection().addToGroup(ascInfo.getSubClass());
                                        }
                                    }
                                    else
                                    {
                                        logger.logComment("Null subclass");

                                    }
                                    logger.logComment("Added new first points seg: " + newSeg);
                                    logger.logComment("Added new first points sec: " + newSeg.getSection());

                                }

                            }
                            else
                            {
                                // case: "normal" neurite...

                                if (ascLine.getPoint().getPoint3f().equals(ascInfo.getLastSegThisBranch().getEndPointPosition())&&
                                    ascLine.getPoint().getRadius()  == ascInfo.getLastSegThisBranch().getRadius())
                                {
                                    logger.logComment("Not adding point! Same point as parent point!!");
                                }
                                else
                                {

                                    Segment newSeg =
                                        cell.addDendriticSegment(ascLine.getPoint().diam / 2,
                                                                 segName,
                                                                 new Point3f(ascLine.getPoint().x,
                                                                             ascLine.getPoint().y,
                                                                             ascLine.getPoint().z),
                                                                 ascInfo.getLastSegThisBranch(),
                                                                 1,
                                                                 ascInfo.getLastSegThisBranch().getSection().
                                                                 getSectionName(),
                                                                 daughtersInherit);

                                    //newSeg.setComment("normal...");

                                    if (ascInfo.getSubClass() != null && ascInfo.getSubClass().equals(ASCInfo.AXON))
                                    {
                                        logger.logComment("It's an axon...");
                                        newSeg.getSection().addToGroup(Section.AXONAL_GROUP);
                                    }

                                    ascInfo.setLastSegThisBranch(newSeg);

                                    logger.logComment("Added new seg: " + newSeg);
                                    logger.logComment("Its sec: " + newSeg.getSection());
                                }
                            }

                        }
                        else if (ascInfo.getState().equals(ASC_State.UNSUPPORTED_ELEMENT))
                        {
                            logger.logComment("Ignoring UNSUPPORTED_ELEMENT info...");
                        }




                        break;

                }

                logger.logComment("New state of asc info: "+ ascInfo.getState());


            }
            if (lineCount == 0)
            {
                GuiUtils.showErrorMessage(logger, "Error. No lines found in file: " + morphologyFile, null, null);
            }

            cell.setCellDescription(description.toString());

            if (unknownLines.size()>0)
                GuiUtils.showErrorMessage(logger, "Note: unidentified lines encountered in ASC file:\n"
                                          +unknownLines, null, null);
        }
        catch (IOException e)
        {
            GuiUtils.showErrorMessage(logger, "Error: " + e.getMessage(), e, null);
            return null;
        }
        logger.logComment("Completed parsing of file: " + morphologyFile);

        return cell;
    }

    public void includeSomaOutline(boolean inc)
    {
        this.includeSomaOutline = inc;
    }

    public void daughtersInherit(boolean adj)
    {
        this.daughtersInherit = adj;
    }



    /**
     * Removes commas, spaces from comments suggesting segment names, so R-2-1, 4
     * becomes R_2_1_4
     */
    private String cleanUpCommentForID(String comment, boolean allowIntegers)
    {
        if (comment == null) return this.getUniqueId()+"";

        if (!allowIntegers)
        {
            try
            {
                Integer.parseInt(comment); // found an int...
                return this.getUniqueId()+"";
            }
            catch(NumberFormatException nfe)
            {
                // allow, it's not an int
            }
        }


        String newComment = new String(comment);
        newComment = GeneralUtils.replaceAllTokens(newComment, "-", "_");
        newComment = GeneralUtils.replaceAllTokens(newComment, ",", "_");
        newComment = GeneralUtils.replaceAllTokens(newComment, " ", "");
        return newComment;
    }


    /**
     * Class to handle points in ASC lines
     */
    private class PointInfo
    {
        public float x, y, z;
        private float diam;

        @Override
        public String toString()
        {
            return "("+x+", "+y+", "+z+"), diam: "+ diam;
        }

        public Point3f getPoint3f()
        {
            return new Point3f(x,y,z);
        }
        public float getRadius()
        {
            return diam/2;
        }

        @Override
        public boolean equals(Object obj)
        {
            if (!(obj instanceof PointInfo)) return false;

            PointInfo pi = (PointInfo)obj;
            if (pi.getPoint3f().equals(this.getPoint3f()) &&
                pi.getRadius() == this.getRadius())
                return true;

            return false;
        }

    }


    /**
     * What part of the neuron is being referred to. Could be inside ASCInfo...
     */
    public enum ASC_State
    {
        ROOT,
        NEURITE,
        CELL_BODY,
        UNSUPPORTED_ELEMENT
    };

    /**
     * Class which contains state of ASC file
     */
    private class ASCInfo
    {

        public static final String CELL_BODY = "CellBody";
        public static final String DENDRITE = "Dendrite";
        public static final String APICAL = "Apical";
        public static final String AXON = "Axon";


        private String[] shapes = new String[]{"Dot", "OpenStar", "FilledQuadStar", "CircleArrow", "OpenCircle",
               "DoubleCircle", "OpenQuadStar", "CircleCross", "Cross", "Circle1",
               "Flower3", "Plus", "Circle2", "Pinwheel", "OpenUpTriangle", "Circle3",
               "TexacoStar", "OpenDownTriangle", "Circle4", "ShadedStar", "OpenSquare",
               "Circle5", "SkiBasket", "Asterisk", "Circle6", "Clock", "OpenDiamond",
               "Circle7", "ThinArrow", "FilledStar", "Circle8", "ThickArrow", "FilledCircle",
               "Circle9", "SquareGunSight", "FilledUpTriangle", "Flower2", "GunSight",
               "FilledDownTriangle", "SnowFlake", "TriStar", "FilledSquare", "OpenFinial",
               "NinjaStar", "FilledDiamond", "FilledFinial", "KnightsCross", "Flower", "MalteseCross", "Splat"};

        private String[] reservedWords = new String[]{"Sections", "ImageCoords", "Thumbnail"};

        private ASC_State myState = ASC_State.ROOT;
        private String preferredColour = null;
        private String subClass = null;
        private String prefix = null;

        private Segment lastSegThisBranch = null;
        private PointInfo startPointBranch = null;

        private LinkedList<Segment> lowerBranchEndSegs = new LinkedList<Segment>();

        private Vector<String> usedPrefixes = new Vector<String>();

        public void setState(ASC_State state)
        {
            this.myState = state;
        }
        public ASC_State getState()
        {
            return myState;
        }

        public LinkedList<Segment> getLowerBranchEndSegs()
        {
            return this.lowerBranchEndSegs;
        }

        public String getPreferredColour()
        {
            return preferredColour;
        }

        public void setPreferredColour(String colour)
        {
            this.preferredColour = colour;
        }

        public String getSubClass()
        {
            return subClass;
        }

        public void setSubClass(String subClass)
        {
            this.subClass = subClass;
        }

        public String getPrefix()
        {
            return prefix;
        }

        public void setPrefix(String suggPrefix)
        {
            if (suggPrefix==null) return;

            String newPrefix = new String(suggPrefix);
            int num = 0;

            while (usedPrefixes.contains(newPrefix))
            {
                if (newPrefix.indexOf("_")>0)
                {
                    //num = Integer.parseInt(prefix.substring(prefix.indexOf("_")+1));
                    num++;
                    newPrefix = newPrefix.substring(0,newPrefix.indexOf("_"))+"_" + num;
                }
                else
                {
                    newPrefix = suggPrefix+"_1";
                }
                System.out.println("Generated new prefix: "+ newPrefix);
            }

            usedPrefixes.add(newPrefix);
            this.prefix = newPrefix;
        }


        public String[] getShapes()
        {
            return shapes;
        }

        public String[] getReservedWords()
        {
            return this.reservedWords;
        }

        public Segment getLastSegThisBranch()
        {
            return lastSegThisBranch;
        }
        public PointInfo getStartPointBranch()
        {
            return startPointBranch;
        }

        public void setLastSegThisBranch(Segment seg)
        {
            lastSegThisBranch = seg;
        }
        public void setStartPointBranch(PointInfo point)
        {
            startPointBranch = point;
        }
    }

    /**
     * Could be inside ASCLine...
     */
    public enum ASCLine_State {UNKNOWN,                      // undetermined line, should be none...
                       EMPTY_LINE,                   // nothing present
                       COMMENT_ONLY,                 // only text after ;
                       OPENING_BRACKET,              // only ( before comment
                       CLOSING_BRACKET,              // only ) before comment
                       NORMAL,                       // Normal termination point
                       INCOMPLETE,                   // Incomplete termination point
                       HIGH,                         // "High" termination point
                       LOW,                          // "Low" termination point
                       ORIGIN,                       // "Origin" termination point
                       MIDDLE,                       // "Middle" termination point
                       GENERATED,                    // "Generated" termination point
                       SPLIT_MARK,                   // | character which occurs after Normal, Incomplete
                       POINT_SPEC,                   // line containing (x,y,z,diam)
                       BRACKETED_DIRECTIVE,          // line with text between brackets, e.g. (CellBody)
                       ANGLE_BRACKETED,              // this is used for spines, e.g. <(  -73.34   995.35   -34.44     0.97)>  ; Spine. Currently ignored
                       OPENING_BRACKET_DIRECTIVE};   // either ((Colour Red) or ("CellBody" etc.



    /**
     * Class to handle lines in ASC file
     */
    private class ASCLine
    {

        private ASCLine_State myState = ASCLine_State.UNKNOWN;
        private String comment = null;
        private String directive = null;
        private PointInfo point = null;

        private ASCLine(){};

        public ASCLine(String line)
        {
            String beforeComment = new String(line.trim());
            String afterComment = "";

            if (line.indexOf(";")>=0)
            {
                beforeComment = line.substring(0, line.indexOf(";")).trim();
                afterComment = line.substring(line.indexOf(";")+1).trim();
            }

            if (beforeComment.length()==0 && afterComment.length()==0)
            {
                myState = ASCLine_State.EMPTY_LINE;
                return;
            }

            if (afterComment.length()>0) comment = afterComment;

            if (beforeComment.length()==0)
            {
                myState = ASCLine_State.COMMENT_ONLY;
                return;
            }
            if (beforeComment.equals("Normal"))
            {
                myState = ASCLine_State.NORMAL;
                return;
            }
            if (beforeComment.equals("Incomplete"))
            {
                myState = ASCLine_State.INCOMPLETE;
                return;
            }
            if (beforeComment.equals("High"))
            {
                myState = ASCLine_State.HIGH;
                return;
            }
            if (beforeComment.equals("Low"))
            {
                myState = ASCLine_State.LOW;
                return;
            }
            if (beforeComment.equals("Origin"))
            {
                myState = ASCLine_State.ORIGIN;
                return;
            }
            if (beforeComment.equals("Middle"))
            {
                myState = ASCLine_State.MIDDLE;
                return;
            }

            if (beforeComment.equals("Generated"))
            {
                myState = ASCLine_State.GENERATED;
                return;
            }

            if (beforeComment.equals("|"))
            {
                myState = ASCLine_State.SPLIT_MARK;
                return;
            }


            if (beforeComment.equals("("))
            {
                myState = ASCLine_State.OPENING_BRACKET;
                return;
            }
            else if (beforeComment.equals(")"))
            {
                myState = ASCLine_State.CLOSING_BRACKET;
                return;
            }
            else if (beforeComment.startsWith("<") &&
                     beforeComment.endsWith(">"))
            {
                // I've only seen this used for specifying spines:
                // <(  -73.34   995.35   -34.44     0.97)>  ; Spine
                // Will ignore these lines...

                myState = ASCLine_State.ANGLE_BRACKETED;

                return;

            }
            else if (beforeComment.startsWith("(") &&
                     beforeComment.endsWith(")") &&
                     beforeComment.lastIndexOf("(")==0 &&
                     beforeComment.lastIndexOf(")") == beforeComment.length()-1)
            {

                String[] words = beforeComment.substring(1,beforeComment.length()-1).trim().split("\\s+");
                logger.logComment("Found: "+words.length+" words");

                try
                {
                    if (words.length == 4)
                    {
                        point = new PointInfo();
                        point.x = Float.parseFloat(words[0]);
                        point.y = Float.parseFloat(words[1]);
                        point.z = Float.parseFloat(words[2]);
                        point.diam = Float.parseFloat(words[3]);

                        myState = ASCLine_State.POINT_SPEC;

                        return;
                    }
                }
                catch(NumberFormatException nfe)
                {
                    logger.logError("Must not have been a point specification: "+ beforeComment);
                }
                directive = beforeComment.substring(1,beforeComment.length()-1).trim();
                myState = ASCLine_State.BRACKETED_DIRECTIVE;
                return;
            }
            else if (beforeComment.startsWith("("))
            {
                String restOfLine = beforeComment.substring(1).trim();

                if (restOfLine.startsWith("(") &&
                    restOfLine.endsWith(")"))
                {
                     directive = restOfLine.substring(1,restOfLine.length()-1).trim();
                     myState = ASCLine_State.OPENING_BRACKET_DIRECTIVE;
                     return;
                 }
                 // For simplicity treat this type of line the same: ("CellBody"
                 else if (restOfLine.startsWith("\"") &&
                     restOfLine.endsWith("\""))
                 {
                      directive = restOfLine.substring(1,restOfLine.length()-1).trim();
                      myState = ASCLine_State.OPENING_BRACKET_DIRECTIVE;
                      return;
                  }
                  // Treat these cases as known directives...
                  else
                  {
                      ASCInfo tempAscInfo = new ASCInfo();
                      String[] shapes = tempAscInfo.getShapes();

                      for (int i = 0; i < shapes.length; i++)
                      {
                          if (restOfLine.equals(shapes[i]))
                          {
                              directive = restOfLine;
                              myState = ASCLine_State.OPENING_BRACKET_DIRECTIVE;
                              return;
                          }
                      }
                  }



                 myState = ASCLine_State.UNKNOWN;
                 return;

            }

        }

        public ASCLine_State getState()
        {
            return myState;
        }

        public String getComment()
        {
            return comment;
        }
        public String getDirective()
        {
            return directive;
        }
        public PointInfo getPoint()
        {
            return point;
        }


    }

    private int getUniqueId()
    {
        return uniqueId++;
    }



    public static void main(String[] args)
    {
        //File f = new File("../temp/antena.asc");
        //File f = new File("../temp/rtest.asc");
        //File f = new File("../temp/cell.asc");
        File f = new File("../../../angus_server/Padraig/Datas/neurolucida/simple.asc");
        //File f = new File("../downloads/C030796A-P2.asc");
        //File f = new File("Y:/Padraig/Datas/neurolucida/newFiles/e040420Amni.asc");
        //File f = new File("../temp/final.asc");
        //File f = new File("../temp/multi.asc");

        try
        {
            System.out.println("Starting...");
            GeneralUtils.timeCheck("Before loading file");


            NeurolucidaReader nlReader = new NeurolucidaReader();

            NeurolucidaImportOptions dlg = new NeurolucidaImportOptions(new Frame(), "Neurolucida options", true);

            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
            Dimension frameSize = dlg.getSize();
            if (frameSize.height > screenSize.height)
            {
                frameSize.height = screenSize.height;
            }
            if (frameSize.width > screenSize.width)
            {
                frameSize.width = screenSize.width;
            }
            dlg.setLocation( (screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);
            dlg.setVisible(true);

            nlReader.includeSomaOutline(dlg.includeSomaOutline());
            nlReader.daughtersInherit(dlg.daughtersInherit());


            Cell nlCell = nlReader.loadFromMorphologyFile(f, "NlCell");


            GeneralUtils.timeCheck("After loading file");

            System.out.println(CellTopologyHelper.printDetails(nlCell, null));

            GeneralUtils.timeCheck("After showing cell info...");

            //Thread.sleep(3000);

            System.out.println("All done...");


        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }

}
