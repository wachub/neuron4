/**
 *  neuroConstruct
 *  Software for developing large scale 3D networks of biologically realistic neurons
 * 
 *  Copyright (c) 2009 Padraig Gleeson
 *  UCL Department of Neuroscience, Physiology and Pharmacology
 *
 *  Development of this software was made possible with funding from the
 *  Medical Research Council and the Wellcome Trust
 *  
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package ucl.physiol.neuroconstruct.cell;

import java.io.Serializable;
import java.util.*;
import javax.vecmath.*;

import ucl.physiol.neuroconstruct.cell.examples.*;
import ucl.physiol.neuroconstruct.j3D.*;
import ucl.physiol.neuroconstruct.utils.compartment.*;
import ucl.physiol.neuroconstruct.utils.ClassLogger;
import ucl.physiol.neuroconstruct.utils.GeneralUtils;

/**
 *
 * A Segment which is the basic unit of somas, dendrites and axons. Segments belong
 * to Sections, with the Section providing the start point and radius, and the segments
 * specifying the points along a section
 *
 * @author Padraig Gleeson
 *  
 *
 */


public class Segment implements Serializable
{
    static final long serialVersionUID = 6877533563271791697L;
    
    private transient ClassLogger logger = new ClassLogger("Segment");
    
    /**
     * Name given to Segment, unique within a cell
     */
    private String segmentName = null;

    /**
     * Reference to parent Segment
     */
    private Segment parentSegment = null;


    /**
     * Unique (for this Cell) Id for the Segment. They should all be >=0 and ideally ascending
     * This is given a funny initial value to ensure the actual value is written to the
     * XML file generated by XMLEncoder
     */
    private int segmentId = Integer.MAX_VALUE;


    /**
     * Fraction along parent *Segment*, NOT fraction along parent section, as a statement like
     * 'soma connect dend1[0] (0), 0.5' in NEURON would mean
     */
    private float fractionAlongParent = 1;

    /**
     * Section to which this Segment belongs
     */
    private Section section = null;

    /**
     * Whether the volume of this segment should be taken into account for packing...
     */
    private boolean finiteVolume = false;

    /**
     * Added so that if anything funny happens in import, a comment can be added
     * to explain what's going on. No functional relevance, but can be printed in Cell Info
     * and included with MorphML export
     */
    private String comment = null;


    // This is set so, to ensure some values (especially 0) are put into the xml
    // representation of endPointPosition. If new Point3f() was used, XMLEncoder
    // wouldn't generate x, y, z entries in XML if x=0, etc.
    private Point3f endPointPosition = new Point3f(Float.NaN, Float.NaN, Float.NaN);


    /**
     * Radius of the end point of the Segment.
     * This is given a funny initial value to ensure the actual value is written to the
     * XML file generated by XMLEncoder
     */
    private float radius = Float.MAX_VALUE;

    /**
     * Flag to say the segment/cell has been altered after loading. When project is saved only edited cells will
     * have their morphologies re saved. Note this is not foolproof as the
     */
    //private boolean edited = false;

    
    public static int UNDETERMINED_SHAPE = -1;
    public static int SPHERICAL_SHAPE = 0;
    public static int CYLINDRICAL_SHAPE = 1;

    
    // Used during rotations etc. to prevent x = 10.00001 etc.
    private static final float roundingError = 8e-4f;
    
    /**
     * This needs to be public for XMLEncoder. DON'T USE IT ON ITS OWN!
     */
    public Segment()
    {
    }



    /**
     * For adding a soma, axon or dendrite segment
     */
    protected Segment(String segmentName,
                   float radius,
                   Point3f endPosition,
                   int segmentId,
                   Segment parentSegment,
                   float fractionAlongParent,
                   Section section)
    {
        if (fractionAlongParent<0) fractionAlongParent=0;
        if (fractionAlongParent>1) fractionAlongParent=1;

        this.fractionAlongParent = fractionAlongParent;
        this.segmentName = segmentName;
        this.radius = radius;
        this.endPointPosition = endPosition;
        if (endPointPosition==null) endPointPosition = new Point3f();

      //  if (parentSegment==null && endPointPosition.equals(new Point3f()))
      //      this.shape = SPHERICAL_SHAPE;
/*
        if (parentSegment == null ||
            !parentSegment.getSection().getSectionName().equals(section.getSectionName()))
        {
            // start of new section...
            firstSectionSegment = true;
        }
*/
        this.parentSegment = parentSegment;
        this.segmentId = segmentId;
        this.section = section;
    }

    /**
     * Note: This produced a clone of the Segment with most of the info intact
     * but DOESN'T clone the **parentSegment or Section**. These will be null and need to
     * be set outside this function. Shouldn't be used to create a new Segment for the existing
     * Cell but as part of cloning the whole cell!!
     * @see Cell#clone()
     */
    @Override
    public Object clone()
    {
        Segment newSegment = new Segment();

        newSegment.setSegmentName(segmentName);
        newSegment.setSegmentId(segmentId);
        newSegment.setParentSegment(null);
        newSegment.setSection(null);
        newSegment.setFractionAlongParent(fractionAlongParent);
        newSegment.setFiniteVolume(finiteVolume);
        newSegment.setRadius(radius);
        newSegment.setEndPointPositionX(endPointPosition.x);
        newSegment.setEndPointPositionY(endPointPosition.y);
        newSegment.setEndPointPositionZ(endPointPosition.z);
        newSegment.setComment(comment);
        // DOESN'T clone the **parentSegment or Section**

        return newSegment;
    }


    public Point3f getEndPointPosition()
    {
        return this.endPointPosition;
    }


    public Point3f getStartPointPosition()
    {
        if (this.isFirstSectionSegment())
        {
            if (section==null) return null;
            //System.out.println("sec: "+section);
            return section.getStartPointPosition();
        }

        /** @todo remove... */
        if (parentSegment.getSegmentId() == getSegmentId())
        {
            logger.logError("parentSegment: " + parentSegment.getSegmentName()+" and "+this.getSegmentName() +" have same id, so cannot getStartPointPosition()!!");
            return null;
        }

        if (parentSegment == null) return new Point3f(Float.NaN, Float.NaN, Float.NaN);

        Point3f startPoint = new Point3f();

        /**
         * This single line is the result of about 3 days debugging...
         */
        if (fractionAlongParent==1) return parentSegment.getEndPointPosition();


        startPoint.x = ( (1f - fractionAlongParent) * parentSegment.getStartPointPosition().x)
            + (fractionAlongParent * parentSegment.getEndPointPosition().x);
        startPoint.y = ( (1f - fractionAlongParent) * parentSegment.getStartPointPosition().y)
            + (fractionAlongParent * parentSegment.getEndPointPosition().y);
        startPoint.z = ( (1f - fractionAlongParent) * parentSegment.getStartPointPosition().z)
            + (fractionAlongParent * parentSegment.getEndPointPosition().z);

        return startPoint;

    }
    
    public int getSegmentsFromSoma()
    {
        int segmentsFromSoma = 0;
        
        Segment seg = this;
        
        if (!seg.isSomaSegment())
        {
            while (!seg.getParentSegment().isSomaSegment())
            {
                segmentsFromSoma = segmentsFromSoma + 1;
                seg = seg.getParentSegment();
            }
        }
        
        return segmentsFromSoma;
    }
    
    public float getDistanceFromSoma()
    {
        float somaDistance = 0;
        
        Segment seg = this;

        float fraction = seg.getFractionAlongParent();
        
        if (!seg.isSomaSegment())
        {
            while (!seg.getParentSegment().isSomaSegment())
            {
                seg = seg.getParentSegment();
                somaDistance = somaDistance + fraction*seg.getSegmentLength();
                fraction = seg.getFractionAlongParent();
            }
        }
        
        return somaDistance;
    }
         
    public Point3f getPointAlong(float fract)
    {
        if (this.isSpherical()) return new Point3f(endPointPosition);
        
        if (fract==1) return new Point3f(endPointPosition);
        if (fract==0) return new Point3f(getStartPointPosition());
        
        Point3f midPoint = new Point3f();
        
        midPoint.x = ( (1f - fract) * getStartPointPosition().x)
            + (fract * endPointPosition.x);
        midPoint.y = ( (1f - fract) * getStartPointPosition().y)
            + (fract * endPointPosition.y);
        midPoint.z = ( (1f - fract) * getStartPointPosition().z)
            + (fract * endPointPosition.z);

        return midPoint;
        
    }


    public float getSegmentStartRadius()
    {
        if (this.isFirstSectionSegment())
        {
            return section.getStartRadius();
        }

        if (parentSegment == null) return Float.NaN;

        return parentSegment.getRadius();

    }


    public float getSegmentSurfaceArea()
    {
        if (getStartPointPosition()==null)
        {
            return Float.NaN;
        }
        if (getSegmentShape()==SPHERICAL_SHAPE)
        {
            return 4 * (float)Math.PI * getSegmentStartRadius() * getSegmentStartRadius();
        }

        SimpleCompartment comp = new SimpleCompartment(getSegmentStartRadius(),
                                                       getRadius(),
                                                       getSegmentLength());

        return (float)comp.getCurvedSurfaceArea();
    }

/*
    public boolean isEdited()
    {
        return this.edited;
    }

    public void setAsUnedited()
    {
        this.edited = false;
    }
*/

    public float getSegmentLength()
    {
        if (getStartPointPosition()==null)
        {
            return Float.NaN;
        }
        return endPointPosition.distance(getStartPointPosition());
    }


    public float getSegmentVolume()
    {
        if (getStartPointPosition()==null)
        {
            return Float.NaN;
        }
        if (this.isSpherical())
            return (float)((4/3f)*Math.PI*getRadius()*getRadius()*getRadius());

        return (float)(new SimpleCompartment(this)).getVolume();
    }




    public Segment getParentSegment()
    {
        return this.parentSegment;
    }




    /**
     * Gets the radius at the END of the Segment
     */
    public float getRadius()
    {
        return radius;
    }

    public void setRadius(float radius)
    {
        this.radius = radius;
    }


    public boolean isAxonalSegment()
    {
        if (section.getGroups().contains(Section.AXONAL_GROUP)) return true;
        return false;
    }

    public boolean isDendriticSegment()
    {
        if (section.getGroups().contains(Section.DENDRITIC_GROUP)) return true;
        return false;
    }

    public boolean isSomaSegment()
    {
        if (section==null) return false;
        if (section.getGroups().contains(Section.SOMA_GROUP)) return true;
        return false;
    }

    public boolean isRootSegment()
    {
        return isSomaSegment() && isFirstSectionSegment();
    }


    public String toShortString()
    {

        return segmentName +" (ID: "+segmentId+")";
    }

    @Override
    public String toString()
    {
        StringBuffer sb = new StringBuffer();
        sb.append(segmentName);

        if (section == null) sb.append(", -- No section specified --");
        else sb.append(", section: " + section.getSectionName());

        if (getSegmentShape()==SPHERICAL_SHAPE) sb.append(", SPHERICAL");
        if (getSegmentShape()==UNDETERMINED_SHAPE) sb.append(", **UNDETERMINED SHAPE**");
        sb.append(", ID: " + segmentId );

        if(this.isFirstSectionSegment() && parentSegment == null)
        {
            sb.append(", ROOT SEGMENT");
        }
        else
        {
            if (parentSegment == null) sb.append(", -- NO PARENT --");
            else
            {
                sb.append(", parent: " + parentSegment.getSegmentName()+" ("+parentSegment.getSegmentId()+")");
                if (fractionAlongParent!=1)
                sb.append(", FRACT ALONG: " + fractionAlongParent);

            }
        }

        sb.append(", rad: " + radius);

        if (getStartPointPosition() == null)
            sb.append(", (-- NO PARENT --)");
        else
            sb.append(", " + getStartPointPosition());

        sb.append(" -> "+ getEndPointPosition());

        if (getSegmentShape()!=SPHERICAL_SHAPE) sb.append(", len: "+ Utils3D.trimDouble(this.getSegmentLength(), 6));

        if (isFiniteVolume()) sb.append(" (FINITE VOLUME)");

        if (comment!=null)  sb.append(" // "+comment);

        return sb.toString();

    }
    
    
    
    public String compareTo(Segment other, boolean html)
    {
        StringBuffer sb = new StringBuffer();
        String col = "black";
        col = segmentName.equals(other.getSegmentName())?"black":"red";
        sb.append(GeneralUtils.getColouredString(segmentName, col, html));

        if (section == null)
        {
            col = other.getSection()==null?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" -- No section specified --", col,html));
        }
        else
        {
            col = other.getSection().getSectionName().equals(section.getSectionName())?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" section: " + section.getSectionName(), col,html));
        }

        if (getSegmentShape()==SPHERICAL_SHAPE)
        {
            col = other.getSegmentShape()==SPHERICAL_SHAPE?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" SPHERICAL", col,html));
        }
        
        if (getSegmentShape()==UNDETERMINED_SHAPE)
        {
            col = other.getSegmentShape()==UNDETERMINED_SHAPE?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" **UNDETERMINED SHAPE**", col,html));
        }
        
        col = segmentId == other.getSegmentId()?"black":"red";
        sb.append(","+GeneralUtils.getColouredString(" ID: " + segmentId, col,html) );

        if(this.isFirstSectionSegment() && parentSegment == null)
        {
            col = (other.isFirstSectionSegment() && other.getParentSegment() == null)?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" ROOT SEGMENT", col,html));
        }
        else
        {
            if (parentSegment == null)
            {
                col = (other.getParentSegment() == null)?"black":"red";
                sb.append(","+GeneralUtils.getColouredString(" -- NO PARENT --", col,html));
            }
            else
            {
                col = (other.getParentSegment().getSegmentName().equals(parentSegment.getSegmentName()))?"black":"red";
                
                sb.append(","+GeneralUtils.getColouredString(" parent: " + parentSegment.getSegmentName(), col,html));
                
                col = (other.getParentSegment().getSegmentId() == parentSegment.getSegmentId())?"black":"red";
                
                sb.append(GeneralUtils.getColouredString(" ("+parentSegment.getSegmentId()+")", col,html));
                
                if (fractionAlongParent!=1)
                {
                    col = (other.getFractionAlongParent() == fractionAlongParent)?"black":"red";
                    sb.append(","+GeneralUtils.getColouredString(" FRACT ALONG: " + fractionAlongParent, col,html));
                }

            }
        }

        col = (other.getRadius() == radius)?"black":"red";
        
        sb.append(","+GeneralUtils.getColouredString(" rad: " + radius, col,html));

        if (getStartPointPosition() == null)
        {
            col = (other.getStartPointPosition()==null)?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" (-- NO PARENT --)", col,html));
        }
        else
        {
            col = (other.getStartPointPosition().equals(getStartPointPosition()))?"black":"red";
            sb.append(","+GeneralUtils.getColouredString(" " + getStartPointPosition(), col,html));
        }
        

        col = (other.getEndPointPosition().equals(getEndPointPosition()))?"black":"red";
        sb.append(GeneralUtils.getColouredString(" -> "+ getEndPointPosition(), col,html));

        String trimThis = Utils3D.trimDouble(this.getSegmentLength(), 6);
        String trimOther = Utils3D.trimDouble(other.getSegmentLength(), 6);
        
        if (getSegmentShape()!=SPHERICAL_SHAPE)
        {
            col = (trimThis.equals(trimOther))?"black":"red";
        
            sb.append(","+GeneralUtils.getColouredString(" len: "+ trimThis, col,html));
        }

        if (isFiniteVolume())
        {
            col = other.isFiniteVolume()?"black":"red";
            sb.append(GeneralUtils.getColouredString(" (FINITE VOLUME)", col,html));
        }

        if (comment!=null)
        {
            col = (other.getComment()!=null && other.getComment().equals(comment))?"black":"red";
            sb.append(GeneralUtils.getColouredString(" // "+comment, col,html));
        }

        return sb.toString();

    }



    public String toHTMLString(boolean includeTabs)
    {
        if (!includeTabs) return toString();

        StringBuffer sb = new StringBuffer();
        sb.append("<span style=\"color:blue;font-weight:bold\">"+segmentName+"</span>");

        if (section == null) sb.append(", -- No section specified --");
        else sb.append(", section: " + section.getSectionName());

        if (getSegmentShape()==SPHERICAL_SHAPE) sb.append(", SPHERICAL");
        sb.append(", ID: " + segmentId );

        if(this.isFirstSectionSegment() && isSomaSegment()) sb.append(", ROOT SEGMENT");
        else
        {
            if (parentSegment == null) sb.append(", -- NO PARENT --");
            else
            {
                sb.append(", parent: " + parentSegment.getSegmentName());
                if (fractionAlongParent!=1)
                sb.append(", FRACT ALONG: " + fractionAlongParent);

            }
        }

        sb.append(", rad: " + radius);

        if (getStartPointPosition() == null)
            sb.append(", (-- NO PARENT --)");
        else
            sb.append(", " + getStartPointPosition());

        sb.append(" -> "+ getEndPointPosition());

        if (getSegmentShape()!=SPHERICAL_SHAPE) sb.append(", len: "+ Utils3D.trimDouble(this.getSegmentLength(), 5));

        if (isFiniteVolume()) sb.append(" (FINITE VOLUME)");

        if (comment!=null)  sb.append("<span style=\"color:#A9A9A9;font-weight:bold\">"+" // "+comment+"</span>");

        return sb.toString();

    }



    public Vector<String> getGroups()
    {
        return section.getGroups();
    }



    public static void main(String[] args)
    {
        Section sec = new Section("sec1");
        sec.addToGroup(Section.SOMA_GROUP);
        sec.setStartPointPositionX(0);
        sec.setStartPointPositionY(0);
        sec.setStartPointPositionZ(0);

        System.out.println("Section: "+sec);

        Segment s1 = new Segment("s1", 111, new Point3f(1,1,1), 0, null, 1, sec);

        Segment s2 = new Segment("s2", 222, new Point3f(2,2,2), 222, s1, 1, sec);

        System.out.println("s1: "+ s1);
        System.out.println("s2: "+ s2);
        System.out.println("s2 section: "+ s2.getSection());

        Segment s3 = null;
        try
        {
            s3 = (Segment) s2.clone();

            System.out.println("s3: "+ s3);
            System.out.println("s3 section: "+ s3.getSection());

        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
        try
        {
            Cell cell = new SimpleCell("Copm");

            System.out.println("Cell: " + cell);

            int id = 3;

            Segment aSeg = cell.getSegmentWithId(id);

            aSeg.setComment("created...");

            System.out.println("Orig seg :" + aSeg);

            Cell cCell = (Cell) cell.clone();

            System.out.println("New Cell: " + cCell);

            Segment cSeg = cCell.getSegmentWithId(id);

            System.out.println("New seg :" + aSeg);

            System.out.println("Equals: " + aSeg.fullEquals(cSeg));
            
            aSeg.setEndPointPositionX(9.9999999f, true);
            
            System.out.println("New seg :" + aSeg);
            
            
            
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }


    }


    public String getSegmentName()
    {
        return this.segmentName;
    }

    public String getComment()
    {
        return this.comment;
    }


    public boolean isFiniteVolume()
    {
        return finiteVolume;
    }

    public void setFiniteVolume(boolean finiteVolume)
    {
        //this.edited = true;
        this.finiteVolume = finiteVolume;
    }



    public void setSegmentName(String segmentName)
    {
        //this.edited = true;
        if (segmentName != null && segmentName.trim().length() > 0)
            this.segmentName = segmentName;
    }

    public void setComment(String comment)
    {
        //this.edited = true;
        this.comment = comment;
    }




    /**
     * These funcs are needed as Point3f etc. aren't too compatible with
     * XMLEncoder, there aren't get/sets for x,y,z...
     */
    public void setEndPointPositionX(float val)
    {
        //this.edited = true;
        this.endPointPosition.x = val;
    }

    public void setEndPointPositionY(float val)
    {
        //this.edited = true;
        this.endPointPosition.y = val;
    }

    public void setEndPointPositionZ(float val)
    {
        //this.edited = true;
        this.endPointPosition.z = val;
    }
    
    protected static float round(float val)
    {

        if (val - Math.floor(val) >= 0 && val - Math.floor(val) < roundingError)
        {
            return (float)Math.floor(val);
        }
        else if (Math.ceil(val) - val >=0 && Math.ceil(val) - val < roundingError)
        {
            return (float)Math.ceil(val);
        }
        return val;            
        
    }
    
    public void setEndPointPositionX(float val, boolean round)
    {
        if (round) 
            val = round(val);
        this.endPointPosition.x = val;
    }

    public void setEndPointPositionY(float val, boolean round)
    {
        if (round) 
            val = round(val);
        this.endPointPosition.y = val;
    }

    public void setEndPointPositionZ(float val, boolean round)
    {
        if (round) 
            val = round(val);
        this.endPointPosition.z = val;
    }
    
    

    public float getEndPointPositionX()
    {
        return this.endPointPosition.x;
    }

    public float getEndPointPositionY()
    {
        return this.endPointPosition.y;
    }

    public float getEndPointPositionZ()
    {
        return this.endPointPosition.z;
    }

    public void setParentSegment(Segment parentSegment)
    {
        this.parentSegment = parentSegment;
    }

    public int getSegmentId()
    {
        return segmentId;
    }
    public void setSegmentId(int segmentId)
    {
        //this.edited = true;
        this.segmentId = segmentId;
    }


    public boolean isFirstSectionSegment()
    {
        if (parentSegment == null ||
            !parentSegment.getSection().equals(section))
        {
            return true;
        }
        return false;
    }

    /**
     * This equals function is used when calling CellTopologyHelper.compare( , )
     */
    public boolean fullEquals(Object obj)
    {
        if (!equals(obj)) return false;
        Segment other = (Segment)obj;

        if (getSection()!=null && other.getSection()!=null)
        {
            if (!getSection().getSectionName().equals(other.getSection().getSectionName()))
            {
                //logger.logComment("Sections do not match");
                return false;
            }
        }

        if (getParentSegment() != null && other.getParentSegment() != null)
        {
            if (getParentSegment().getSegmentId() != other.getParentSegment().getSegmentId())
            {
                //logger.logComment("Parent Sections do not match");
                return false;
            }
        }


        return true;
    }

    /*
    * Note the equals function is mainly used during the cloning of cells, when the
    * parent segment and section aren't set. therefore the check on identity of parents isn't made here!
    *
    */
    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Segment)
        {
            Segment other = (Segment)obj;

            if (!other.getSegmentName().equals(this.segmentName)) return false;

            /*
            * Note the equals function is mainly used during the cloning of cells, when the
            * parent segment and section aren't set. therefore the check on identity of parents isn't made here!
            *

            if (parentSegment==null)
            {
                if (other.getParentSegment()!=null)  return false;
            }
            else
            {
                if (!other.getParentSegment().equals(parentSegment))  return false;
            }

            if (!other.getSection().equals(section)) return false;

            */

            if (other.getSegmentId()!= this.segmentId) return false;

            if (other.getFractionAlongParent()!= this.fractionAlongParent) return false;


            if (other.isFiniteVolume()!= this.finiteVolume) return false;

            if (comment==null)
            {
                if (other.getComment()!=null)  return false; // not important but throw it in anyway for completeness
            }
            else
            {
                if (other.getComment()==null)  return false;
                if (!other.getComment().equals(comment))  return false;
            }

            if (!other.getEndPointPosition().equals(endPointPosition)) return false;

            if (other.getRadius()!= this.radius) return false;

            return true;
        }
        return false;
    }
    
    
    

    // NetBeans generated hashCode
    @Override
    public int hashCode()
    {
        int hash = 3;
        hash = 59 * hash + (this.segmentName != null ? this.segmentName.hashCode() : 0);
        hash = 59 * hash + this.segmentId;
        hash = 59 * hash + Float.floatToIntBits(this.fractionAlongParent);
        hash = 59 * hash + (this.finiteVolume ? 1 : 0);
        hash = 59 * hash + (this.comment != null ? this.comment.hashCode() : 0);
        hash = 59 * hash + (this.endPointPosition != null ? this.endPointPosition.hashCode() : 0);
        hash = 59 * hash + Float.floatToIntBits(this.radius);
        return hash;
    }


    public int getSegmentShape()
    {
        Point3f startPoint = getStartPointPosition();
        if (startPoint==null)
        {
            return UNDETERMINED_SHAPE;
        }
        if (this.getEndPointPosition().equals(startPoint))
            return Segment.SPHERICAL_SHAPE; // by definition...
        else
            return Segment.CYLINDRICAL_SHAPE;
    }

    public boolean isSpherical()
    {
        return (getSegmentShape() == Segment.SPHERICAL_SHAPE);
    }

    public Section getSection()
    {
        return section;
    }
    public void setSection(Section section)
    {
        //this.edited = true;
        this.section = section;
    }
    public float getFractionAlongParent()
    {
        return fractionAlongParent;
    }
    public void setFractionAlongParent(float fractionAlongParent)
    {
        //this.edited = true;
        this.fractionAlongParent = fractionAlongParent;
    }


}
