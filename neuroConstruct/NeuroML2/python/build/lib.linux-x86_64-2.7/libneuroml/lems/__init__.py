#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated by generateDS.py version 2.7b_pg.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Lems(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, DefaultRun=None, Dimension=None, Unit=None, Include=None, ComponentType=None, Component=None):
        self.description = _cast(None, description)
        self.DefaultRun = DefaultRun
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
        if Include is None:
            self.Include = []
        else:
            self.Include = Include
        if ComponentType is None:
            self.ComponentType = []
        else:
            self.ComponentType = ComponentType
        if Component is None:
            self.Component = []
        else:
            self.Component = Component
    def factory(*args_, **kwargs_):
        if Lems.subclass:
            return Lems.subclass(*args_, **kwargs_)
        else:
            return Lems(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDefaultRun(self): return self.DefaultRun
    def setDefaultRun(self, DefaultRun): self.DefaultRun = DefaultRun
    def getDimension(self): return self.Dimension
    def setDimension(self, Dimension): self.Dimension = Dimension
    def addDimension(self, value): self.Dimension.append(value)
    def insertDimension(self, index, value): self.Dimension[index] = value
    def getUnit(self): return self.Unit
    def setUnit(self, Unit): self.Unit = Unit
    def addUnit(self, value): self.Unit.append(value)
    def insertUnit(self, index, value): self.Unit[index] = value
    def getInclude(self): return self.Include
    def setInclude(self, Include): self.Include = Include
    def addInclude(self, value): self.Include.append(value)
    def insertInclude(self, index, value): self.Include[index] = value
    def getComponentType(self): return self.ComponentType
    def setComponentType(self, ComponentType): self.ComponentType = ComponentType
    def addComponentType(self, value): self.ComponentType.append(value)
    def insertComponentType(self, index, value): self.ComponentType[index] = value
    def getComponent(self): return self.Component
    def setComponent(self, Component): self.Component = Component
    def addComponent(self, value): self.Component.append(value)
    def insertComponent(self, index, value): self.Component[index] = value
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='Lems', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lems')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lems'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Lems', fromsubclass_=False):
        if self.DefaultRun is not None:
            self.DefaultRun.export(outfile, level, namespace_, name_='DefaultRun')
        for Dimension_ in self.Dimension:
            Dimension_.export(outfile, level, namespace_, name_='Dimension')
        for Unit_ in self.Unit:
            Unit_.export(outfile, level, namespace_, name_='Unit')
        for Include_ in self.Include:
            Include_.export(outfile, level, namespace_, name_='Include')
        for ComponentType_ in self.ComponentType:
            ComponentType_.export(outfile, level, namespace_, name_='ComponentType')
        for Component_ in self.Component:
            Component_.export(outfile, level, namespace_, name_='Component')
    def hasContent_(self):
        if (
            self.DefaultRun is not None or
            self.Dimension or
            self.Unit or
            self.Include or
            self.ComponentType or
            self.Component
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Lems'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefaultRun is not None:
            showIndent(outfile, level)
            outfile.write('DefaultRun=model_.DefaultRun(\n')
            self.DefaultRun.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Dimension=[\n')
        level += 1
        for Dimension_ in self.Dimension:
            showIndent(outfile, level)
            outfile.write('model_.Dimension(\n')
            Dimension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Unit=[\n')
        level += 1
        for Unit_ in self.Unit:
            showIndent(outfile, level)
            outfile.write('model_.Unit(\n')
            Unit_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Include=[\n')
        level += 1
        for Include_ in self.Include:
            showIndent(outfile, level)
            outfile.write('model_.Include(\n')
            Include_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ComponentType=[\n')
        level += 1
        for ComponentType_ in self.ComponentType:
            showIndent(outfile, level)
            outfile.write('model_.ComponentType(\n')
            ComponentType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Component=[\n')
        level += 1
        for Component_ in self.Component:
            showIndent(outfile, level)
            outfile.write('model_.Component(\n')
            Component_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultRun':
            obj_ = DefaultRun.factory()
            obj_.build(child_)
            self.setDefaultRun(obj_)
        elif nodeName_ == 'Dimension':
            obj_ = Dimension.factory()
            obj_.build(child_)
            self.Dimension.append(obj_)
        elif nodeName_ == 'Unit':
            obj_ = Unit.factory()
            obj_.build(child_)
            self.Unit.append(obj_)
        elif nodeName_ == 'Include':
            obj_ = Include.factory()
            obj_.build(child_)
            self.Include.append(obj_)
        elif nodeName_ == 'ComponentType':
            obj_ = ComponentType.factory()
            obj_.build(child_)
            self.ComponentType.append(obj_)
        elif nodeName_ == 'Component':
            obj_ = Component.factory()
            obj_.build(child_)
            self.Component.append(obj_)
# end class Lems


class Include(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file=None):
        self.file = _cast(None, file)
        pass
    def factory(*args_, **kwargs_):
        if Include.subclass:
            return Include.subclass(*args_, **kwargs_)
        else:
            return Include(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFile(self): return self.file
    def setFile(self, file): self.file = file
    def export(self, outfile, level, namespace_='', name_='Include', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Include')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Include'):
        if self.file is not None and 'file' not in already_processed:
            already_processed.append('file')
            outfile.write(' file=%s' % (self.gds_format_string(quote_attrib(self.file).encode(ExternalEncoding), input_name='file'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Include', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Include'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.file is not None and 'file' not in already_processed:
            already_processed.append('file')
            showIndent(outfile, level)
            outfile.write('file = "%s",\n' % (self.file,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.append('file')
            self.file = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Include


class DefaultRun(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, component=None):
        self.component = _cast(None, component)
        pass
    def factory(*args_, **kwargs_):
        if DefaultRun.subclass:
            return DefaultRun.subclass(*args_, **kwargs_)
        else:
            return DefaultRun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComponent(self): return self.component
    def setComponent(self, component): self.component = component
    def export(self, outfile, level, namespace_='', name_='DefaultRun', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultRun')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultRun'):
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            outfile.write(' component=%s' % (self.gds_format_string(quote_attrib(self.component).encode(ExternalEncoding), input_name='component'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultRun', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefaultRun'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            showIndent(outfile, level)
            outfile.write('component = "%s",\n' % (self.component,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.append('component')
            self.component = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DefaultRun


class Dimension(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, i=0, k=0, m=0, l=0, n=0, t=0):
        self.name = _cast(None, name)
        self.i = _cast(int, i)
        self.k = _cast(int, k)
        self.m = _cast(int, m)
        self.l = _cast(int, l)
        self.n = _cast(int, n)
        self.t = _cast(int, t)
        pass
    def factory(*args_, **kwargs_):
        if Dimension.subclass:
            return Dimension.subclass(*args_, **kwargs_)
        else:
            return Dimension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getI(self): return self.i
    def setI(self, i): self.i = i
    def getK(self): return self.k
    def setK(self, k): self.k = k
    def getM(self): return self.m
    def setM(self, m): self.m = m
    def getL(self): return self.l
    def setL(self, l): self.l = l
    def getN(self): return self.n
    def setN(self, n): self.n = n
    def getT(self): return self.t
    def setT(self, t): self.t = t
    def export(self, outfile, level, namespace_='', name_='Dimension', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Dimension')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Dimension'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.k is not None and 'k' not in already_processed:
            already_processed.append('k')
            outfile.write(' k="%s"' % self.gds_format_integer(self.k, input_name='k'))
        if self.m is not None and 'm' not in already_processed:
            already_processed.append('m')
            outfile.write(' m="%s"' % self.gds_format_integer(self.m, input_name='m'))
        if self.l is not None and 'l' not in already_processed:
            already_processed.append('l')
            outfile.write(' l="%s"' % self.gds_format_integer(self.l, input_name='l'))
        if self.n is not None and 'n' not in already_processed:
            already_processed.append('n')
            outfile.write(' n="%s"' % self.gds_format_integer(self.n, input_name='n'))
        if self.t is not None and 't' not in already_processed:
            already_processed.append('t')
            outfile.write(' t="%s"' % self.gds_format_integer(self.t, input_name='t'))
    def exportChildren(self, outfile, level, namespace_='', name_='Dimension', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Dimension'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.k is not None and 'k' not in already_processed:
            already_processed.append('k')
            showIndent(outfile, level)
            outfile.write('k = %d,\n' % (self.k,))
        if self.m is not None and 'm' not in already_processed:
            already_processed.append('m')
            showIndent(outfile, level)
            outfile.write('m = %d,\n' % (self.m,))
        if self.l is not None and 'l' not in already_processed:
            already_processed.append('l')
            showIndent(outfile, level)
            outfile.write('l = %d,\n' % (self.l,))
        if self.n is not None and 'n' not in already_processed:
            already_processed.append('n')
            showIndent(outfile, level)
            outfile.write('n = %d,\n' % (self.n,))
        if self.t is not None and 't' not in already_processed:
            already_processed.append('t')
            showIndent(outfile, level)
            outfile.write('t = %d,\n' % (self.t,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('k', node)
        if value is not None and 'k' not in already_processed:
            already_processed.append('k')
            try:
                self.k = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('m', node)
        if value is not None and 'm' not in already_processed:
            already_processed.append('m')
            try:
                self.m = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('l', node)
        if value is not None and 'l' not in already_processed:
            already_processed.append('l')
            try:
                self.l = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.append('n')
            try:
                self.n = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.append('t')
            try:
                self.t = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Dimension


class Unit(GeneratedsSuper):
    """Some have asked whether fractional dimensions should be allowed.
    Disallowing it until needed..."""
    subclass = None
    superclass = None
    def __init__(self, powTen=0, symbol=None, scale=1, dimension=None, offset=0):
        self.powTen = _cast(int, powTen)
        self.symbol = _cast(None, symbol)
        self.scale = _cast(float, scale)
        self.dimension = _cast(None, dimension)
        self.offset = _cast(float, offset)
        pass
    def factory(*args_, **kwargs_):
        if Unit.subclass:
            return Unit.subclass(*args_, **kwargs_)
        else:
            return Unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPowTen(self): return self.powTen
    def setPowTen(self, powTen): self.powTen = powTen
    def getSymbol(self): return self.symbol
    def setSymbol(self, symbol): self.symbol = symbol
    def getScale(self): return self.scale
    def setScale(self, scale): self.scale = scale
    def getDimension(self): return self.dimension
    def setDimension(self, dimension): self.dimension = dimension
    def getOffset(self): return self.offset
    def setOffset(self, offset): self.offset = offset
    def export(self, outfile, level, namespace_='', name_='Unit', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Unit')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Unit'):
        if self.powTen is not None and 'powTen' not in already_processed:
            already_processed.append('powTen')
            outfile.write(' powTen="%s"' % self.gds_format_integer(self.powTen, input_name='powTen'))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            outfile.write(' symbol=%s' % (self.gds_format_string(quote_attrib(self.symbol).encode(ExternalEncoding), input_name='symbol'), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            outfile.write(' scale="%s"' % self.gds_format_float(self.scale, input_name='scale'))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (self.gds_format_string(quote_attrib(self.dimension).encode(ExternalEncoding), input_name='dimension'), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            outfile.write(' offset="%s"' % self.gds_format_float(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='', name_='Unit', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Unit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.powTen is not None and 'powTen' not in already_processed:
            already_processed.append('powTen')
            showIndent(outfile, level)
            outfile.write('powTen = %d,\n' % (self.powTen,))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            showIndent(outfile, level)
            outfile.write('symbol = "%s",\n' % (self.symbol,))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            showIndent(outfile, level)
            outfile.write('scale = %f,\n' % (self.scale,))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = "%s",\n' % (self.dimension,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            showIndent(outfile, level)
            outfile.write('offset = %f,\n' % (self.offset,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('powTen', node)
        if value is not None and 'powTen' not in already_processed:
            already_processed.append('powTen')
            try:
                self.powTen = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            self.symbol = value
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            try:
                self.scale = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (scale): %s' % exp)
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            try:
                self.offset = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (offset): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Unit


class DerivedParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, dimension='none'):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.dimension = _cast(None, dimension)
        pass
    def factory(*args_, **kwargs_):
        if DerivedParameter.subclass:
            return DerivedParameter.subclass(*args_, **kwargs_)
        else:
            return DerivedParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def getDimension(self): return self.dimension
    def setDimension(self, dimension): self.dimension = dimension
    def export(self, outfile, level, namespace_='', name_='DerivedParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedParameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (self.gds_format_string(quote_attrib(self.dimension).encode(ExternalEncoding), input_name='dimension'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedParameter', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivedParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = "%s",\n' % (self.dimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DerivedParameter


class Constant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, value=None, dimension='none'):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.dimension = _cast(None, dimension)
        pass
    def factory(*args_, **kwargs_):
        if Constant.subclass:
            return Constant.subclass(*args_, **kwargs_)
        else:
            return Constant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def validate_PhysicalQuantity(self, value):
        # Validate type PhysicalQuantity, a restriction on xs:string.
        pass
    def getDimension(self): return self.dimension
    def setDimension(self, dimension): self.dimension = dimension
    def export(self, outfile, level, namespace_='', name_='Constant', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Constant')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Constant'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (self.gds_format_string(quote_attrib(self.dimension).encode(ExternalEncoding), input_name='dimension'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Constant', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Constant'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = "%s",\n' % (self.dimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
            self.validate_PhysicalQuantity(self.value)    # validate type PhysicalQuantity
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Constant


class ComponentRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None):
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if ComponentRef.subclass:
            return ComponentRef.subclass(*args_, **kwargs_)
        else:
            return ComponentRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='ComponentRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComponentRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComponentRef'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ComponentRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ComponentRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ComponentRef


class Child(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None):
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if Child.subclass:
            return Child.subclass(*args_, **kwargs_)
        else:
            return Child(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Child', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Child')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Child'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Child', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Child'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Child


class Attachments(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, description=None):
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if Attachments.subclass:
            return Attachments.subclass(*args_, **kwargs_)
        else:
            return Attachments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='Attachments', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attachments')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Attachments'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Attachments', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attachments'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Attachments


class EventPort(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, direction=None, name=None, description=None):
        self.direction = _cast(None, direction)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if EventPort.subclass:
            return EventPort.subclass(*args_, **kwargs_)
        else:
            return EventPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDirection(self): return self.direction
    def setDirection(self, direction): self.direction = direction
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='EventPort', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventPort')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventPort'):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            outfile.write(' direction=%s' % (self.gds_format_string(quote_attrib(self.direction).encode(ExternalEncoding), input_name='direction'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventPort', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EventPort'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            showIndent(outfile, level)
            outfile.write('direction = "%s",\n' % (self.direction,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            self.direction = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventPort


class Fixed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameter=None, description=None, value=None):
        self.parameter = _cast(None, parameter)
        self.description = _cast(None, description)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if Fixed.subclass:
            return Fixed.subclass(*args_, **kwargs_)
        else:
            return Fixed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def validate_PhysicalQuantity(self, value):
        # Validate type PhysicalQuantity, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Fixed', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Fixed')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Fixed'):
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.append('parameter')
            outfile.write(' parameter=%s' % (self.gds_format_string(quote_attrib(self.parameter).encode(ExternalEncoding), input_name='parameter'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Fixed', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Fixed'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.append('parameter')
            showIndent(outfile, level)
            outfile.write('parameter = "%s",\n' % (self.parameter,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameter', node)
        if value is not None and 'parameter' not in already_processed:
            already_processed.append('parameter')
            self.parameter = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
            self.validate_PhysicalQuantity(self.value)    # validate type PhysicalQuantity
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Fixed


class Link(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, description=None):
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if Link.subclass:
            return Link.subclass(*args_, **kwargs_)
        else:
            return Link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='Link', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Link')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Link'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Link', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Link'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Link


class Children(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max=None, type_=None, name=None, min=None):
        self.max = _cast(int, max)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.min = _cast(int, min)
        pass
    def factory(*args_, **kwargs_):
        if Children.subclass:
            return Children.subclass(*args_, **kwargs_)
        else:
            return Children(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMax(self): return self.max
    def setMax(self, max): self.max = max
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getMin(self): return self.min
    def setMin(self, min): self.min = min
    def export(self, outfile, level, namespace_='', name_='Children', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Children')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Children'):
        if self.max is not None and 'max' not in already_processed:
            already_processed.append('max')
            outfile.write(' max="%s"' % self.gds_format_integer(self.max, input_name='max'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            outfile.write(' min="%s"' % self.gds_format_integer(self.min, input_name='min'))
    def exportChildren(self, outfile, level, namespace_='', name_='Children', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Children'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max is not None and 'max' not in already_processed:
            already_processed.append('max')
            showIndent(outfile, level)
            outfile.write('max = %d,\n' % (self.max,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            showIndent(outfile, level)
            outfile.write('min = %d,\n' % (self.min,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.append('max')
            try:
                self.max = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.append('min')
            try:
                self.min = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Children


class Path(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None):
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='Path', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Path')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Path'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Path', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Path'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Path


class Text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None):
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if Text.subclass:
            return Text.subclass(*args_, **kwargs_)
        else:
            return Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='Text', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Text')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Text'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Text', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Text'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Text


class StateVariable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, exposure=None, name=None, dimension='none'):
        self.description = _cast(None, description)
        self.exposure = _cast(None, exposure)
        self.name = _cast(None, name)
        self.dimension = _cast(None, dimension)
        pass
    def factory(*args_, **kwargs_):
        if StateVariable.subclass:
            return StateVariable.subclass(*args_, **kwargs_)
        else:
            return StateVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getExposure(self): return self.exposure
    def setExposure(self, exposure): self.exposure = exposure
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDimension(self): return self.dimension
    def setDimension(self, dimension): self.dimension = dimension
    def export(self, outfile, level, namespace_='', name_='StateVariable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateVariable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateVariable'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.exposure is not None and 'exposure' not in already_processed:
            already_processed.append('exposure')
            outfile.write(' exposure=%s' % (self.gds_format_string(quote_attrib(self.exposure).encode(ExternalEncoding), input_name='exposure'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (self.gds_format_string(quote_attrib(self.dimension).encode(ExternalEncoding), input_name='dimension'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StateVariable', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateVariable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.exposure is not None and 'exposure' not in already_processed:
            already_processed.append('exposure')
            showIndent(outfile, level)
            outfile.write('exposure = "%s",\n' % (self.exposure,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = "%s",\n' % (self.dimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('exposure', node)
        if value is not None and 'exposure' not in already_processed:
            already_processed.append('exposure')
            self.exposure = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StateVariable


class DerivedVariable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueCondition=None, reduce=None, value=None, onAbsent=None, valueIfFalse=None, dimension='none', select=None, exposure=None):
        self.name = _cast(None, name)
        self.valueCondition = _cast(None, valueCondition)
        self.reduce = _cast(None, reduce)
        self.value = _cast(None, value)
        self.onAbsent = _cast(None, onAbsent)
        self.valueIfFalse = _cast(None, valueIfFalse)
        self.dimension = _cast(None, dimension)
        self.select = _cast(None, select)
        self.exposure = _cast(None, exposure)
        pass
    def factory(*args_, **kwargs_):
        if DerivedVariable.subclass:
            return DerivedVariable.subclass(*args_, **kwargs_)
        else:
            return DerivedVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValueCondition(self): return self.valueCondition
    def setValueCondition(self, valueCondition): self.valueCondition = valueCondition
    def getReduce(self): return self.reduce
    def setReduce(self, reduce): self.reduce = reduce
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def getOnAbsent(self): return self.onAbsent
    def setOnAbsent(self, onAbsent): self.onAbsent = onAbsent
    def getValueIfFalse(self): return self.valueIfFalse
    def setValueIfFalse(self, valueIfFalse): self.valueIfFalse = valueIfFalse
    def getDimension(self): return self.dimension
    def setDimension(self, dimension): self.dimension = dimension
    def getSelect(self): return self.select
    def setSelect(self, select): self.select = select
    def getExposure(self): return self.exposure
    def setExposure(self, exposure): self.exposure = exposure
    def export(self, outfile, level, namespace_='', name_='DerivedVariable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedVariable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedVariable'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.valueCondition is not None and 'valueCondition' not in already_processed:
            already_processed.append('valueCondition')
            outfile.write(' valueCondition=%s' % (self.gds_format_string(quote_attrib(self.valueCondition).encode(ExternalEncoding), input_name='valueCondition'), ))
        if self.reduce is not None and 'reduce' not in already_processed:
            already_processed.append('reduce')
            outfile.write(' reduce=%s' % (self.gds_format_string(quote_attrib(self.reduce).encode(ExternalEncoding), input_name='reduce'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.onAbsent is not None and 'onAbsent' not in already_processed:
            already_processed.append('onAbsent')
            outfile.write(' onAbsent=%s' % (self.gds_format_string(quote_attrib(self.onAbsent).encode(ExternalEncoding), input_name='onAbsent'), ))
        if self.valueIfFalse is not None and 'valueIfFalse' not in already_processed:
            already_processed.append('valueIfFalse')
            outfile.write(' valueIfFalse=%s' % (self.gds_format_string(quote_attrib(self.valueIfFalse).encode(ExternalEncoding), input_name='valueIfFalse'), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (self.gds_format_string(quote_attrib(self.dimension).encode(ExternalEncoding), input_name='dimension'), ))
        if self.select is not None and 'select' not in already_processed:
            already_processed.append('select')
            outfile.write(' select=%s' % (self.gds_format_string(quote_attrib(self.select).encode(ExternalEncoding), input_name='select'), ))
        if self.exposure is not None and 'exposure' not in already_processed:
            already_processed.append('exposure')
            outfile.write(' exposure=%s' % (self.gds_format_string(quote_attrib(self.exposure).encode(ExternalEncoding), input_name='exposure'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedVariable', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivedVariable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.valueCondition is not None and 'valueCondition' not in already_processed:
            already_processed.append('valueCondition')
            showIndent(outfile, level)
            outfile.write('valueCondition = "%s",\n' % (self.valueCondition,))
        if self.reduce is not None and 'reduce' not in already_processed:
            already_processed.append('reduce')
            showIndent(outfile, level)
            outfile.write('reduce = "%s",\n' % (self.reduce,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.onAbsent is not None and 'onAbsent' not in already_processed:
            already_processed.append('onAbsent')
            showIndent(outfile, level)
            outfile.write('onAbsent = "%s",\n' % (self.onAbsent,))
        if self.valueIfFalse is not None and 'valueIfFalse' not in already_processed:
            already_processed.append('valueIfFalse')
            showIndent(outfile, level)
            outfile.write('valueIfFalse = "%s",\n' % (self.valueIfFalse,))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = "%s",\n' % (self.dimension,))
        if self.select is not None and 'select' not in already_processed:
            already_processed.append('select')
            showIndent(outfile, level)
            outfile.write('select = "%s",\n' % (self.select,))
        if self.exposure is not None and 'exposure' not in already_processed:
            already_processed.append('exposure')
            showIndent(outfile, level)
            outfile.write('exposure = "%s",\n' % (self.exposure,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('valueCondition', node)
        if value is not None and 'valueCondition' not in already_processed:
            already_processed.append('valueCondition')
            self.valueCondition = value
        value = find_attr_value_('reduce', node)
        if value is not None and 'reduce' not in already_processed:
            already_processed.append('reduce')
            self.reduce = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('onAbsent', node)
        if value is not None and 'onAbsent' not in already_processed:
            already_processed.append('onAbsent')
            self.onAbsent = value
        value = find_attr_value_('valueIfFalse', node)
        if value is not None and 'valueIfFalse' not in already_processed:
            already_processed.append('valueIfFalse')
            self.valueIfFalse = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
        value = find_attr_value_('select', node)
        if value is not None and 'select' not in already_processed:
            already_processed.append('select')
            self.select = value
        value = find_attr_value_('exposure', node)
        if value is not None and 'exposure' not in already_processed:
            already_processed.append('exposure')
            self.exposure = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DerivedVariable


class TimeDerivative(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, value=None):
        self.variable = _cast(None, variable)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if TimeDerivative.subclass:
            return TimeDerivative.subclass(*args_, **kwargs_)
        else:
            return TimeDerivative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='TimeDerivative', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeDerivative')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeDerivative'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeDerivative', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeDerivative'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeDerivative


class OnStart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StateAssignment=None):
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
    def factory(*args_, **kwargs_):
        if OnStart.subclass:
            return OnStart.subclass(*args_, **kwargs_)
        else:
            return OnStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStateAssignment(self): return self.StateAssignment
    def setStateAssignment(self, StateAssignment): self.StateAssignment = StateAssignment
    def addStateAssignment(self, value): self.StateAssignment.append(value)
    def insertStateAssignment(self, index, value): self.StateAssignment[index] = value
    def export(self, outfile, level, namespace_='', name_='OnStart', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnStart')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnStart'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OnStart', fromsubclass_=False):
        for StateAssignment_ in self.StateAssignment:
            StateAssignment_.export(outfile, level, namespace_, name_='StateAssignment')
    def hasContent_(self):
        if (
            self.StateAssignment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OnStart'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StateAssignment=[\n')
        level += 1
        for StateAssignment_ in self.StateAssignment:
            showIndent(outfile, level)
            outfile.write('model_.StateAssignment(\n')
            StateAssignment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateAssignment':
            obj_ = StateAssignment.factory()
            obj_.build(child_)
            self.StateAssignment.append(obj_)
# end class OnStart


class OnEntry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StateAssignment=None):
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
    def factory(*args_, **kwargs_):
        if OnEntry.subclass:
            return OnEntry.subclass(*args_, **kwargs_)
        else:
            return OnEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStateAssignment(self): return self.StateAssignment
    def setStateAssignment(self, StateAssignment): self.StateAssignment = StateAssignment
    def addStateAssignment(self, value): self.StateAssignment.append(value)
    def insertStateAssignment(self, index, value): self.StateAssignment[index] = value
    def export(self, outfile, level, namespace_='', name_='OnEntry', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnEntry')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OnEntry', fromsubclass_=False):
        for StateAssignment_ in self.StateAssignment:
            StateAssignment_.export(outfile, level, namespace_, name_='StateAssignment')
    def hasContent_(self):
        if (
            self.StateAssignment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OnEntry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StateAssignment=[\n')
        level += 1
        for StateAssignment_ in self.StateAssignment:
            showIndent(outfile, level)
            outfile.write('model_.StateAssignment(\n')
            StateAssignment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateAssignment':
            obj_ = StateAssignment.factory()
            obj_.build(child_)
            self.StateAssignment.append(obj_)
# end class OnEntry


class OnEvent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, port=None, StateAssignment=None, EventOut=None):
        self.port = _cast(None, port)
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
        if EventOut is None:
            self.EventOut = []
        else:
            self.EventOut = EventOut
    def factory(*args_, **kwargs_):
        if OnEvent.subclass:
            return OnEvent.subclass(*args_, **kwargs_)
        else:
            return OnEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStateAssignment(self): return self.StateAssignment
    def setStateAssignment(self, StateAssignment): self.StateAssignment = StateAssignment
    def addStateAssignment(self, value): self.StateAssignment.append(value)
    def insertStateAssignment(self, index, value): self.StateAssignment[index] = value
    def getEventOut(self): return self.EventOut
    def setEventOut(self, EventOut): self.EventOut = EventOut
    def addEventOut(self, value): self.EventOut.append(value)
    def insertEventOut(self, index, value): self.EventOut[index] = value
    def getPort(self): return self.port
    def setPort(self, port): self.port = port
    def export(self, outfile, level, namespace_='', name_='OnEvent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnEvent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnEvent'):
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            outfile.write(' port=%s' % (self.gds_format_string(quote_attrib(self.port).encode(ExternalEncoding), input_name='port'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OnEvent', fromsubclass_=False):
        for StateAssignment_ in self.StateAssignment:
            StateAssignment_.export(outfile, level, namespace_, name_='StateAssignment')
        for EventOut_ in self.EventOut:
            EventOut_.export(outfile, level, namespace_, name_='EventOut')
    def hasContent_(self):
        if (
            self.StateAssignment or
            self.EventOut
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OnEvent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            showIndent(outfile, level)
            outfile.write('port = "%s",\n' % (self.port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StateAssignment=[\n')
        level += 1
        for StateAssignment_ in self.StateAssignment:
            showIndent(outfile, level)
            outfile.write('model_.StateAssignment(\n')
            StateAssignment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EventOut=[\n')
        level += 1
        for EventOut_ in self.EventOut:
            showIndent(outfile, level)
            outfile.write('model_.EventOut(\n')
            EventOut_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.append('port')
            self.port = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateAssignment':
            obj_ = StateAssignment.factory()
            obj_.build(child_)
            self.StateAssignment.append(obj_)
        elif nodeName_ == 'EventOut':
            obj_ = EventOut.factory()
            obj_.build(child_)
            self.EventOut.append(obj_)
# end class OnEvent


class OnCondition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, test=None, StateAssignment=None, EventOut=None, Transition=None):
        self.test = _cast(None, test)
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
        if EventOut is None:
            self.EventOut = []
        else:
            self.EventOut = EventOut
        self.Transition = Transition
    def factory(*args_, **kwargs_):
        if OnCondition.subclass:
            return OnCondition.subclass(*args_, **kwargs_)
        else:
            return OnCondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStateAssignment(self): return self.StateAssignment
    def setStateAssignment(self, StateAssignment): self.StateAssignment = StateAssignment
    def addStateAssignment(self, value): self.StateAssignment.append(value)
    def insertStateAssignment(self, index, value): self.StateAssignment[index] = value
    def getEventOut(self): return self.EventOut
    def setEventOut(self, EventOut): self.EventOut = EventOut
    def addEventOut(self, value): self.EventOut.append(value)
    def insertEventOut(self, index, value): self.EventOut[index] = value
    def getTransition(self): return self.Transition
    def setTransition(self, Transition): self.Transition = Transition
    def getTest(self): return self.test
    def setTest(self, test): self.test = test
    def export(self, outfile, level, namespace_='', name_='OnCondition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnCondition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnCondition'):
        if self.test is not None and 'test' not in already_processed:
            already_processed.append('test')
            outfile.write(' test=%s' % (self.gds_format_string(quote_attrib(self.test).encode(ExternalEncoding), input_name='test'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OnCondition', fromsubclass_=False):
        for StateAssignment_ in self.StateAssignment:
            StateAssignment_.export(outfile, level, namespace_, name_='StateAssignment')
        for EventOut_ in self.EventOut:
            EventOut_.export(outfile, level, namespace_, name_='EventOut')
        if self.Transition is not None:
            self.Transition.export(outfile, level, namespace_, name_='Transition')
    def hasContent_(self):
        if (
            self.StateAssignment or
            self.EventOut or
            self.Transition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OnCondition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.test is not None and 'test' not in already_processed:
            already_processed.append('test')
            showIndent(outfile, level)
            outfile.write('test = "%s",\n' % (self.test,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StateAssignment=[\n')
        level += 1
        for StateAssignment_ in self.StateAssignment:
            showIndent(outfile, level)
            outfile.write('model_.StateAssignment(\n')
            StateAssignment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EventOut=[\n')
        level += 1
        for EventOut_ in self.EventOut:
            showIndent(outfile, level)
            outfile.write('model_.EventOut(\n')
            EventOut_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Transition is not None:
            showIndent(outfile, level)
            outfile.write('Transition=model_.Transition(\n')
            self.Transition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('test', node)
        if value is not None and 'test' not in already_processed:
            already_processed.append('test')
            self.test = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateAssignment':
            obj_ = StateAssignment.factory()
            obj_.build(child_)
            self.StateAssignment.append(obj_)
        elif nodeName_ == 'EventOut':
            obj_ = EventOut.factory()
            obj_.build(child_)
            self.EventOut.append(obj_)
        elif nodeName_ == 'Transition':
            obj_ = Transition.factory()
            obj_.build(child_)
            self.setTransition(obj_)
# end class OnCondition


class EventOut(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, port=None):
        self.port = _cast(None, port)
        pass
    def factory(*args_, **kwargs_):
        if EventOut.subclass:
            return EventOut.subclass(*args_, **kwargs_)
        else:
            return EventOut(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPort(self): return self.port
    def setPort(self, port): self.port = port
    def export(self, outfile, level, namespace_='', name_='EventOut', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventOut')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventOut'):
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            outfile.write(' port=%s' % (self.gds_format_string(quote_attrib(self.port).encode(ExternalEncoding), input_name='port'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventOut', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EventOut'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            showIndent(outfile, level)
            outfile.write('port = "%s",\n' % (self.port,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.append('port')
            self.port = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventOut


class StateAssignment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, value=None):
        self.variable = _cast(None, variable)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if StateAssignment.subclass:
            return StateAssignment.subclass(*args_, **kwargs_)
        else:
            return StateAssignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='StateAssignment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateAssignment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateAssignment'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StateAssignment', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateAssignment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StateAssignment


class Regime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, initial=None, name=None, TimeDerivative=None, OnEntry=None, OnCondition=None):
        self.initial = _cast(None, initial)
        self.name = _cast(None, name)
        if TimeDerivative is None:
            self.TimeDerivative = []
        else:
            self.TimeDerivative = TimeDerivative
        self.OnEntry = OnEntry
        if OnCondition is None:
            self.OnCondition = []
        else:
            self.OnCondition = OnCondition
    def factory(*args_, **kwargs_):
        if Regime.subclass:
            return Regime.subclass(*args_, **kwargs_)
        else:
            return Regime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTimeDerivative(self): return self.TimeDerivative
    def setTimeDerivative(self, TimeDerivative): self.TimeDerivative = TimeDerivative
    def addTimeDerivative(self, value): self.TimeDerivative.append(value)
    def insertTimeDerivative(self, index, value): self.TimeDerivative[index] = value
    def getOnEntry(self): return self.OnEntry
    def setOnEntry(self, OnEntry): self.OnEntry = OnEntry
    def getOnCondition(self): return self.OnCondition
    def setOnCondition(self, OnCondition): self.OnCondition = OnCondition
    def addOnCondition(self, value): self.OnCondition.append(value)
    def insertOnCondition(self, index, value): self.OnCondition[index] = value
    def getInitial(self): return self.initial
    def setInitial(self, initial): self.initial = initial
    def validate_TrueOrFalse(self, value):
        # Validate type TrueOrFalse, a restriction on xs:string.
        pass
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Regime', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Regime')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Regime'):
        if self.initial is not None and 'initial' not in already_processed:
            already_processed.append('initial')
            outfile.write(' initial=%s' % (quote_attrib(self.initial), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Regime', fromsubclass_=False):
        for TimeDerivative_ in self.TimeDerivative:
            TimeDerivative_.export(outfile, level, namespace_, name_='TimeDerivative')
        if self.OnEntry is not None:
            self.OnEntry.export(outfile, level, namespace_, name_='OnEntry')
        for OnCondition_ in self.OnCondition:
            OnCondition_.export(outfile, level, namespace_, name_='OnCondition')
    def hasContent_(self):
        if (
            self.TimeDerivative or
            self.OnEntry is not None or
            self.OnCondition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Regime'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.initial is not None and 'initial' not in already_processed:
            already_processed.append('initial')
            showIndent(outfile, level)
            outfile.write('initial = "%s",\n' % (self.initial,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TimeDerivative=[\n')
        level += 1
        for TimeDerivative_ in self.TimeDerivative:
            showIndent(outfile, level)
            outfile.write('model_.TimeDerivative(\n')
            TimeDerivative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.OnEntry is not None:
            showIndent(outfile, level)
            outfile.write('OnEntry=model_.OnStart(\n')
            self.OnEntry.exportLiteral(outfile, level, name_='OnEntry')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OnCondition=[\n')
        level += 1
        for OnCondition_ in self.OnCondition:
            showIndent(outfile, level)
            outfile.write('model_.OnCondition(\n')
            OnCondition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initial', node)
        if value is not None and 'initial' not in already_processed:
            already_processed.append('initial')
            self.initial = value
            self.validate_TrueOrFalse(self.initial)    # validate type TrueOrFalse
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeDerivative':
            obj_ = TimeDerivative.factory()
            obj_.build(child_)
            self.TimeDerivative.append(obj_)
        elif nodeName_ == 'OnEntry':
            obj_ = OnStart.factory()
            obj_.build(child_)
            self.setOnEntry(obj_)
        elif nodeName_ == 'OnCondition':
            obj_ = OnCondition.factory()
            obj_.build(child_)
            self.OnCondition.append(obj_)
# end class Regime


class Transition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, regime=None):
        self.regime = _cast(None, regime)
        pass
    def factory(*args_, **kwargs_):
        if Transition.subclass:
            return Transition.subclass(*args_, **kwargs_)
        else:
            return Transition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getRegime(self): return self.regime
    def setRegime(self, regime): self.regime = regime
    def export(self, outfile, level, namespace_='', name_='Transition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Transition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Transition'):
        if self.regime is not None and 'regime' not in already_processed:
            already_processed.append('regime')
            outfile.write(' regime=%s' % (self.gds_format_string(quote_attrib(self.regime).encode(ExternalEncoding), input_name='regime'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Transition', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Transition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.regime is not None and 'regime' not in already_processed:
            already_processed.append('regime')
            showIndent(outfile, level)
            outfile.write('regime = "%s",\n' % (self.regime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regime', node)
        if value is not None and 'regime' not in already_processed:
            already_processed.append('regime')
            self.regime = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Transition


class Component(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, Component=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        if Component is None:
            self.Component = []
        else:
            self.Component = Component
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Component.subclass:
            return Component.subclass(*args_, **kwargs_)
        else:
            return Component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComponent(self): return self.Component
    def setComponent(self, Component): self.Component = Component
    def addComponent(self, value): self.Component.append(value)
    def insertComponent(self, index, value): self.Component[index] = value
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def getAnyAttributes_(self): return self.anyAttributes_
    def setAnyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Component', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Component')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Component'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Component', fromsubclass_=False):
        for Component_ in self.Component:
            Component_.export(outfile, level, namespace_, name_='Component')
    def hasContent_(self):
        if (
            self.Component
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Component'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Component=[\n')
        level += 1
        for Component_ in self.Component:
            showIndent(outfile, level)
            outfile.write('model_.Component(\n')
            Component_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Component':
            obj_ = Component.factory()
            obj_.build(child_)
            self.Component.append(obj_)
# end class Component


class ComponentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extends=None, name=None, description=None, Property=None, Parameter=None, DerivedParameter=None, Constant=None, Child=None, Children=None, Fixed=None, Link=None, ComponentRef=None, Attachments=None, EventPort=None, Exposure=None, Requirement=None, Path=None, Text=None, Behavior=None):
        self.extends = _cast(None, extends)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        if DerivedParameter is None:
            self.DerivedParameter = []
        else:
            self.DerivedParameter = DerivedParameter
        if Constant is None:
            self.Constant = []
        else:
            self.Constant = Constant
        if Child is None:
            self.Child = []
        else:
            self.Child = Child
        if Children is None:
            self.Children = []
        else:
            self.Children = Children
        if Fixed is None:
            self.Fixed = []
        else:
            self.Fixed = Fixed
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if ComponentRef is None:
            self.ComponentRef = []
        else:
            self.ComponentRef = ComponentRef
        if Attachments is None:
            self.Attachments = []
        else:
            self.Attachments = Attachments
        if EventPort is None:
            self.EventPort = []
        else:
            self.EventPort = EventPort
        if Exposure is None:
            self.Exposure = []
        else:
            self.Exposure = Exposure
        if Requirement is None:
            self.Requirement = []
        else:
            self.Requirement = Requirement
        if Path is None:
            self.Path = []
        else:
            self.Path = Path
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if Behavior is None:
            self.Behavior = []
        else:
            self.Behavior = Behavior
    def factory(*args_, **kwargs_):
        if ComponentType.subclass:
            return ComponentType.subclass(*args_, **kwargs_)
        else:
            return ComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProperty(self): return self.Property
    def setProperty(self, Property): self.Property = Property
    def addProperty(self, value): self.Property.append(value)
    def insertProperty(self, index, value): self.Property[index] = value
    def getParameter(self): return self.Parameter
    def setParameter(self, Parameter): self.Parameter = Parameter
    def addParameter(self, value): self.Parameter.append(value)
    def insertParameter(self, index, value): self.Parameter[index] = value
    def getDerivedParameter(self): return self.DerivedParameter
    def setDerivedParameter(self, DerivedParameter): self.DerivedParameter = DerivedParameter
    def addDerivedParameter(self, value): self.DerivedParameter.append(value)
    def insertDerivedParameter(self, index, value): self.DerivedParameter[index] = value
    def getConstant(self): return self.Constant
    def setConstant(self, Constant): self.Constant = Constant
    def addConstant(self, value): self.Constant.append(value)
    def insertConstant(self, index, value): self.Constant[index] = value
    def getChild(self): return self.Child
    def setChild(self, Child): self.Child = Child
    def addChild(self, value): self.Child.append(value)
    def insertChild(self, index, value): self.Child[index] = value
    def getChildren(self): return self.Children
    def setChildren(self, Children): self.Children = Children
    def addChildren(self, value): self.Children.append(value)
    def insertChildren(self, index, value): self.Children[index] = value
    def getFixed(self): return self.Fixed
    def setFixed(self, Fixed): self.Fixed = Fixed
    def addFixed(self, value): self.Fixed.append(value)
    def insertFixed(self, index, value): self.Fixed[index] = value
    def getLink(self): return self.Link
    def setLink(self, Link): self.Link = Link
    def addLink(self, value): self.Link.append(value)
    def insertLink(self, index, value): self.Link[index] = value
    def getComponentRef(self): return self.ComponentRef
    def setComponentRef(self, ComponentRef): self.ComponentRef = ComponentRef
    def addComponentRef(self, value): self.ComponentRef.append(value)
    def insertComponentRef(self, index, value): self.ComponentRef[index] = value
    def getAttachments(self): return self.Attachments
    def setAttachments(self, Attachments): self.Attachments = Attachments
    def addAttachments(self, value): self.Attachments.append(value)
    def insertAttachments(self, index, value): self.Attachments[index] = value
    def getEventPort(self): return self.EventPort
    def setEventPort(self, EventPort): self.EventPort = EventPort
    def addEventPort(self, value): self.EventPort.append(value)
    def insertEventPort(self, index, value): self.EventPort[index] = value
    def getExposure(self): return self.Exposure
    def setExposure(self, Exposure): self.Exposure = Exposure
    def addExposure(self, value): self.Exposure.append(value)
    def insertExposure(self, index, value): self.Exposure[index] = value
    def getRequirement(self): return self.Requirement
    def setRequirement(self, Requirement): self.Requirement = Requirement
    def addRequirement(self, value): self.Requirement.append(value)
    def insertRequirement(self, index, value): self.Requirement[index] = value
    def getPath(self): return self.Path
    def setPath(self, Path): self.Path = Path
    def addPath(self, value): self.Path.append(value)
    def insertPath(self, index, value): self.Path[index] = value
    def getText(self): return self.Text
    def setText(self, Text): self.Text = Text
    def addText(self, value): self.Text.append(value)
    def insertText(self, index, value): self.Text[index] = value
    def getBehavior(self): return self.Behavior
    def setBehavior(self, Behavior): self.Behavior = Behavior
    def addBehavior(self, value): self.Behavior.append(value)
    def insertBehavior(self, index, value): self.Behavior[index] = value
    def getExtends(self): return self.extends
    def setExtends(self, extends): self.extends = extends
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='ComponentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComponentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComponentType'):
        if self.extends is not None and 'extends' not in already_processed:
            already_processed.append('extends')
            outfile.write(' extends=%s' % (self.gds_format_string(quote_attrib(self.extends).encode(ExternalEncoding), input_name='extends'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ComponentType', fromsubclass_=False):
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property')
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter')
        for DerivedParameter_ in self.DerivedParameter:
            DerivedParameter_.export(outfile, level, namespace_, name_='DerivedParameter')
        for Constant_ in self.Constant:
            Constant_.export(outfile, level, namespace_, name_='Constant')
        for Child_ in self.Child:
            Child_.export(outfile, level, namespace_, name_='Child')
        for Children_ in self.Children:
            Children_.export(outfile, level, namespace_, name_='Children')
        for Fixed_ in self.Fixed:
            Fixed_.export(outfile, level, namespace_, name_='Fixed')
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link')
        for ComponentRef_ in self.ComponentRef:
            ComponentRef_.export(outfile, level, namespace_, name_='ComponentRef')
        for Attachments_ in self.Attachments:
            Attachments_.export(outfile, level, namespace_, name_='Attachments')
        for EventPort_ in self.EventPort:
            EventPort_.export(outfile, level, namespace_, name_='EventPort')
        for Exposure_ in self.Exposure:
            Exposure_.export(outfile, level, namespace_, name_='Exposure')
        for Requirement_ in self.Requirement:
            Requirement_.export(outfile, level, namespace_, name_='Requirement')
        for Path_ in self.Path:
            Path_.export(outfile, level, namespace_, name_='Path')
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text')
        for Behavior_ in self.Behavior:
            Behavior_.export(outfile, level, namespace_, name_='Behavior')
    def hasContent_(self):
        if (
            self.Property or
            self.Parameter or
            self.DerivedParameter or
            self.Constant or
            self.Child or
            self.Children or
            self.Fixed or
            self.Link or
            self.ComponentRef or
            self.Attachments or
            self.EventPort or
            self.Exposure or
            self.Requirement or
            self.Path or
            self.Text or
            self.Behavior
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ComponentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.extends is not None and 'extends' not in already_processed:
            already_processed.append('extends')
            showIndent(outfile, level)
            outfile.write('extends = "%s",\n' % (self.extends,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.Property(\n')
            Property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.Parameter(\n')
            Parameter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedParameter=[\n')
        level += 1
        for DerivedParameter_ in self.DerivedParameter:
            showIndent(outfile, level)
            outfile.write('model_.DerivedParameter(\n')
            DerivedParameter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Constant=[\n')
        level += 1
        for Constant_ in self.Constant:
            showIndent(outfile, level)
            outfile.write('model_.Constant(\n')
            Constant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Child=[\n')
        level += 1
        for Child_ in self.Child:
            showIndent(outfile, level)
            outfile.write('model_.Child(\n')
            Child_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Children=[\n')
        level += 1
        for Children_ in self.Children:
            showIndent(outfile, level)
            outfile.write('model_.Children(\n')
            Children_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Fixed=[\n')
        level += 1
        for Fixed_ in self.Fixed:
            showIndent(outfile, level)
            outfile.write('model_.Fixed(\n')
            Fixed_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.Link(\n')
            Link_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ComponentRef=[\n')
        level += 1
        for ComponentRef_ in self.ComponentRef:
            showIndent(outfile, level)
            outfile.write('model_.ComponentRef(\n')
            ComponentRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Attachments=[\n')
        level += 1
        for Attachments_ in self.Attachments:
            showIndent(outfile, level)
            outfile.write('model_.Attachments(\n')
            Attachments_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EventPort=[\n')
        level += 1
        for EventPort_ in self.EventPort:
            showIndent(outfile, level)
            outfile.write('model_.EventPort(\n')
            EventPort_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Exposure=[\n')
        level += 1
        for Exposure_ in self.Exposure:
            showIndent(outfile, level)
            outfile.write('model_.Exposure(\n')
            Exposure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Requirement=[\n')
        level += 1
        for Requirement_ in self.Requirement:
            showIndent(outfile, level)
            outfile.write('model_.Requirement(\n')
            Requirement_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Path=[\n')
        level += 1
        for Path_ in self.Path:
            showIndent(outfile, level)
            outfile.write('model_.Path(\n')
            Path_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Behavior=[\n')
        level += 1
        for Behavior_ in self.Behavior:
            showIndent(outfile, level)
            outfile.write('model_.Behavior(\n')
            Behavior_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extends', node)
        if value is not None and 'extends' not in already_processed:
            already_processed.append('extends')
            self.extends = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = Property.factory()
            obj_.build(child_)
            self.Property.append(obj_)
        elif nodeName_ == 'Parameter':
            obj_ = Parameter.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
        elif nodeName_ == 'DerivedParameter':
            obj_ = DerivedParameter.factory()
            obj_.build(child_)
            self.DerivedParameter.append(obj_)
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant.append(obj_)
        elif nodeName_ == 'Child':
            obj_ = Child.factory()
            obj_.build(child_)
            self.Child.append(obj_)
        elif nodeName_ == 'Children':
            obj_ = Children.factory()
            obj_.build(child_)
            self.Children.append(obj_)
        elif nodeName_ == 'Fixed':
            obj_ = Fixed.factory()
            obj_.build(child_)
            self.Fixed.append(obj_)
        elif nodeName_ == 'Link':
            obj_ = Link.factory()
            obj_.build(child_)
            self.Link.append(obj_)
        elif nodeName_ == 'ComponentRef':
            obj_ = ComponentRef.factory()
            obj_.build(child_)
            self.ComponentRef.append(obj_)
        elif nodeName_ == 'Attachments':
            obj_ = Attachments.factory()
            obj_.build(child_)
            self.Attachments.append(obj_)
        elif nodeName_ == 'EventPort':
            obj_ = EventPort.factory()
            obj_.build(child_)
            self.EventPort.append(obj_)
        elif nodeName_ == 'Exposure':
            obj_ = Exposure.factory()
            obj_.build(child_)
            self.Exposure.append(obj_)
        elif nodeName_ == 'Requirement':
            obj_ = Requirement.factory()
            obj_.build(child_)
            self.Requirement.append(obj_)
        elif nodeName_ == 'Path':
            obj_ = Path.factory()
            obj_.build(child_)
            self.Path.append(obj_)
        elif nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
        elif nodeName_ == 'Behavior':
            obj_ = Behavior.factory()
            obj_.build(child_)
            self.Behavior.append(obj_)
# end class ComponentType


class NamedDimensionalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, dimension='none', extensiontype_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.dimension = _cast(None, dimension)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NamedDimensionalType.subclass:
            return NamedDimensionalType.subclass(*args_, **kwargs_)
        else:
            return NamedDimensionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDimension(self): return self.dimension
    def setDimension(self, dimension): self.dimension = dimension
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='NamedDimensionalType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamedDimensionalType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NamedDimensionalType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (self.gds_format_string(quote_attrib(self.dimension).encode(ExternalEncoding), input_name='dimension'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NamedDimensionalType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NamedDimensionalType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = "%s",\n' % (self.dimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NamedDimensionalType


class Property(NamedDimensionalType):
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, description=None, name=None, dimension='none'):
        super(Property, self).__init__(description, name, dimension, )
        pass
    def factory(*args_, **kwargs_):
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Property'):
        super(Property, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
    def exportChildren(self, outfile, level, namespace_='', name_='Property', fromsubclass_=False):
        super(Property, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(Property, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Property, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Property, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Property, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Property, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Property


class Parameter(NamedDimensionalType):
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, description=None, name=None, dimension='none'):
        super(Parameter, self).__init__(description, name, dimension, )
        pass
    def factory(*args_, **kwargs_):
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Parameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parameter'):
        super(Parameter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Parameter')
    def exportChildren(self, outfile, level, namespace_='', name_='Parameter', fromsubclass_=False):
        super(Parameter, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(Parameter, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Parameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Parameter, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Parameter, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Parameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Parameter, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Parameter


class Requirement(NamedDimensionalType):
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, description=None, name=None, dimension='none'):
        super(Requirement, self).__init__(description, name, dimension, )
        pass
    def factory(*args_, **kwargs_):
        if Requirement.subclass:
            return Requirement.subclass(*args_, **kwargs_)
        else:
            return Requirement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Requirement', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Requirement')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Requirement'):
        super(Requirement, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Requirement')
    def exportChildren(self, outfile, level, namespace_='', name_='Requirement', fromsubclass_=False):
        super(Requirement, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(Requirement, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Requirement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Requirement, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Requirement, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Requirement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Requirement, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Requirement


class Exposure(NamedDimensionalType):
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, description=None, name=None, dimension='none'):
        super(Exposure, self).__init__(description, name, dimension, )
        pass
    def factory(*args_, **kwargs_):
        if Exposure.subclass:
            return Exposure.subclass(*args_, **kwargs_)
        else:
            return Exposure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Exposure', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Exposure')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exposure'):
        super(Exposure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Exposure')
    def exportChildren(self, outfile, level, namespace_='', name_='Exposure', fromsubclass_=False):
        super(Exposure, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(Exposure, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Exposure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Exposure, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Exposure, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Exposure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Exposure, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Exposure


class Behavior(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Build=None, StateVariable=None, DerivedVariable=None, TimeDerivative=None, OnStart=None, OnEvent=None, OnCondition=None, Regime=None, KineticScheme=None, Show=None, Record=None, Run=None):
        self.Build = Build
        if StateVariable is None:
            self.StateVariable = []
        else:
            self.StateVariable = StateVariable
        if DerivedVariable is None:
            self.DerivedVariable = []
        else:
            self.DerivedVariable = DerivedVariable
        if TimeDerivative is None:
            self.TimeDerivative = []
        else:
            self.TimeDerivative = TimeDerivative
        self.OnStart = OnStart
        if OnEvent is None:
            self.OnEvent = []
        else:
            self.OnEvent = OnEvent
        if OnCondition is None:
            self.OnCondition = []
        else:
            self.OnCondition = OnCondition
        if Regime is None:
            self.Regime = []
        else:
            self.Regime = Regime
        self.KineticScheme = KineticScheme
        if Show is None:
            self.Show = []
        else:
            self.Show = Show
        if Record is None:
            self.Record = []
        else:
            self.Record = Record
        if Run is None:
            self.Run = []
        else:
            self.Run = Run
    def factory(*args_, **kwargs_):
        if Behavior.subclass:
            return Behavior.subclass(*args_, **kwargs_)
        else:
            return Behavior(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBuild(self): return self.Build
    def setBuild(self, Build): self.Build = Build
    def getStateVariable(self): return self.StateVariable
    def setStateVariable(self, StateVariable): self.StateVariable = StateVariable
    def addStateVariable(self, value): self.StateVariable.append(value)
    def insertStateVariable(self, index, value): self.StateVariable[index] = value
    def getDerivedVariable(self): return self.DerivedVariable
    def setDerivedVariable(self, DerivedVariable): self.DerivedVariable = DerivedVariable
    def addDerivedVariable(self, value): self.DerivedVariable.append(value)
    def insertDerivedVariable(self, index, value): self.DerivedVariable[index] = value
    def getTimeDerivative(self): return self.TimeDerivative
    def setTimeDerivative(self, TimeDerivative): self.TimeDerivative = TimeDerivative
    def addTimeDerivative(self, value): self.TimeDerivative.append(value)
    def insertTimeDerivative(self, index, value): self.TimeDerivative[index] = value
    def getOnStart(self): return self.OnStart
    def setOnStart(self, OnStart): self.OnStart = OnStart
    def getOnEvent(self): return self.OnEvent
    def setOnEvent(self, OnEvent): self.OnEvent = OnEvent
    def addOnEvent(self, value): self.OnEvent.append(value)
    def insertOnEvent(self, index, value): self.OnEvent[index] = value
    def getOnCondition(self): return self.OnCondition
    def setOnCondition(self, OnCondition): self.OnCondition = OnCondition
    def addOnCondition(self, value): self.OnCondition.append(value)
    def insertOnCondition(self, index, value): self.OnCondition[index] = value
    def getRegime(self): return self.Regime
    def setRegime(self, Regime): self.Regime = Regime
    def addRegime(self, value): self.Regime.append(value)
    def insertRegime(self, index, value): self.Regime[index] = value
    def getKineticScheme(self): return self.KineticScheme
    def setKineticScheme(self, KineticScheme): self.KineticScheme = KineticScheme
    def getShow(self): return self.Show
    def setShow(self, Show): self.Show = Show
    def addShow(self, value): self.Show.append(value)
    def insertShow(self, index, value): self.Show[index] = value
    def getRecord(self): return self.Record
    def setRecord(self, Record): self.Record = Record
    def addRecord(self, value): self.Record.append(value)
    def insertRecord(self, index, value): self.Record[index] = value
    def getRun(self): return self.Run
    def setRun(self, Run): self.Run = Run
    def addRun(self, value): self.Run.append(value)
    def insertRun(self, index, value): self.Run[index] = value
    def export(self, outfile, level, namespace_='', name_='Behavior', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Behavior')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Behavior'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Behavior', fromsubclass_=False):
        if self.Build is not None:
            self.Build.export(outfile, level, namespace_, name_='Build')
        for StateVariable_ in self.StateVariable:
            StateVariable_.export(outfile, level, namespace_, name_='StateVariable')
        for DerivedVariable_ in self.DerivedVariable:
            DerivedVariable_.export(outfile, level, namespace_, name_='DerivedVariable')
        for TimeDerivative_ in self.TimeDerivative:
            TimeDerivative_.export(outfile, level, namespace_, name_='TimeDerivative')
        if self.OnStart is not None:
            self.OnStart.export(outfile, level, namespace_, name_='OnStart')
        for OnEvent_ in self.OnEvent:
            OnEvent_.export(outfile, level, namespace_, name_='OnEvent')
        for OnCondition_ in self.OnCondition:
            OnCondition_.export(outfile, level, namespace_, name_='OnCondition')
        for Regime_ in self.Regime:
            Regime_.export(outfile, level, namespace_, name_='Regime')
        if self.KineticScheme is not None:
            self.KineticScheme.export(outfile, level, namespace_, name_='KineticScheme')
        for Show_ in self.Show:
            Show_.export(outfile, level, namespace_, name_='Show')
        for Record_ in self.Record:
            Record_.export(outfile, level, namespace_, name_='Record')
        for Run_ in self.Run:
            Run_.export(outfile, level, namespace_, name_='Run')
    def hasContent_(self):
        if (
            self.Build is not None or
            self.StateVariable or
            self.DerivedVariable or
            self.TimeDerivative or
            self.OnStart is not None or
            self.OnEvent or
            self.OnCondition or
            self.Regime or
            self.KineticScheme is not None or
            self.Show or
            self.Record or
            self.Run
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Behavior'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Build is not None:
            showIndent(outfile, level)
            outfile.write('Build=model_.Build(\n')
            self.Build.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('StateVariable=[\n')
        level += 1
        for StateVariable_ in self.StateVariable:
            showIndent(outfile, level)
            outfile.write('model_.StateVariable(\n')
            StateVariable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedVariable=[\n')
        level += 1
        for DerivedVariable_ in self.DerivedVariable:
            showIndent(outfile, level)
            outfile.write('model_.DerivedVariable(\n')
            DerivedVariable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TimeDerivative=[\n')
        level += 1
        for TimeDerivative_ in self.TimeDerivative:
            showIndent(outfile, level)
            outfile.write('model_.TimeDerivative(\n')
            TimeDerivative_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.OnStart is not None:
            showIndent(outfile, level)
            outfile.write('OnStart=model_.OnStart(\n')
            self.OnStart.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OnEvent=[\n')
        level += 1
        for OnEvent_ in self.OnEvent:
            showIndent(outfile, level)
            outfile.write('model_.OnEvent(\n')
            OnEvent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OnCondition=[\n')
        level += 1
        for OnCondition_ in self.OnCondition:
            showIndent(outfile, level)
            outfile.write('model_.OnCondition(\n')
            OnCondition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Regime=[\n')
        level += 1
        for Regime_ in self.Regime:
            showIndent(outfile, level)
            outfile.write('model_.Regime(\n')
            Regime_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.KineticScheme is not None:
            showIndent(outfile, level)
            outfile.write('KineticScheme=model_.KineticScheme(\n')
            self.KineticScheme.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Show=[\n')
        level += 1
        for Show_ in self.Show:
            showIndent(outfile, level)
            outfile.write('model_.Show(\n')
            Show_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Record=[\n')
        level += 1
        for Record_ in self.Record:
            showIndent(outfile, level)
            outfile.write('model_.Record(\n')
            Record_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Run=[\n')
        level += 1
        for Run_ in self.Run:
            showIndent(outfile, level)
            outfile.write('model_.Run(\n')
            Run_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Build':
            obj_ = Build.factory()
            obj_.build(child_)
            self.setBuild(obj_)
        elif nodeName_ == 'StateVariable':
            obj_ = StateVariable.factory()
            obj_.build(child_)
            self.StateVariable.append(obj_)
        elif nodeName_ == 'DerivedVariable':
            obj_ = DerivedVariable.factory()
            obj_.build(child_)
            self.DerivedVariable.append(obj_)
        elif nodeName_ == 'TimeDerivative':
            obj_ = TimeDerivative.factory()
            obj_.build(child_)
            self.TimeDerivative.append(obj_)
        elif nodeName_ == 'OnStart':
            obj_ = OnStart.factory()
            obj_.build(child_)
            self.setOnStart(obj_)
        elif nodeName_ == 'OnEvent':
            obj_ = OnEvent.factory()
            obj_.build(child_)
            self.OnEvent.append(obj_)
        elif nodeName_ == 'OnCondition':
            obj_ = OnCondition.factory()
            obj_.build(child_)
            self.OnCondition.append(obj_)
        elif nodeName_ == 'Regime':
            obj_ = Regime.factory()
            obj_.build(child_)
            self.Regime.append(obj_)
        elif nodeName_ == 'KineticScheme':
            obj_ = KineticScheme.factory()
            obj_.build(child_)
            self.setKineticScheme(obj_)
        elif nodeName_ == 'Show':
            obj_ = Show.factory()
            obj_.build(child_)
            self.Show.append(obj_)
        elif nodeName_ == 'Record':
            obj_ = Record.factory()
            obj_.build(child_)
            self.Record.append(obj_)
        elif nodeName_ == 'Run':
            obj_ = Run.factory()
            obj_.build(child_)
            self.Run.append(obj_)
# end class Behavior


class Build(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChildInstance=None, MultiInstantiate=None, ForEach=None, With=None, EventConnection=None):
        self.ChildInstance = ChildInstance
        self.MultiInstantiate = MultiInstantiate
        self.ForEach = ForEach
        if With is None:
            self.With = []
        else:
            self.With = With
        self.EventConnection = EventConnection
    def factory(*args_, **kwargs_):
        if Build.subclass:
            return Build.subclass(*args_, **kwargs_)
        else:
            return Build(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getChildInstance(self): return self.ChildInstance
    def setChildInstance(self, ChildInstance): self.ChildInstance = ChildInstance
    def getMultiInstantiate(self): return self.MultiInstantiate
    def setMultiInstantiate(self, MultiInstantiate): self.MultiInstantiate = MultiInstantiate
    def getForEach(self): return self.ForEach
    def setForEach(self, ForEach): self.ForEach = ForEach
    def getWith(self): return self.With
    def setWith(self, With): self.With = With
    def addWith(self, value): self.With.append(value)
    def insertWith(self, index, value): self.With[index] = value
    def getEventConnection(self): return self.EventConnection
    def setEventConnection(self, EventConnection): self.EventConnection = EventConnection
    def export(self, outfile, level, namespace_='', name_='Build', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Build')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Build'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Build', fromsubclass_=False):
        if self.ChildInstance is not None:
            self.ChildInstance.export(outfile, level, namespace_, name_='ChildInstance')
        if self.MultiInstantiate is not None:
            self.MultiInstantiate.export(outfile, level, namespace_, name_='MultiInstantiate')
        if self.ForEach is not None:
            self.ForEach.export(outfile, level, namespace_, name_='ForEach')
        for With_ in self.With:
            With_.export(outfile, level, namespace_, name_='With')
        if self.EventConnection is not None:
            self.EventConnection.export(outfile, level, namespace_, name_='EventConnection')
    def hasContent_(self):
        if (
            self.ChildInstance is not None or
            self.MultiInstantiate is not None or
            self.ForEach is not None or
            self.With or
            self.EventConnection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Build'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ChildInstance is not None:
            showIndent(outfile, level)
            outfile.write('ChildInstance=model_.ChildInstance(\n')
            self.ChildInstance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MultiInstantiate is not None:
            showIndent(outfile, level)
            outfile.write('MultiInstantiate=model_.MultiInstantiate(\n')
            self.MultiInstantiate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ForEach is not None:
            showIndent(outfile, level)
            outfile.write('ForEach=model_.ForEach(\n')
            self.ForEach.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('With=[\n')
        level += 1
        for With_ in self.With:
            showIndent(outfile, level)
            outfile.write('model_.With(\n')
            With_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EventConnection is not None:
            showIndent(outfile, level)
            outfile.write('EventConnection=model_.EventConnection(\n')
            self.EventConnection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChildInstance':
            obj_ = ChildInstance.factory()
            obj_.build(child_)
            self.setChildInstance(obj_)
        elif nodeName_ == 'MultiInstantiate':
            obj_ = MultiInstantiate.factory()
            obj_.build(child_)
            self.setMultiInstantiate(obj_)
        elif nodeName_ == 'ForEach':
            obj_ = ForEach.factory()
            obj_.build(child_)
            self.setForEach(obj_)
        elif nodeName_ == 'With':
            obj_ = With.factory()
            obj_.build(child_)
            self.With.append(obj_)
        elif nodeName_ == 'EventConnection':
            obj_ = EventConnection.factory()
            obj_.build(child_)
            self.setEventConnection(obj_)
# end class Build


class ChildInstance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, component=None):
        self.component = _cast(None, component)
        pass
    def factory(*args_, **kwargs_):
        if ChildInstance.subclass:
            return ChildInstance.subclass(*args_, **kwargs_)
        else:
            return ChildInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComponent(self): return self.component
    def setComponent(self, component): self.component = component
    def export(self, outfile, level, namespace_='', name_='ChildInstance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChildInstance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChildInstance'):
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            outfile.write(' component=%s' % (self.gds_format_string(quote_attrib(self.component).encode(ExternalEncoding), input_name='component'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChildInstance', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChildInstance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            showIndent(outfile, level)
            outfile.write('component = "%s",\n' % (self.component,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.append('component')
            self.component = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChildInstance


class MultiInstantiate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, component=None, number=None):
        self.component = _cast(None, component)
        self.number = _cast(None, number)
        pass
    def factory(*args_, **kwargs_):
        if MultiInstantiate.subclass:
            return MultiInstantiate.subclass(*args_, **kwargs_)
        else:
            return MultiInstantiate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComponent(self): return self.component
    def setComponent(self, component): self.component = component
    def getNumber(self): return self.number
    def setNumber(self, number): self.number = number
    def export(self, outfile, level, namespace_='', name_='MultiInstantiate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiInstantiate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiInstantiate'):
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            outfile.write(' component=%s' % (self.gds_format_string(quote_attrib(self.component).encode(ExternalEncoding), input_name='component'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding), input_name='number'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiInstantiate', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiInstantiate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            showIndent(outfile, level)
            outfile.write('component = "%s",\n' % (self.component,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = "%s",\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.append('component')
            self.component = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            self.number = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MultiInstantiate


class ForEach(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, instances=None, asxx=None, MultiInstantiate=None):
        self.instances = _cast(None, instances)
        self.asxx = _cast(None, asxx)
        self.MultiInstantiate = MultiInstantiate
    def factory(*args_, **kwargs_):
        if ForEach.subclass:
            return ForEach.subclass(*args_, **kwargs_)
        else:
            return ForEach(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMultiInstantiate(self): return self.MultiInstantiate
    def setMultiInstantiate(self, MultiInstantiate): self.MultiInstantiate = MultiInstantiate
    def getInstances(self): return self.instances
    def setInstances(self, instances): self.instances = instances
    def getAs(self): return self.asxx
    def setAs(self, asxx): self.asxx = asxx
    def export(self, outfile, level, namespace_='', name_='ForEach', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForEach')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ForEach'):
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            outfile.write(' instances=%s' % (self.gds_format_string(quote_attrib(self.instances).encode(ExternalEncoding), input_name='instances'), ))
        if self.asxx is not None and 'asxx' not in already_processed:
            already_processed.append('asxx')
            outfile.write(' as=%s' % (self.gds_format_string(quote_attrib(self.asxx).encode(ExternalEncoding), input_name='as'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ForEach', fromsubclass_=False):
        if self.MultiInstantiate is not None:
            self.MultiInstantiate.export(outfile, level, namespace_, name_='MultiInstantiate')
    def hasContent_(self):
        if (
            self.MultiInstantiate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ForEach'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            showIndent(outfile, level)
            outfile.write('instances = "%s",\n' % (self.instances,))
        if self.asxx is not None and 'asxx' not in already_processed:
            already_processed.append('asxx')
            showIndent(outfile, level)
            outfile.write('asxx = "%s",\n' % (self.asxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiInstantiate is not None:
            showIndent(outfile, level)
            outfile.write('MultiInstantiate=model_.MultiInstantiate(\n')
            self.MultiInstantiate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            self.instances = value
        value = find_attr_value_('as', node)
        if value is not None and 'as' not in already_processed:
            already_processed.append('as')
            self.asxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiInstantiate':
            obj_ = MultiInstantiate.factory()
            obj_.build(child_)
            self.setMultiInstantiate(obj_)
# end class ForEach


class With(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, instance=None, asxx=None):
        self.instance = _cast(None, instance)
        self.asxx = _cast(None, asxx)
        pass
    def factory(*args_, **kwargs_):
        if With.subclass:
            return With.subclass(*args_, **kwargs_)
        else:
            return With(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInstance(self): return self.instance
    def setInstance(self, instance): self.instance = instance
    def getAs(self): return self.asxx
    def setAs(self, asxx): self.asxx = asxx
    def export(self, outfile, level, namespace_='', name_='With', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='With')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='With'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.asxx is not None and 'asxx' not in already_processed:
            already_processed.append('asxx')
            outfile.write(' as=%s' % (self.gds_format_string(quote_attrib(self.asxx).encode(ExternalEncoding), input_name='as'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='With', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='With'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.asxx is not None and 'asxx' not in already_processed:
            already_processed.append('asxx')
            showIndent(outfile, level)
            outfile.write('asxx = "%s",\n' % (self.asxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('as', node)
        if value is not None and 'as' not in already_processed:
            already_processed.append('as')
            self.asxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class With


class EventConnection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, delay=None, to=None, targetPort=None, fromxx=None, receiver=None, Assign=None):
        self.delay = _cast(None, delay)
        self.to = _cast(None, to)
        self.targetPort = _cast(None, targetPort)
        self.fromxx = _cast(None, fromxx)
        self.receiver = _cast(None, receiver)
        self.Assign = Assign
    def factory(*args_, **kwargs_):
        if EventConnection.subclass:
            return EventConnection.subclass(*args_, **kwargs_)
        else:
            return EventConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getAssign(self): return self.Assign
    def setAssign(self, Assign): self.Assign = Assign
    def getDelay(self): return self.delay
    def setDelay(self, delay): self.delay = delay
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def getTargetPort(self): return self.targetPort
    def setTargetPort(self, targetPort): self.targetPort = targetPort
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def getReceiver(self): return self.receiver
    def setReceiver(self, receiver): self.receiver = receiver
    def export(self, outfile, level, namespace_='', name_='EventConnection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventConnection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventConnection'):
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            outfile.write(' delay=%s' % (self.gds_format_string(quote_attrib(self.delay).encode(ExternalEncoding), input_name='delay'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.targetPort is not None and 'targetPort' not in already_processed:
            already_processed.append('targetPort')
            outfile.write(' targetPort=%s' % (self.gds_format_string(quote_attrib(self.targetPort).encode(ExternalEncoding), input_name='targetPort'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.receiver is not None and 'receiver' not in already_processed:
            already_processed.append('receiver')
            outfile.write(' receiver=%s' % (self.gds_format_string(quote_attrib(self.receiver).encode(ExternalEncoding), input_name='receiver'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventConnection', fromsubclass_=False):
        if self.Assign is not None:
            self.Assign.export(outfile, level, namespace_, name_='Assign')
    def hasContent_(self):
        if (
            self.Assign is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EventConnection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            showIndent(outfile, level)
            outfile.write('delay = "%s",\n' % (self.delay,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.targetPort is not None and 'targetPort' not in already_processed:
            already_processed.append('targetPort')
            showIndent(outfile, level)
            outfile.write('targetPort = "%s",\n' % (self.targetPort,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.receiver is not None and 'receiver' not in already_processed:
            already_processed.append('receiver')
            showIndent(outfile, level)
            outfile.write('receiver = "%s",\n' % (self.receiver,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Assign is not None:
            showIndent(outfile, level)
            outfile.write('Assign=model_.Assign(\n')
            self.Assign.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            self.delay = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('targetPort', node)
        if value is not None and 'targetPort' not in already_processed:
            already_processed.append('targetPort')
            self.targetPort = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('receiver', node)
        if value is not None and 'receiver' not in already_processed:
            already_processed.append('receiver')
            self.receiver = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Assign':
            obj_ = Assign.factory()
            obj_.build(child_)
            self.setAssign(obj_)
# end class EventConnection


class Assign(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, value=None):
        self.property = _cast(None, property)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if Assign.subclass:
            return Assign.subclass(*args_, **kwargs_)
        else:
            return Assign(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='Assign', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Assign')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Assign'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Assign', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Assign'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            showIndent(outfile, level)
            outfile.write('property = "%s",\n' % (self.property,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.append('property')
            self.property = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Assign


class KineticScheme(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, Nodes=None, Edges=None, Tabulable=None):
        self.name = _cast(None, name)
        if Nodes is None:
            self.Nodes = []
        else:
            self.Nodes = Nodes
        if Edges is None:
            self.Edges = []
        else:
            self.Edges = Edges
        if Tabulable is None:
            self.Tabulable = []
        else:
            self.Tabulable = Tabulable
    def factory(*args_, **kwargs_):
        if KineticScheme.subclass:
            return KineticScheme.subclass(*args_, **kwargs_)
        else:
            return KineticScheme(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNodes(self): return self.Nodes
    def setNodes(self, Nodes): self.Nodes = Nodes
    def addNodes(self, value): self.Nodes.append(value)
    def insertNodes(self, index, value): self.Nodes[index] = value
    def getEdges(self): return self.Edges
    def setEdges(self, Edges): self.Edges = Edges
    def addEdges(self, value): self.Edges.append(value)
    def insertEdges(self, index, value): self.Edges[index] = value
    def getTabulable(self): return self.Tabulable
    def setTabulable(self, Tabulable): self.Tabulable = Tabulable
    def addTabulable(self, value): self.Tabulable.append(value)
    def insertTabulable(self, index, value): self.Tabulable[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='KineticScheme', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KineticScheme')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KineticScheme'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='KineticScheme', fromsubclass_=False):
        for Nodes_ in self.Nodes:
            Nodes_.export(outfile, level, namespace_, name_='Nodes')
        for Edges_ in self.Edges:
            Edges_.export(outfile, level, namespace_, name_='Edges')
        for Tabulable_ in self.Tabulable:
            Tabulable_.export(outfile, level, namespace_, name_='Tabulable')
    def hasContent_(self):
        if (
            self.Nodes or
            self.Edges or
            self.Tabulable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KineticScheme'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Nodes=[\n')
        level += 1
        for Nodes_ in self.Nodes:
            showIndent(outfile, level)
            outfile.write('model_.Nodes(\n')
            Nodes_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Edges=[\n')
        level += 1
        for Edges_ in self.Edges:
            showIndent(outfile, level)
            outfile.write('model_.Edges(\n')
            Edges_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Tabulable=[\n')
        level += 1
        for Tabulable_ in self.Tabulable:
            showIndent(outfile, level)
            outfile.write('model_.Tabulable(\n')
            Tabulable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nodes':
            obj_ = Nodes.factory()
            obj_.build(child_)
            self.Nodes.append(obj_)
        elif nodeName_ == 'Edges':
            obj_ = Edges.factory()
            obj_.build(child_)
            self.Edges.append(obj_)
        elif nodeName_ == 'Tabulable':
            obj_ = Tabulable.factory()
            obj_.build(child_)
            self.Tabulable.append(obj_)
# end class KineticScheme


class Nodes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, children=None):
        self.variable = _cast(None, variable)
        self.children = _cast(None, children)
        pass
    def factory(*args_, **kwargs_):
        if Nodes.subclass:
            return Nodes.subclass(*args_, **kwargs_)
        else:
            return Nodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getChildren(self): return self.children
    def setChildren(self, children): self.children = children
    def export(self, outfile, level, namespace_='', name_='Nodes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Nodes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Nodes'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.children is not None and 'children' not in already_processed:
            already_processed.append('children')
            outfile.write(' children=%s' % (self.gds_format_string(quote_attrib(self.children).encode(ExternalEncoding), input_name='children'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Nodes', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Nodes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.children is not None and 'children' not in already_processed:
            already_processed.append('children')
            showIndent(outfile, level)
            outfile.write('children = "%s",\n' % (self.children,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('children', node)
        if value is not None and 'children' not in already_processed:
            already_processed.append('children')
            self.children = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Nodes


class Edges(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetNodeName=None, sourceNodeName=None, children=None, forwardRate=None, reverseRate=None):
        self.targetNodeName = _cast(None, targetNodeName)
        self.sourceNodeName = _cast(None, sourceNodeName)
        self.children = _cast(None, children)
        self.forwardRate = _cast(None, forwardRate)
        self.reverseRate = _cast(None, reverseRate)
        pass
    def factory(*args_, **kwargs_):
        if Edges.subclass:
            return Edges.subclass(*args_, **kwargs_)
        else:
            return Edges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTargetNodeName(self): return self.targetNodeName
    def setTargetNodeName(self, targetNodeName): self.targetNodeName = targetNodeName
    def getSourceNodeName(self): return self.sourceNodeName
    def setSourceNodeName(self, sourceNodeName): self.sourceNodeName = sourceNodeName
    def getChildren(self): return self.children
    def setChildren(self, children): self.children = children
    def getForwardRate(self): return self.forwardRate
    def setForwardRate(self, forwardRate): self.forwardRate = forwardRate
    def getReverseRate(self): return self.reverseRate
    def setReverseRate(self, reverseRate): self.reverseRate = reverseRate
    def export(self, outfile, level, namespace_='', name_='Edges', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Edges')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Edges'):
        if self.targetNodeName is not None and 'targetNodeName' not in already_processed:
            already_processed.append('targetNodeName')
            outfile.write(' targetNodeName=%s' % (self.gds_format_string(quote_attrib(self.targetNodeName).encode(ExternalEncoding), input_name='targetNodeName'), ))
        if self.sourceNodeName is not None and 'sourceNodeName' not in already_processed:
            already_processed.append('sourceNodeName')
            outfile.write(' sourceNodeName=%s' % (self.gds_format_string(quote_attrib(self.sourceNodeName).encode(ExternalEncoding), input_name='sourceNodeName'), ))
        if self.children is not None and 'children' not in already_processed:
            already_processed.append('children')
            outfile.write(' children=%s' % (self.gds_format_string(quote_attrib(self.children).encode(ExternalEncoding), input_name='children'), ))
        if self.forwardRate is not None and 'forwardRate' not in already_processed:
            already_processed.append('forwardRate')
            outfile.write(' forwardRate=%s' % (self.gds_format_string(quote_attrib(self.forwardRate).encode(ExternalEncoding), input_name='forwardRate'), ))
        if self.reverseRate is not None and 'reverseRate' not in already_processed:
            already_processed.append('reverseRate')
            outfile.write(' reverseRate=%s' % (self.gds_format_string(quote_attrib(self.reverseRate).encode(ExternalEncoding), input_name='reverseRate'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Edges', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Edges'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetNodeName is not None and 'targetNodeName' not in already_processed:
            already_processed.append('targetNodeName')
            showIndent(outfile, level)
            outfile.write('targetNodeName = "%s",\n' % (self.targetNodeName,))
        if self.sourceNodeName is not None and 'sourceNodeName' not in already_processed:
            already_processed.append('sourceNodeName')
            showIndent(outfile, level)
            outfile.write('sourceNodeName = "%s",\n' % (self.sourceNodeName,))
        if self.children is not None and 'children' not in already_processed:
            already_processed.append('children')
            showIndent(outfile, level)
            outfile.write('children = "%s",\n' % (self.children,))
        if self.forwardRate is not None and 'forwardRate' not in already_processed:
            already_processed.append('forwardRate')
            showIndent(outfile, level)
            outfile.write('forwardRate = "%s",\n' % (self.forwardRate,))
        if self.reverseRate is not None and 'reverseRate' not in already_processed:
            already_processed.append('reverseRate')
            showIndent(outfile, level)
            outfile.write('reverseRate = "%s",\n' % (self.reverseRate,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetNodeName', node)
        if value is not None and 'targetNodeName' not in already_processed:
            already_processed.append('targetNodeName')
            self.targetNodeName = value
        value = find_attr_value_('sourceNodeName', node)
        if value is not None and 'sourceNodeName' not in already_processed:
            already_processed.append('sourceNodeName')
            self.sourceNodeName = value
        value = find_attr_value_('children', node)
        if value is not None and 'children' not in already_processed:
            already_processed.append('children')
            self.children = value
        value = find_attr_value_('forwardRate', node)
        if value is not None and 'forwardRate' not in already_processed:
            already_processed.append('forwardRate')
            self.forwardRate = value
        value = find_attr_value_('reverseRate', node)
        if value is not None and 'reverseRate' not in already_processed:
            already_processed.append('reverseRate')
            self.reverseRate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Edges


class Tabulable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, increment=None):
        self.variable = _cast(None, variable)
        self.increment = _cast(None, increment)
        pass
    def factory(*args_, **kwargs_):
        if Tabulable.subclass:
            return Tabulable.subclass(*args_, **kwargs_)
        else:
            return Tabulable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getIncrement(self): return self.increment
    def setIncrement(self, increment): self.increment = increment
    def export(self, outfile, level, namespace_='', name_='Tabulable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Tabulable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Tabulable'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.increment is not None and 'increment' not in already_processed:
            already_processed.append('increment')
            outfile.write(' increment=%s' % (self.gds_format_string(quote_attrib(self.increment).encode(ExternalEncoding), input_name='increment'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Tabulable', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Tabulable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.increment is not None and 'increment' not in already_processed:
            already_processed.append('increment')
            showIndent(outfile, level)
            outfile.write('increment = "%s",\n' % (self.increment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('increment', node)
        if value is not None and 'increment' not in already_processed:
            already_processed.append('increment')
            self.increment = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Tabulable


class Show(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, scale=None):
        self.src = _cast(None, src)
        self.scale = _cast(None, scale)
        pass
    def factory(*args_, **kwargs_):
        if Show.subclass:
            return Show.subclass(*args_, **kwargs_)
        else:
            return Show(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSrc(self): return self.src
    def setSrc(self, src): self.src = src
    def getScale(self): return self.scale
    def setScale(self, scale): self.scale = scale
    def export(self, outfile, level, namespace_='', name_='Show', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Show')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Show'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale).encode(ExternalEncoding), input_name='scale'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Show', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Show'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            showIndent(outfile, level)
            outfile.write('scale = "%s",\n' % (self.scale,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('src', node)
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            self.scale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Show


class Record(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, color=None, scale=None, quantity=None):
        self.color = _cast(None, color)
        self.scale = _cast(None, scale)
        self.quantity = _cast(None, quantity)
        pass
    def factory(*args_, **kwargs_):
        if Record.subclass:
            return Record.subclass(*args_, **kwargs_)
        else:
            return Record(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getColor(self): return self.color
    def setColor(self, color): self.color = color
    def getScale(self): return self.scale
    def setScale(self, scale): self.scale = scale
    def getQuantity(self): return self.quantity
    def setQuantity(self, quantity): self.quantity = quantity
    def export(self, outfile, level, namespace_='', name_='Record', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Record')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Record'):
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            outfile.write(' color=%s' % (self.gds_format_string(quote_attrib(self.color).encode(ExternalEncoding), input_name='color'), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale).encode(ExternalEncoding), input_name='scale'), ))
        if self.quantity is not None and 'quantity' not in already_processed:
            already_processed.append('quantity')
            outfile.write(' quantity=%s' % (self.gds_format_string(quote_attrib(self.quantity).encode(ExternalEncoding), input_name='quantity'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Record', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Record'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            showIndent(outfile, level)
            outfile.write('color = "%s",\n' % (self.color,))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            showIndent(outfile, level)
            outfile.write('scale = "%s",\n' % (self.scale,))
        if self.quantity is not None and 'quantity' not in already_processed:
            already_processed.append('quantity')
            showIndent(outfile, level)
            outfile.write('quantity = "%s",\n' % (self.quantity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.append('color')
            self.color = value
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            self.scale = value
        value = find_attr_value_('quantity', node)
        if value is not None and 'quantity' not in already_processed:
            already_processed.append('quantity')
            self.quantity = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Record


class Run(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, total=None, component=None, increment=None):
        self.variable = _cast(None, variable)
        self.total = _cast(None, total)
        self.component = _cast(None, component)
        self.increment = _cast(None, increment)
        pass
    def factory(*args_, **kwargs_):
        if Run.subclass:
            return Run.subclass(*args_, **kwargs_)
        else:
            return Run(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getTotal(self): return self.total
    def setTotal(self, total): self.total = total
    def getComponent(self): return self.component
    def setComponent(self, component): self.component = component
    def getIncrement(self): return self.increment
    def setIncrement(self, increment): self.increment = increment
    def export(self, outfile, level, namespace_='', name_='Run', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Run')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Run'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            outfile.write(' total=%s' % (self.gds_format_string(quote_attrib(self.total).encode(ExternalEncoding), input_name='total'), ))
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            outfile.write(' component=%s' % (self.gds_format_string(quote_attrib(self.component).encode(ExternalEncoding), input_name='component'), ))
        if self.increment is not None and 'increment' not in already_processed:
            already_processed.append('increment')
            outfile.write(' increment=%s' % (self.gds_format_string(quote_attrib(self.increment).encode(ExternalEncoding), input_name='increment'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Run', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Run'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            showIndent(outfile, level)
            outfile.write('total = "%s",\n' % (self.total,))
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            showIndent(outfile, level)
            outfile.write('component = "%s",\n' % (self.component,))
        if self.increment is not None and 'increment' not in already_processed:
            already_processed.append('increment')
            showIndent(outfile, level)
            outfile.write('increment = "%s",\n' % (self.increment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('total', node)
        if value is not None and 'total' not in already_processed:
            already_processed.append('total')
            self.total = value
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.append('component')
            self.component = value
        value = find_attr_value_('increment', node)
        if value is not None and 'increment' not in already_processed:
            already_processed.append('increment')
            self.increment = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Run


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Lems'
        rootClass = Lems
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='xmlns:lems="http://www.neuroml.org/lems/0.5"')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Lems'
        rootClass = Lems
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="Lems",
##         namespacedef_='xmlns:lems="http://www.neuroml.org/lems/0.5"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Lems'
        rootClass = Lems
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from lems import *\n\n')
##     sys.stdout.write('import lems as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Assign",
    "Attachments",
    "Behavior",
    "Build",
    "Child",
    "ChildInstance",
    "Children",
    "Component",
    "ComponentRef",
    "ComponentType",
    "Constant",
    "DefaultRun",
    "DerivedParameter",
    "DerivedVariable",
    "Dimension",
    "Edges",
    "EventConnection",
    "EventOut",
    "EventPort",
    "Exposure",
    "Fixed",
    "ForEach",
    "Include",
    "KineticScheme",
    "Lems",
    "Link",
    "MultiInstantiate",
    "NamedDimensionalType",
    "Nodes",
    "OnCondition",
    "OnEntry",
    "OnEvent",
    "OnStart",
    "Parameter",
    "Path",
    "Property",
    "Record",
    "Regime",
    "Requirement",
    "Run",
    "Show",
    "StateAssignment",
    "StateVariable",
    "Tabulable",
    "Text",
    "TimeDerivative",
    "Transition",
    "Unit",
    "With"
    ]
