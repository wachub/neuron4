#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Feb  1 19:21:07 2012 by generateDS.py version 2.7b_pg.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Point(GeneratedsSuper):
    """A 3D point with optional diameter. Note: the units for these values
    will be specified in the file in which the element is used, e.g.
    in a MorphML file with <b>length_units="micrometer"</b> in the
    morphml element. Assume micrometer if no other units are given."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None, diameter=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        self.diameter = _cast(float, diameter)
        pass
    def factory(*args_, **kwargs_):
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def getDiameter(self): return self.diameter
    def setDiameter(self, diameter): self.diameter = diameter
    def export(self, outfile, level, namespace_='', name_='Point', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter="%s"' % self.gds_format_double(self.diameter, input_name='diameter'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = %e,\n' % (self.diameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            try:
                self.diameter = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (diameter): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point


class Point3D(GeneratedsSuper):
    """A 3D point with no diameter. Note: the units for these values will
    be specified in the file in which the element is used, e.g. in a
    MorphML file with <b>length_units="micrometer"</b> in the
    morphml element. Assume micrometer if no other units are given."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        pass
    def factory(*args_, **kwargs_):
        if Point3D.subclass:
            return Point3D.subclass(*args_, **kwargs_)
        else:
            return Point3D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='Point3D', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point3D')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point3D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point3D', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point3D'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point3D


class Points(GeneratedsSuper):
    """A collection of points."""
    subclass = None
    superclass = None
    def __init__(self, name=None, point=None, extensiontype_=None):
        self.name = _cast(None, name)
        if point is None:
            self.point = []
        else:
            self.point = point
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Points.subclass:
            return Points.subclass(*args_, **kwargs_)
        else:
            return Points(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPoint(self): return self.point
    def setPoint(self, point): self.point = point
    def addPoint(self, value): self.point.append(value)
    def insertPoint(self, index, value): self.point[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Points', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Points')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Points'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Points', fromsubclass_=False):
        for point_ in self.point:
            point_.export(outfile, level, namespace_, name_='point')
    def hasContent_(self):
        if (
            self.point
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Points'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('point=[\n')
        level += 1
        for point_ in self.point:
            showIndent(outfile, level)
            outfile.write('model_.Point(\n')
            point_.exportLiteral(outfile, level, name_='Point')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = Point.factory()
            obj_.build(child_)
            self.point.append(obj_)
# end class Points


class Sphere(GeneratedsSuper):
    """A spherical structure such as a cell body or cell."""
    subclass = None
    superclass = None
    def __init__(self, name=None, center=None):
        self.name = _cast(None, name)
        self.center = center
    def factory(*args_, **kwargs_):
        if Sphere.subclass:
            return Sphere.subclass(*args_, **kwargs_)
        else:
            return Sphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCenter(self): return self.center
    def setCenter(self, center): self.center = center
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Sphere', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sphere')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sphere'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Sphere', fromsubclass_=False):
        if self.center is not None:
            self.center.export(outfile, level, namespace_, name_='center', )
    def hasContent_(self):
        if (
            self.center is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Sphere'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.center is not None:
            showIndent(outfile, level)
            outfile.write('center=model_.Point(\n')
            self.center.exportLiteral(outfile, level, name_='center')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'center':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setCenter(obj_)
# end class Sphere


class RectangularBox(GeneratedsSuper):
    """A Rectangular Box for locating cells in 3D."""
    subclass = None
    superclass = None
    def __init__(self, name=None, corner=None, size=None):
        self.name = _cast(None, name)
        self.corner = corner
        self.size = size
    def factory(*args_, **kwargs_):
        if RectangularBox.subclass:
            return RectangularBox.subclass(*args_, **kwargs_)
        else:
            return RectangularBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCorner(self): return self.corner
    def setCorner(self, corner): self.corner = corner
    def getSize(self): return self.size
    def setSize(self, size): self.size = size
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='RectangularBox', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RectangularBox')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RectangularBox'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RectangularBox', fromsubclass_=False):
        if self.corner is not None:
            self.corner.export(outfile, level, namespace_, name_='corner', )
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', )
    def hasContent_(self):
        if (
            self.corner is not None or
            self.size is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RectangularBox'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.corner is not None:
            showIndent(outfile, level)
            outfile.write('corner=model_.Point(\n')
            self.corner.exportLiteral(outfile, level, name_='corner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=model_.sizeType(\n')
            self.size.exportLiteral(outfile, level, name_='size')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'corner':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setCorner(obj_)
        elif nodeName_ == 'size':
            obj_ = sizeType.factory()
            obj_.build(child_)
            self.setSize(obj_)
# end class RectangularBox


class NonSpatialGrid(GeneratedsSuper):
    """Specifies a grid of up to 3 dimensions, without any explicit 3D
    location information."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(int, y)
        self.x = _cast(int, x)
        self.z = _cast(int, z)
        pass
    def factory(*args_, **kwargs_):
        if NonSpatialGrid.subclass:
            return NonSpatialGrid.subclass(*args_, **kwargs_)
        else:
            return NonSpatialGrid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='NonSpatialGrid', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonSpatialGrid')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonSpatialGrid'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_integer(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='NonSpatialGrid', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NonSpatialGrid'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %d,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %d,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %d,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.y <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.x <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.z <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NonSpatialGrid


class Manifold(Points):
    """A surface."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(Manifold, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if Manifold.subclass:
            return Manifold.subclass(*args_, **kwargs_)
        else:
            return Manifold(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Manifold', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Manifold')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Manifold'):
        super(Manifold, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Manifold')
    def exportChildren(self, outfile, level, namespace_='', name_='Manifold', fromsubclass_=False):
        super(Manifold, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Manifold, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Manifold'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Manifold, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Manifold, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Manifold, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Manifold, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Manifold


class Polygon(Points):
    """A closed structure represented by a list of points where the first
    point connects with the last point."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(Polygon, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if Polygon.subclass:
            return Polygon.subclass(*args_, **kwargs_)
        else:
            return Polygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Polygon', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Polygon')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Polygon'):
        super(Polygon, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Polygon')
    def exportChildren(self, outfile, level, namespace_='', name_='Polygon', fromsubclass_=False):
        super(Polygon, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Polygon, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Polygon'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Polygon, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Polygon, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Polygon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Polygon, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Polygon


class Polyhedron(GeneratedsSuper):
    """A 3d surface to represent the cell body or histological structure."""
    subclass = None
    superclass = None
    def __init__(self, polygons=None):
        self.polygons = polygons
    def factory(*args_, **kwargs_):
        if Polyhedron.subclass:
            return Polyhedron.subclass(*args_, **kwargs_)
        else:
            return Polyhedron(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPolygons(self): return self.polygons
    def setPolygons(self, polygons): self.polygons = polygons
    def export(self, outfile, level, namespace_='', name_='Polyhedron', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Polyhedron')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Polyhedron'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Polyhedron', fromsubclass_=False):
        if self.polygons is not None:
            self.polygons.export(outfile, level, namespace_, name_='polygons', )
    def hasContent_(self):
        if (
            self.polygons is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Polyhedron'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.polygons is not None:
            showIndent(outfile, level)
            outfile.write('polygons=model_.polygonsType(\n')
            self.polygons.exportLiteral(outfile, level, name_='polygons')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygons':
            obj_ = polygonsType.factory()
            obj_.build(child_)
            self.setPolygons(obj_)
# end class Polyhedron


class Annotation(GeneratedsSuper):
    """Concise processing directives for downstream applications."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='Annotation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Annotation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Annotation', fromsubclass_=False):
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Annotation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Annotation')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class Annotation


class Property(GeneratedsSuper):
    """A Tag/Value/Type tuple. Note prior to v1.7.1, tag and value were sub
    elements. The attribute option is now preferred."""
    subclass = None
    superclass = None
    def __init__(self, value_attr=None, tag_attr=None, tag=None, value=None):
        self.value_attr = _cast(None, value_attr)
        self.tag_attr = _cast(None, tag_attr)
        self.tag = tag
        self.value = value
    def factory(*args_, **kwargs_):
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTag(self): return self.tag
    def setTag(self, tag): self.tag = tag
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def getValue_attr(self): return self.value_attr
    def setValue_attr(self, value_attr): self.value_attr = value_attr
    def getTag_attr(self): return self.tag_attr
    def setTag_attr(self, tag_attr): self.tag_attr = tag_attr
    def export(self, outfile, level, namespace_='', name_='Property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Property'):
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            outfile.write(' value_attr=%s' % (self.gds_format_string(quote_attrib(self.value_attr).encode(ExternalEncoding), input_name='value_attr'), ))
        if self.tag_attr is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            outfile.write(' tag_attr=%s' % (self.gds_format_string(quote_attrib(self.tag_attr).encode(ExternalEncoding), input_name='tag_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Property', fromsubclass_=False):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('<%stag>%s</%stag>\n' % (namespace_, self.gds_format_string(quote_xml(self.tag).encode(ExternalEncoding), input_name='tag'), namespace_))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.tag is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            showIndent(outfile, level)
            outfile.write('value_attr = "%s",\n' % (self.value_attr,))
        if self.tag_attr is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            showIndent(outfile, level)
            outfile.write('tag_attr = "%s",\n' % (self.tag_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('tag=%s,\n' % quote_python(self.tag).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value_attr', node)
        if value is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            self.value_attr = value
        value = find_attr_value_('tag_attr', node)
        if value is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            self.tag_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            tag_ = child_.text
            tag_ = self.gds_validate_string(tag_, node, 'tag')
            self.tag = tag_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class Property


class Properties(GeneratedsSuper):
    """A collection of Properties"""
    subclass = None
    superclass = None
    def __init__(self, property=None):
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if Properties.subclass:
            return Properties.subclass(*args_, **kwargs_)
        else:
            return Properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def addProperty(self, value): self.property.append(value)
    def insertProperty(self, index, value): self.property[index] = value
    def export(self, outfile, level, namespace_='', name_='Properties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Properties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Properties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Properties', fromsubclass_=False):
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Properties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.Property(\n')
            property_.exportLiteral(outfile, level, name_='Property')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = Property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class Properties


class PropertyDetail(GeneratedsSuper):
    """Metadata for each Property."""
    subclass = None
    superclass = None
    def __init__(self, property=None, description=None, type_=None):
        self.property = _cast(None, property)
        self.description = description
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if PropertyDetail.subclass:
            return PropertyDetail.subclass(*args_, **kwargs_)
        else:
            return PropertyDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def export(self, outfile, level, namespace_='', name_='PropertyDetail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyDetail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyDetail'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyDetail', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None or
            self.type_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyDetail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            showIndent(outfile, level)
            outfile.write('property = "%s",\n' % (self.property,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.append('property')
            self.property = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class PropertyDetail


class GroupDetail(GeneratedsSuper):
    """Metadata for each Group."""
    subclass = None
    superclass = None
    def __init__(self, group=None, description=None, properties=None):
        self.group = _cast(None, group)
        self.description = description
        if properties is None:
            self.properties = []
        else:
            self.properties = properties
    def factory(*args_, **kwargs_):
        if GroupDetail.subclass:
            return GroupDetail.subclass(*args_, **kwargs_)
        else:
            return GroupDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def addProperties(self, value): self.properties.append(value)
    def insertProperties(self, index, value): self.properties[index] = value
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def export(self, outfile, level, namespace_='', name_='GroupDetail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupDetail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupDetail'):
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            outfile.write(' group=%s' % (self.gds_format_string(quote_attrib(self.group).encode(ExternalEncoding), input_name='group'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GroupDetail', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        for properties_ in self.properties:
            properties_.export(outfile, level, namespace_, name_='properties')
    def hasContent_(self):
        if (
            self.description is not None or
            self.properties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupDetail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            showIndent(outfile, level)
            outfile.write('group = "%s",\n' % (self.group,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('properties=[\n')
        level += 1
        for properties_ in self.properties:
            showIndent(outfile, level)
            outfile.write('model_.Properties(\n')
            properties_.exportLiteral(outfile, level, name_='Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.append('group')
            self.group = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.properties.append(obj_)
# end class GroupDetail


class NeuroMorphoRef(GeneratedsSuper):
    """A reference to an entity in NeuroMorpho.org Note: This element will
    possibly change when a new set of schema files is adopted for
    adding references, authors, citations, etc. See mailing lists
    for latest status"""
    subclass = None
    superclass = None
    def __init__(self, morphologyRef=None, uri=None, comment=None):
        self.morphologyRef = morphologyRef
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NeuroMorphoRef.subclass:
            return NeuroMorphoRef.subclass(*args_, **kwargs_)
        else:
            return NeuroMorphoRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMorphologyRef(self): return self.morphologyRef
    def setMorphologyRef(self, morphologyRef): self.morphologyRef = morphologyRef
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NeuroMorphoRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuroMorphoRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuroMorphoRef'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NeuroMorphoRef', fromsubclass_=False):
        if self.morphologyRef is not None:
            showIndent(outfile, level)
            outfile.write('<%smorphologyRef>%s</%smorphologyRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.morphologyRef).encode(ExternalEncoding), input_name='morphologyRef'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.morphologyRef is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuroMorphoRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.morphologyRef is not None:
            showIndent(outfile, level)
            outfile.write('morphologyRef=%s,\n' % quote_python(self.morphologyRef).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'morphologyRef':
            morphologyRef_ = child_.text
            morphologyRef_ = self.gds_validate_string(morphologyRef_, node, 'morphologyRef')
            self.morphologyRef = morphologyRef_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NeuroMorphoRef


class NeuronDBReference(GeneratedsSuper):
    """A reference to an entity in NeuronDB Note: This element will
    possibly change when a new set of schema files is adopted for
    adding references, authors, citations, etc. See mailing lists
    for latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelName=None, uri=None, comment=None):
        self.modelName = modelName
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NeuronDBReference.subclass:
            return NeuronDBReference.subclass(*args_, **kwargs_)
        else:
            return NeuronDBReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelName(self): return self.modelName
    def setModelName(self, modelName): self.modelName = modelName
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NeuronDBReference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuronDBReference')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuronDBReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NeuronDBReference', fromsubclass_=False):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('<%smodelName>%s</%smodelName>\n' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.modelName is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuronDBReference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NeuronDBReference


class ModelDBReference(GeneratedsSuper):
    """A reference to an entity in ModelDB Note: This element will possibly
    change when a new set of schema files is adopted for adding
    references, authors, citations, etc. See mailing lists for
    latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelName=None, uri=None, comment=None):
        self.modelName = modelName
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ModelDBReference.subclass:
            return ModelDBReference.subclass(*args_, **kwargs_)
        else:
            return ModelDBReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelName(self): return self.modelName
    def setModelName(self, modelName): self.modelName = modelName
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ModelDBReference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelDBReference')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelDBReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelDBReference', fromsubclass_=False):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('<%smodelName>%s</%smodelName>\n' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.modelName is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ModelDBReference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ModelDBReference


class Publication(GeneratedsSuper):
    """A reference to a publication Note: This element will possibly change
    when a new set of schema files is adopted for adding references,
    authors, citations, etc. See mailing lists for latest status"""
    subclass = None
    superclass = None
    def __init__(self, fullTitle=None, pubmedRef=None, comment=None):
        self.fullTitle = fullTitle
        self.pubmedRef = pubmedRef
        self.comment = comment
    def factory(*args_, **kwargs_):
        if Publication.subclass:
            return Publication.subclass(*args_, **kwargs_)
        else:
            return Publication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFullTitle(self): return self.fullTitle
    def setFullTitle(self, fullTitle): self.fullTitle = fullTitle
    def getPubmedRef(self): return self.pubmedRef
    def setPubmedRef(self, pubmedRef): self.pubmedRef = pubmedRef
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='Publication', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Publication')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Publication'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Publication', fromsubclass_=False):
        if self.fullTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sfullTitle>%s</%sfullTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.fullTitle).encode(ExternalEncoding), input_name='fullTitle'), namespace_))
        if self.pubmedRef is not None:
            showIndent(outfile, level)
            outfile.write('<%spubmedRef>%s</%spubmedRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.pubmedRef).encode(ExternalEncoding), input_name='pubmedRef'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.fullTitle is not None or
            self.pubmedRef is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Publication'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fullTitle is not None:
            showIndent(outfile, level)
            outfile.write('fullTitle=%s,\n' % quote_python(self.fullTitle).encode(ExternalEncoding))
        if self.pubmedRef is not None:
            showIndent(outfile, level)
            outfile.write('pubmedRef=%s,\n' % quote_python(self.pubmedRef).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullTitle':
            fullTitle_ = child_.text
            fullTitle_ = self.gds_validate_string(fullTitle_, node, 'fullTitle')
            self.fullTitle = fullTitle_
        elif nodeName_ == 'pubmedRef':
            pubmedRef_ = child_.text
            pubmedRef_ = self.gds_validate_string(pubmedRef_, node, 'pubmedRef')
            self.pubmedRef = pubmedRef_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class Publication


class Authors(GeneratedsSuper):
    """A reference to an author Note: This element will possibly change
    when a new set of schema files is adopted for adding references,
    authors, citations, etc. See mailing lists for latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelAuthor=None, modelTranslator=None):
        if modelAuthor is None:
            self.modelAuthor = []
        else:
            self.modelAuthor = modelAuthor
        if modelTranslator is None:
            self.modelTranslator = []
        else:
            self.modelTranslator = modelTranslator
    def factory(*args_, **kwargs_):
        if Authors.subclass:
            return Authors.subclass(*args_, **kwargs_)
        else:
            return Authors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelAuthor(self): return self.modelAuthor
    def setModelAuthor(self, modelAuthor): self.modelAuthor = modelAuthor
    def addModelAuthor(self, value): self.modelAuthor.append(value)
    def insertModelAuthor(self, index, value): self.modelAuthor[index] = value
    def getModelTranslator(self): return self.modelTranslator
    def setModelTranslator(self, modelTranslator): self.modelTranslator = modelTranslator
    def addModelTranslator(self, value): self.modelTranslator.append(value)
    def insertModelTranslator(self, index, value): self.modelTranslator[index] = value
    def export(self, outfile, level, namespace_='', name_='Authors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Authors')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Authors'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Authors', fromsubclass_=False):
        for modelAuthor_ in self.modelAuthor:
            modelAuthor_.export(outfile, level, namespace_, name_='modelAuthor')
        for modelTranslator_ in self.modelTranslator:
            modelTranslator_.export(outfile, level, namespace_, name_='modelTranslator')
    def hasContent_(self):
        if (
            self.modelAuthor or
            self.modelTranslator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Authors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('modelAuthor=[\n')
        level += 1
        for modelAuthor_ in self.modelAuthor:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            modelAuthor_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelTranslator=[\n')
        level += 1
        for modelTranslator_ in self.modelTranslator:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            modelTranslator_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelAuthor':
            obj_ = Person.factory()
            obj_.build(child_)
            self.modelAuthor.append(obj_)
        elif nodeName_ == 'modelTranslator':
            obj_ = Person.factory()
            obj_.build(child_)
            self.modelTranslator.append(obj_)
# end class Authors


class Person(GeneratedsSuper):
    """A generic reference to a person, for authorship, etc"""
    subclass = None
    superclass = None
    def __init__(self, name=None, institution=None, email=None, comment=None):
        self.name = name
        self.institution = institution
        self.email = email
        self.comment = comment
    def factory(*args_, **kwargs_):
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getInstitution(self): return self.institution
    def setInstitution(self, institution): self.institution = institution
    def getEmail(self): return self.email
    def setEmail(self, email): self.email = email
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='Person', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Person')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Person'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Person', fromsubclass_=False):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstitution>%s</%sinstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.institution).encode(ExternalEncoding), input_name='institution'), namespace_))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('<%semail>%s</%semail>\n' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.institution is not None or
            self.email is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Person'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('institution=%s,\n' % quote_python(self.institution).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'institution':
            institution_ = child_.text
            institution_ = self.gds_validate_string(institution_, node, 'institution')
            self.institution = institution_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class Person


class Status(GeneratedsSuper):
    """Status element giving the stability state of files and some extra
    comments.Currently an enum value of status/in progress/etc."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, issue=None, contributor=None):
        self.value = _cast(None, value)
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        if issue is None:
            self.issue = []
        else:
            self.issue = issue
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
    def factory(*args_, **kwargs_):
        if Status.subclass:
            return Status.subclass(*args_, **kwargs_)
        else:
            return Status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def addComment(self, value): self.comment.append(value)
    def insertComment(self, index, value): self.comment[index] = value
    def getIssue(self): return self.issue
    def setIssue(self, issue): self.issue = issue
    def addIssue(self, value): self.issue.append(value)
    def insertIssue(self, index, value): self.issue[index] = value
    def getContributor(self): return self.contributor
    def setContributor(self, contributor): self.contributor = contributor
    def addContributor(self, value): self.contributor.append(value)
    def insertContributor(self, index, value): self.contributor[index] = value
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def validate_StatusValue(self, value):
        # Validate type StatusValue, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Status', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Status')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Status'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Status', fromsubclass_=False):
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(comment_).encode(ExternalEncoding), input_name='comment'), namespace_))
        for issue_ in self.issue:
            showIndent(outfile, level)
            outfile.write('<%sissue>%s</%sissue>\n' % (namespace_, self.gds_format_string(quote_xml(issue_).encode(ExternalEncoding), input_name='issue'), namespace_))
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
    def hasContent_(self):
        if (
            self.comment or
            self.issue or
            self.contributor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('issue=[\n')
        level += 1
        for issue_ in self.issue:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(issue_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            contributor_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
            self.validate_StatusValue(self.value)    # validate type StatusValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment.append(comment_)
        elif nodeName_ == 'issue':
            issue_ = child_.text
            issue_ = self.gds_validate_string(issue_, node, 'issue')
            self.issue.append(issue_)
        elif nodeName_ == 'contributor':
            obj_ = Person.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
# end class Status


class sizeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, depth=None, height=None):
        self.width = _cast(float, width)
        self.depth = _cast(float, depth)
        self.height = _cast(float, height)
        pass
    def factory(*args_, **kwargs_):
        if sizeType.subclass:
            return sizeType.subclass(*args_, **kwargs_)
        else:
            return sizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWidth(self): return self.width
    def setWidth(self, width): self.width = width
    def getDepth(self): return self.depth
    def setDepth(self, depth): self.depth = depth
    def getHeight(self): return self.height
    def setHeight(self, height): self.height = height
    def export(self, outfile, level, namespace_='', name_='sizeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sizeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sizeType'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            outfile.write(' depth="%s"' % self.gds_format_double(self.depth, input_name='depth'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='sizeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sizeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = %e,\n' % (self.width,))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            showIndent(outfile, level)
            outfile.write('depth = %e,\n' % (self.depth,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            showIndent(outfile, level)
            outfile.write('height = %e,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            try:
                self.width = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
        value = find_attr_value_('depth', node)
        if value is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            try:
                self.depth = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (depth): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.append('height')
            try:
                self.height = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sizeType


class polygonsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polygon=None):
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
    def factory(*args_, **kwargs_):
        if polygonsType.subclass:
            return polygonsType.subclass(*args_, **kwargs_)
        else:
            return polygonsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPolygon(self): return self.polygon
    def setPolygon(self, polygon): self.polygon = polygon
    def addPolygon(self, value): self.polygon.append(value)
    def insertPolygon(self, index, value): self.polygon[index] = value
    def export(self, outfile, level, namespace_='', name_='polygonsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polygonsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polygonsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polygonsType', fromsubclass_=False):
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
    def hasContent_(self):
        if (
            self.polygon
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polygonsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.Polygon(\n')
            polygon_.exportLiteral(outfile, level, name_='Polygon')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = Polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
# end class polygonsType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Point'
        rootClass = Point
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='xmlns:meta="http://morphml.org/metadata/schema"')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Point'
        rootClass = Point
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="Point",
##         namespacedef_='xmlns:meta="http://morphml.org/metadata/schema"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Point'
        rootClass = Point
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from meta import *\n\n')
##     sys.stdout.write('import meta as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Annotation",
    "Authors",
    "GroupDetail",
    "Manifold",
    "ModelDBReference",
    "NeuroMorphoRef",
    "NeuronDBReference",
    "NonSpatialGrid",
    "Person",
    "Point",
    "Point3D",
    "Points",
    "Polygon",
    "Polyhedron",
    "Properties",
    "Property",
    "PropertyDetail",
    "Publication",
    "RectangularBox",
    "Sphere",
    "Status",
    "polygonsType",
    "sizeType"
    ]
