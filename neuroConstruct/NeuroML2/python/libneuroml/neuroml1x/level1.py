#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Feb  1 19:21:08 2012 by generateDS.py version 2.7b_pg.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class NeuroMLLevel1(GeneratedsSuper):
    """Description of cells compliant to NeuroML Level1.Unit of all length
    measurements. Usually has the value <b>micrometer</b>. Note:
    length_units will be the preferred form in v2.0Unit of all
    length measurements. Usually has the value <b>micrometer</b>.
    Note: length_units will be the preferred form in v2.0Unit of all
    volume measurements."""
    subclass = None
    superclass = None
    def __init__(self, volumeUnits='cubic_millimeter', lengthUnits=None, length_units=None, name=None, notes=None, properties=None, annotation=None, group=None, authorList=None, publication=None, neuronDBref=None, modelDBref=None, neuroMorphoRef=None, cells=None):
        self.volumeUnits = _cast(None, volumeUnits)
        self.lengthUnits = _cast(None, lengthUnits)
        self.length_units = _cast(None, length_units)
        self.name = _cast(None, name)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.authorList = authorList
        if publication is None:
            self.publication = []
        else:
            self.publication = publication
        if neuronDBref is None:
            self.neuronDBref = []
        else:
            self.neuronDBref = neuronDBref
        if modelDBref is None:
            self.modelDBref = []
        else:
            self.modelDBref = modelDBref
        if neuroMorphoRef is None:
            self.neuroMorphoRef = []
        else:
            self.neuroMorphoRef = neuroMorphoRef
        self.cells = cells
    def factory(*args_, **kwargs_):
        if NeuroMLLevel1.subclass:
            return NeuroMLLevel1.subclass(*args_, **kwargs_)
        else:
            return NeuroMLLevel1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getAuthorList(self): return self.authorList
    def setAuthorList(self, authorList): self.authorList = authorList
    def getPublication(self): return self.publication
    def setPublication(self, publication): self.publication = publication
    def addPublication(self, value): self.publication.append(value)
    def insertPublication(self, index, value): self.publication[index] = value
    def getNeuronDBref(self): return self.neuronDBref
    def setNeuronDBref(self, neuronDBref): self.neuronDBref = neuronDBref
    def addNeuronDBref(self, value): self.neuronDBref.append(value)
    def insertNeuronDBref(self, index, value): self.neuronDBref[index] = value
    def getModelDBref(self): return self.modelDBref
    def setModelDBref(self, modelDBref): self.modelDBref = modelDBref
    def addModelDBref(self, value): self.modelDBref.append(value)
    def insertModelDBref(self, index, value): self.modelDBref[index] = value
    def getNeuroMorphoRef(self): return self.neuroMorphoRef
    def setNeuroMorphoRef(self, neuroMorphoRef): self.neuroMorphoRef = neuroMorphoRef
    def addNeuroMorphoRef(self, value): self.neuroMorphoRef.append(value)
    def insertNeuroMorphoRef(self, index, value): self.neuroMorphoRef[index] = value
    def getCells(self): return self.cells
    def setCells(self, cells): self.cells = cells
    def getVolumeUnits(self): return self.volumeUnits
    def setVolumeUnits(self, volumeUnits): self.volumeUnits = volumeUnits
    def getLengthUnits(self): return self.lengthUnits
    def setLengthUnits(self, lengthUnits): self.lengthUnits = lengthUnits
    def getLength_units(self): return self.length_units
    def setLength_units(self, length_units): self.length_units = length_units
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='NeuroMLLevel1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuroMLLevel1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuroMLLevel1'):
        if self.volumeUnits is not None and 'volumeUnits' not in already_processed:
            already_processed.append('volumeUnits')
            outfile.write(' volumeUnits=%s' % (quote_attrib(self.volumeUnits), ))
        if self.lengthUnits is not None and 'lengthUnits' not in already_processed:
            already_processed.append('lengthUnits')
            outfile.write(' lengthUnits=%s' % (quote_attrib(self.lengthUnits), ))
        if self.length_units is not None and 'length_units' not in already_processed:
            already_processed.append('length_units')
            outfile.write(' length_units=%s' % (quote_attrib(self.length_units), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuroMLLevel1', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.authorList is not None:
            self.authorList.export(outfile, level, namespace_, name_='authorList')
        for publication_ in self.publication:
            publication_.export(outfile, level, namespace_, name_='publication')
        for neuronDBref_ in self.neuronDBref:
            neuronDBref_.export(outfile, level, namespace_, name_='neuronDBref')
        for modelDBref_ in self.modelDBref:
            modelDBref_.export(outfile, level, namespace_, name_='modelDBref')
        for neuroMorphoRef_ in self.neuroMorphoRef:
            neuroMorphoRef_.export(outfile, level, namespace_, name_='neuroMorphoRef')
        if self.cells is not None:
            self.cells.export(outfile, level, namespace_, name_='cells')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.authorList is not None or
            self.publication or
            self.neuronDBref or
            self.modelDBref or
            self.neuroMorphoRef or
            self.cells is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuroMLLevel1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.volumeUnits is not None and 'volumeUnits' not in already_processed:
            already_processed.append('volumeUnits')
            showIndent(outfile, level)
            outfile.write('volumeUnits = %s,\n' % (self.volumeUnits,))
        if self.lengthUnits is not None and 'lengthUnits' not in already_processed:
            already_processed.append('lengthUnits')
            showIndent(outfile, level)
            outfile.write('lengthUnits = %s,\n' % (self.lengthUnits,))
        if self.length_units is not None and 'length_units' not in already_processed:
            already_processed.append('length_units')
            showIndent(outfile, level)
            outfile.write('length_units = %s,\n' % (self.length_units,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.authorList is not None:
            showIndent(outfile, level)
            outfile.write('authorList=model_.Authors(\n')
            self.authorList.exportLiteral(outfile, level, name_='authorList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('publication=[\n')
        level += 1
        for publication_ in self.publication:
            showIndent(outfile, level)
            outfile.write('model_.Publication(\n')
            publication_.exportLiteral(outfile, level, name_='Publication')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuronDBref=[\n')
        level += 1
        for neuronDBref_ in self.neuronDBref:
            showIndent(outfile, level)
            outfile.write('model_.NeuronDBReference(\n')
            neuronDBref_.exportLiteral(outfile, level, name_='NeuronDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelDBref=[\n')
        level += 1
        for modelDBref_ in self.modelDBref:
            showIndent(outfile, level)
            outfile.write('model_.ModelDBReference(\n')
            modelDBref_.exportLiteral(outfile, level, name_='ModelDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuroMorphoRef=[\n')
        level += 1
        for neuroMorphoRef_ in self.neuroMorphoRef:
            showIndent(outfile, level)
            outfile.write('model_.NeuroMorphoRef(\n')
            neuroMorphoRef_.exportLiteral(outfile, level, name_='NeuroMorphoRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cells is not None:
            showIndent(outfile, level)
            outfile.write('cells=model_.cellsType(\n')
            self.cells.exportLiteral(outfile, level, name_='cells')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('volumeUnits', node)
        if value is not None and 'volumeUnits' not in already_processed:
            already_processed.append('volumeUnits')
            self.volumeUnits = value
        value = find_attr_value_('lengthUnits', node)
        if value is not None and 'lengthUnits' not in already_processed:
            already_processed.append('lengthUnits')
            self.lengthUnits = value
        value = find_attr_value_('length_units', node)
        if value is not None and 'length_units' not in already_processed:
            already_processed.append('length_units')
            self.length_units = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'authorList':
            obj_ = Authors.factory()
            obj_.build(child_)
            self.setAuthorList(obj_)
        elif nodeName_ == 'publication':
            obj_ = Publication.factory()
            obj_.build(child_)
            self.publication.append(obj_)
        elif nodeName_ == 'neuronDBref':
            obj_ = NeuronDBReference.factory()
            obj_.build(child_)
            self.neuronDBref.append(obj_)
        elif nodeName_ == 'modelDBref':
            obj_ = ModelDBReference.factory()
            obj_.build(child_)
            self.modelDBref.append(obj_)
        elif nodeName_ == 'neuroMorphoRef':
            obj_ = NeuroMorphoRef.factory()
            obj_.build(child_)
            self.neuroMorphoRef.append(obj_)
        elif nodeName_ == 'cells':
            obj_ = cellsType.factory()
            obj_.build(child_)
            self.setCells(obj_)
# end class NeuroMLLevel1


class Morphology(GeneratedsSuper):
    """The main element which details the neuronal morphology. Cells,
    various histological features, and properties associated with
    the data can be contained in this elementAn optional name which
    can be given to the morphologyUnit of all length measurements.
    Usually has the value <b>micrometer</b>. Note: length_units will
    be the preferred form in v2.0Unit of all length measurements.
    Usually has the value <b>micrometer</b>. Note: length_units will
    be the preferred form in v2.0Unit of all volume measurements."""
    subclass = None
    superclass = None
    def __init__(self, volumeUnits='cubic_millimeter', lengthUnits=None, length_units=None, name=None, notes=None, properties=None, annotation=None, group=None, cells=None, features=None, propertyDetails=None, groupDetails=None):
        self.volumeUnits = _cast(None, volumeUnits)
        self.lengthUnits = _cast(None, lengthUnits)
        self.length_units = _cast(None, length_units)
        self.name = _cast(None, name)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.cells = cells
        self.features = features
        self.propertyDetails = propertyDetails
        self.groupDetails = groupDetails
    def factory(*args_, **kwargs_):
        if Morphology.subclass:
            return Morphology.subclass(*args_, **kwargs_)
        else:
            return Morphology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getCells(self): return self.cells
    def setCells(self, cells): self.cells = cells
    def getFeatures(self): return self.features
    def setFeatures(self, features): self.features = features
    def getPropertyDetails(self): return self.propertyDetails
    def setPropertyDetails(self, propertyDetails): self.propertyDetails = propertyDetails
    def getGroupDetails(self): return self.groupDetails
    def setGroupDetails(self, groupDetails): self.groupDetails = groupDetails
    def getVolumeUnits(self): return self.volumeUnits
    def setVolumeUnits(self, volumeUnits): self.volumeUnits = volumeUnits
    def getLengthUnits(self): return self.lengthUnits
    def setLengthUnits(self, lengthUnits): self.lengthUnits = lengthUnits
    def getLength_units(self): return self.length_units
    def setLength_units(self, length_units): self.length_units = length_units
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Morphology', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Morphology')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Morphology'):
        if self.volumeUnits is not None and 'volumeUnits' not in already_processed:
            already_processed.append('volumeUnits')
            outfile.write(' volumeUnits=%s' % (quote_attrib(self.volumeUnits), ))
        if self.lengthUnits is not None and 'lengthUnits' not in already_processed:
            already_processed.append('lengthUnits')
            outfile.write(' lengthUnits=%s' % (quote_attrib(self.lengthUnits), ))
        if self.length_units is not None and 'length_units' not in already_processed:
            already_processed.append('length_units')
            outfile.write(' length_units=%s' % (quote_attrib(self.length_units), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Morphology', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.cells is not None:
            self.cells.export(outfile, level, namespace_, name_='cells', )
        if self.features is not None:
            self.features.export(outfile, level, namespace_, name_='features')
        if self.propertyDetails is not None:
            self.propertyDetails.export(outfile, level, namespace_, name_='propertyDetails')
        if self.groupDetails is not None:
            self.groupDetails.export(outfile, level, namespace_, name_='groupDetails')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.cells is not None or
            self.features is not None or
            self.propertyDetails is not None or
            self.groupDetails is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Morphology'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.volumeUnits is not None and 'volumeUnits' not in already_processed:
            already_processed.append('volumeUnits')
            showIndent(outfile, level)
            outfile.write('volumeUnits = %s,\n' % (self.volumeUnits,))
        if self.lengthUnits is not None and 'lengthUnits' not in already_processed:
            already_processed.append('lengthUnits')
            showIndent(outfile, level)
            outfile.write('lengthUnits = %s,\n' % (self.lengthUnits,))
        if self.length_units is not None and 'length_units' not in already_processed:
            already_processed.append('length_units')
            showIndent(outfile, level)
            outfile.write('length_units = %s,\n' % (self.length_units,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cells is not None:
            showIndent(outfile, level)
            outfile.write('cells=model_.Cells(\n')
            self.cells.exportLiteral(outfile, level, name_='cells')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.features is not None:
            showIndent(outfile, level)
            outfile.write('features=model_.featuresType(\n')
            self.features.exportLiteral(outfile, level, name_='features')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.propertyDetails is not None:
            showIndent(outfile, level)
            outfile.write('propertyDetails=model_.propertyDetailsType(\n')
            self.propertyDetails.exportLiteral(outfile, level, name_='propertyDetails')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.groupDetails is not None:
            showIndent(outfile, level)
            outfile.write('groupDetails=model_.groupDetailsType(\n')
            self.groupDetails.exportLiteral(outfile, level, name_='groupDetails')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('volumeUnits', node)
        if value is not None and 'volumeUnits' not in already_processed:
            already_processed.append('volumeUnits')
            self.volumeUnits = value
        value = find_attr_value_('lengthUnits', node)
        if value is not None and 'lengthUnits' not in already_processed:
            already_processed.append('lengthUnits')
            self.lengthUnits = value
        value = find_attr_value_('length_units', node)
        if value is not None and 'length_units' not in already_processed:
            already_processed.append('length_units')
            self.length_units = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'cells':
            obj_ = Cells.factory()
            obj_.build(child_)
            self.setCells(obj_)
        elif nodeName_ == 'features':
            obj_ = featuresType.factory()
            obj_.build(child_)
            self.setFeatures(obj_)
        elif nodeName_ == 'propertyDetails':
            obj_ = propertyDetailsType.factory()
            obj_.build(child_)
            self.setPropertyDetails(obj_)
        elif nodeName_ == 'groupDetails':
            obj_ = groupDetailsType.factory()
            obj_.build(child_)
            self.setGroupDetails(obj_)
# end class Morphology


class Cells(GeneratedsSuper):
    """Collection of all cells."""
    subclass = None
    superclass = None
    def __init__(self, cell=None):
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if Cells.subclass:
            return Cells.subclass(*args_, **kwargs_)
        else:
            return Cells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCell(self): return self.cell
    def setCell(self, cell): self.cell = cell
    def addCell(self, value): self.cell.append(value)
    def insertCell(self, index, value): self.cell[index] = value
    def export(self, outfile, level, namespace_='', name_='Cells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cells'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Cells', fromsubclass_=False):
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.Cell(\n')
            cell_.exportLiteral(outfile, level, name_='Cell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cell':
            obj_ = Cell.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class Cells


class Cell(GeneratedsSuper):
    """Definition of a cell."""
    subclass = None
    superclass = None
    def __init__(self, name=None, status=None, notes=None, properties=None, annotation=None, group=None, authorList=None, publication=None, neuronDBref=None, modelDBref=None, neuroMorphoRef=None, segments=None, cables=None, cellBody=None, spines=None, freePoints=None):
        self.name = _cast(None, name)
        self.status = status
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.authorList = authorList
        if publication is None:
            self.publication = []
        else:
            self.publication = publication
        if neuronDBref is None:
            self.neuronDBref = []
        else:
            self.neuronDBref = neuronDBref
        if modelDBref is None:
            self.modelDBref = []
        else:
            self.modelDBref = modelDBref
        if neuroMorphoRef is None:
            self.neuroMorphoRef = []
        else:
            self.neuroMorphoRef = neuroMorphoRef
        self.segments = segments
        self.cables = cables
        self.cellBody = cellBody
        self.spines = spines
        self.freePoints = freePoints
    def factory(*args_, **kwargs_):
        if Cell.subclass:
            return Cell.subclass(*args_, **kwargs_)
        else:
            return Cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getAuthorList(self): return self.authorList
    def setAuthorList(self, authorList): self.authorList = authorList
    def getPublication(self): return self.publication
    def setPublication(self, publication): self.publication = publication
    def addPublication(self, value): self.publication.append(value)
    def insertPublication(self, index, value): self.publication[index] = value
    def getNeuronDBref(self): return self.neuronDBref
    def setNeuronDBref(self, neuronDBref): self.neuronDBref = neuronDBref
    def addNeuronDBref(self, value): self.neuronDBref.append(value)
    def insertNeuronDBref(self, index, value): self.neuronDBref[index] = value
    def getModelDBref(self): return self.modelDBref
    def setModelDBref(self, modelDBref): self.modelDBref = modelDBref
    def addModelDBref(self, value): self.modelDBref.append(value)
    def insertModelDBref(self, index, value): self.modelDBref[index] = value
    def getNeuroMorphoRef(self): return self.neuroMorphoRef
    def setNeuroMorphoRef(self, neuroMorphoRef): self.neuroMorphoRef = neuroMorphoRef
    def addNeuroMorphoRef(self, value): self.neuroMorphoRef.append(value)
    def insertNeuroMorphoRef(self, index, value): self.neuroMorphoRef[index] = value
    def getSegments(self): return self.segments
    def setSegments(self, segments): self.segments = segments
    def getCables(self): return self.cables
    def setCables(self, cables): self.cables = cables
    def getCellBody(self): return self.cellBody
    def setCellBody(self, cellBody): self.cellBody = cellBody
    def getSpines(self): return self.spines
    def setSpines(self, spines): self.spines = spines
    def getFreePoints(self): return self.freePoints
    def setFreePoints(self, freePoints): self.freePoints = freePoints
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Cell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cell'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Cell', fromsubclass_=False):
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.authorList is not None:
            self.authorList.export(outfile, level, namespace_, name_='authorList')
        for publication_ in self.publication:
            publication_.export(outfile, level, namespace_, name_='publication')
        for neuronDBref_ in self.neuronDBref:
            neuronDBref_.export(outfile, level, namespace_, name_='neuronDBref')
        for modelDBref_ in self.modelDBref:
            modelDBref_.export(outfile, level, namespace_, name_='modelDBref')
        for neuroMorphoRef_ in self.neuroMorphoRef:
            neuroMorphoRef_.export(outfile, level, namespace_, name_='neuroMorphoRef')
        if self.segments is not None:
            self.segments.export(outfile, level, namespace_, name_='segments', )
        if self.cables is not None:
            self.cables.export(outfile, level, namespace_, name_='cables')
        if self.cellBody is not None:
            self.cellBody.export(outfile, level, namespace_, name_='cellBody')
        if self.spines is not None:
            self.spines.export(outfile, level, namespace_, name_='spines')
        if self.freePoints is not None:
            self.freePoints.export(outfile, level, namespace_, name_='freePoints')
    def hasContent_(self):
        if (
            self.status is not None or
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.authorList is not None or
            self.publication or
            self.neuronDBref or
            self.modelDBref or
            self.neuroMorphoRef or
            self.segments is not None or
            self.cables is not None or
            self.cellBody is not None or
            self.spines is not None or
            self.freePoints is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.Status(\n')
            self.status.exportLiteral(outfile, level, name_='status')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.authorList is not None:
            showIndent(outfile, level)
            outfile.write('authorList=model_.Authors(\n')
            self.authorList.exportLiteral(outfile, level, name_='authorList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('publication=[\n')
        level += 1
        for publication_ in self.publication:
            showIndent(outfile, level)
            outfile.write('model_.Publication(\n')
            publication_.exportLiteral(outfile, level, name_='Publication')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuronDBref=[\n')
        level += 1
        for neuronDBref_ in self.neuronDBref:
            showIndent(outfile, level)
            outfile.write('model_.NeuronDBReference(\n')
            neuronDBref_.exportLiteral(outfile, level, name_='NeuronDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelDBref=[\n')
        level += 1
        for modelDBref_ in self.modelDBref:
            showIndent(outfile, level)
            outfile.write('model_.ModelDBReference(\n')
            modelDBref_.exportLiteral(outfile, level, name_='ModelDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuroMorphoRef=[\n')
        level += 1
        for neuroMorphoRef_ in self.neuroMorphoRef:
            showIndent(outfile, level)
            outfile.write('model_.NeuroMorphoRef(\n')
            neuroMorphoRef_.exportLiteral(outfile, level, name_='NeuroMorphoRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.segments is not None:
            showIndent(outfile, level)
            outfile.write('segments=model_.segmentsType(\n')
            self.segments.exportLiteral(outfile, level, name_='segments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cables is not None:
            showIndent(outfile, level)
            outfile.write('cables=model_.cablesType(\n')
            self.cables.exportLiteral(outfile, level, name_='cables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cellBody is not None:
            showIndent(outfile, level)
            outfile.write('cellBody=model_.cellBodyType(\n')
            self.cellBody.exportLiteral(outfile, level, name_='cellBody')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spines is not None:
            showIndent(outfile, level)
            outfile.write('spines=model_.spinesType(\n')
            self.spines.exportLiteral(outfile, level, name_='spines')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.freePoints is not None:
            showIndent(outfile, level)
            outfile.write('freePoints=model_.FreePoints(\n')
            self.freePoints.exportLiteral(outfile, level, name_='freePoints')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = Status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'authorList':
            obj_ = Authors.factory()
            obj_.build(child_)
            self.setAuthorList(obj_)
        elif nodeName_ == 'publication':
            obj_ = Publication.factory()
            obj_.build(child_)
            self.publication.append(obj_)
        elif nodeName_ == 'neuronDBref':
            obj_ = NeuronDBReference.factory()
            obj_.build(child_)
            self.neuronDBref.append(obj_)
        elif nodeName_ == 'modelDBref':
            obj_ = ModelDBReference.factory()
            obj_.build(child_)
            self.modelDBref.append(obj_)
        elif nodeName_ == 'neuroMorphoRef':
            obj_ = NeuroMorphoRef.factory()
            obj_.build(child_)
            self.neuroMorphoRef.append(obj_)
        elif nodeName_ == 'segments':
            obj_ = segmentsType.factory()
            obj_.build(child_)
            self.setSegments(obj_)
        elif nodeName_ == 'cables':
            obj_ = cablesType.factory()
            obj_.build(child_)
            self.setCables(obj_)
        elif nodeName_ == 'cellBody':
            obj_ = cellBodyType.factory()
            obj_.build(child_)
            self.setCellBody(obj_)
        elif nodeName_ == 'spines':
            obj_ = spinesType.factory()
            obj_.build(child_)
            self.setSpines(obj_)
        elif nodeName_ == 'freePoints':
            obj_ = FreePoints.factory()
            obj_.build(child_)
            self.setFreePoints(obj_)
# end class Cell


class Segment(GeneratedsSuper):
    """Defines the smallest unit within a possibly branching structure,
    such as a segment of a dendrite or axon. The parent attribute is
    used to define connectivity. A segment would be mapped to a
    compartment in a compartmental modelling application such as
    GENESISThe ID of the segment, which should be unique within the
    cell.As many simulators use a string to identify the
    compartments, etc. a unique name can be given to the
    segment.Used to indicate logical connectivity between segments.
    Note that there is no requirement that the end point of this
    parent segment is equal to the start point of this segment.The
    cable ID of which this segment is part. Numerous segments will
    make up one cable, and it is assumed these are connected
    electrically."""
    subclass = None
    superclass = None
    def __init__(self, cable=None, id=None, parent=None, name=None, proximal=None, distal=None, properties=None):
        self.cable = _cast(int, cable)
        self.id = _cast(None, id)
        self.parent = _cast(None, parent)
        self.name = _cast(None, name)
        self.proximal = proximal
        self.distal = distal
        self.properties = properties
    def factory(*args_, **kwargs_):
        if Segment.subclass:
            return Segment.subclass(*args_, **kwargs_)
        else:
            return Segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProximal(self): return self.proximal
    def setProximal(self, proximal): self.proximal = proximal
    def getDistal(self): return self.distal
    def setDistal(self, distal): self.distal = distal
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getCable(self): return self.cable
    def setCable(self, cable): self.cable = cable
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def getParent(self): return self.parent
    def setParent(self, parent): self.parent = parent
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Segment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Segment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Segment'):
        if self.cable is not None and 'cable' not in already_processed:
            already_processed.append('cable')
            outfile.write(' cable="%s"' % self.gds_format_integer(self.cable, input_name='cable'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            outfile.write(' parent=%s' % (quote_attrib(self.parent), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Segment', fromsubclass_=False):
        if self.proximal is not None:
            self.proximal.export(outfile, level, namespace_, name_='proximal')
        if self.distal is not None:
            self.distal.export(outfile, level, namespace_, name_='distal', )
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
    def hasContent_(self):
        if (
            self.proximal is not None or
            self.distal is not None or
            self.properties is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Segment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cable is not None and 'cable' not in already_processed:
            already_processed.append('cable')
            showIndent(outfile, level)
            outfile.write('cable = %d,\n' % (self.cable,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            showIndent(outfile, level)
            outfile.write('parent = %s,\n' % (self.parent,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.proximal is not None:
            showIndent(outfile, level)
            outfile.write('proximal=model_.Point(\n')
            self.proximal.exportLiteral(outfile, level, name_='proximal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distal is not None:
            showIndent(outfile, level)
            outfile.write('distal=model_.Point(\n')
            self.distal.exportLiteral(outfile, level, name_='distal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cable', node)
        if value is not None and 'cable' not in already_processed:
            already_processed.append('cable')
            try:
                self.cable = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.cable < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            self.parent = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'proximal':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setProximal(obj_)
        elif nodeName_ == 'distal':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setDistal(obj_)
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
# end class Segment


class Cable(GeneratedsSuper):
    """Definition of a cable. A cable is a non-branching group of connected
    segments. A cable would be mapped to a section in a cable
    modelling based simulator such as NEURONID of the cable, unique
    within this cellAs many simulators use a string to identify the
    sections, etc. a unique name can be given to the segment.A cable
    ID. A way to connect cables logically.Approximate location of
    this section's proximal point along the parent cable. NOTE: this
    attribute will be removed in v2.0!! Use fract_along_parent
    instead. Changed for consistency with ChannelML and NetworkML
    naming conventions.Connection location of this section's
    proximal point along the parent cable. Normally this could be
    determined by the 3D points, but this option is needed as many
    reconstructed neurons have dendrites "floating in space",
    possibly due to drift of the slice. In this case the
    fract_along_parent determines electrical connectivity, and it is
    up to the loading application/its user to decide to ignore the
    discrepancy, move the dendrite or fill in an extra section.
    NOTE: this attribute will be required in v2.0!! Don't use
    fractAlongParent anymore. Changed for consistency with ChannelML
    and NetworkML naming conventions."""
    subclass = None
    superclass = None
    def __init__(self, fractAlongParent=None, fract_along_parent=None, id=None, parent=None, name=None, notes=None, properties=None, annotation=None, group=None):
        self.fractAlongParent = _cast(None, fractAlongParent)
        self.fract_along_parent = _cast(None, fract_along_parent)
        self.id = _cast(int, id)
        self.parent = _cast(int, parent)
        self.name = _cast(None, name)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if Cable.subclass:
            return Cable.subclass(*args_, **kwargs_)
        else:
            return Cable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getFractAlongParent(self): return self.fractAlongParent
    def setFractAlongParent(self, fractAlongParent): self.fractAlongParent = fractAlongParent
    def getFract_along_parent(self): return self.fract_along_parent
    def setFract_along_parent(self, fract_along_parent): self.fract_along_parent = fract_along_parent
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def getParent(self): return self.parent
    def setParent(self, parent): self.parent = parent
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Cable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cable'):
        if self.fractAlongParent is not None and 'fractAlongParent' not in already_processed:
            already_processed.append('fractAlongParent')
            outfile.write(' fractAlongParent=%s' % (quote_attrib(self.fractAlongParent), ))
        if self.fract_along_parent is not None and 'fract_along_parent' not in already_processed:
            already_processed.append('fract_along_parent')
            outfile.write(' fract_along_parent=%s' % (quote_attrib(self.fract_along_parent), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            outfile.write(' parent="%s"' % self.gds_format_integer(self.parent, input_name='parent'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Cable', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fractAlongParent is not None and 'fractAlongParent' not in already_processed:
            already_processed.append('fractAlongParent')
            showIndent(outfile, level)
            outfile.write('fractAlongParent = %s,\n' % (self.fractAlongParent,))
        if self.fract_along_parent is not None and 'fract_along_parent' not in already_processed:
            already_processed.append('fract_along_parent')
            showIndent(outfile, level)
            outfile.write('fract_along_parent = %s,\n' % (self.fract_along_parent,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            showIndent(outfile, level)
            outfile.write('parent = %d,\n' % (self.parent,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fractAlongParent', node)
        if value is not None and 'fractAlongParent' not in already_processed:
            already_processed.append('fractAlongParent')
            self.fractAlongParent = value
        value = find_attr_value_('fract_along_parent', node)
        if value is not None and 'fract_along_parent' not in already_processed:
            already_processed.append('fract_along_parent')
            self.fract_along_parent = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            try:
                self.parent = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.parent < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
# end class Cable


class CableGroup(GeneratedsSuper):
    """Definition of a cable group. Cable groups can also be specified by
    adding an element group to the cable elementName of the cable
    group"""
    subclass = None
    superclass = None
    def __init__(self, name=None, cable=None, inhomogeneous_param=None):
        self.name = _cast(None, name)
        if cable is None:
            self.cable = []
        else:
            self.cable = cable
        if inhomogeneous_param is None:
            self.inhomogeneous_param = []
        else:
            self.inhomogeneous_param = inhomogeneous_param
    def factory(*args_, **kwargs_):
        if CableGroup.subclass:
            return CableGroup.subclass(*args_, **kwargs_)
        else:
            return CableGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCable(self): return self.cable
    def setCable(self, cable): self.cable = cable
    def addCable(self, value): self.cable.append(value)
    def insertCable(self, index, value): self.cable[index] = value
    def getInhomogeneousParam(self): return self.inhomogeneous_param
    def setInhomogeneousParam(self, inhomogeneous_param): self.inhomogeneous_param = inhomogeneous_param
    def addInhomogeneousParam(self, value): self.inhomogeneous_param.append(value)
    def insertInhomogeneousParam(self, index, value): self.inhomogeneous_param[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='CableGroup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CableGroup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CableGroup'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CableGroup', fromsubclass_=False):
        for cable_ in self.cable:
            cable_.export(outfile, level, namespace_, name_='cable')
        for inhomogeneous_param_ in self.inhomogeneous_param:
            inhomogeneous_param_.export(outfile, level, namespace_, name_='inhomogeneous_param')
    def hasContent_(self):
        if (
            self.cable or
            self.inhomogeneous_param
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CableGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cable=[\n')
        level += 1
        for cable_ in self.cable:
            showIndent(outfile, level)
            outfile.write('model_.cableType(\n')
            cable_.exportLiteral(outfile, level, name_='cableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('inhomogeneous_param=[\n')
        level += 1
        for inhomogeneous_param_ in self.inhomogeneous_param:
            showIndent(outfile, level)
            outfile.write('model_.InhomogeneousParam(\n')
            inhomogeneous_param_.exportLiteral(outfile, level, name_='InhomogeneousParam')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cable':
            obj_ = cableType.factory()
            obj_.build(child_)
            self.cable.append(obj_)
        elif nodeName_ == 'inhomogeneous_param':
            obj_ = InhomogeneousParam.factory()
            obj_.build(child_)
            self.inhomogeneous_param.append(obj_)
# end class CableGroup


class InhomogeneousParam(GeneratedsSuper):
    """Definition of a parameter which varies along a cable group.Name of
    the inhomogeneous parameter specificationName of the variable
    which will change over the length"""
    subclass = None
    superclass = None
    def __init__(self, variable=None, name=None, metric=None, proximal=None, distal=None):
        self.variable = _cast(None, variable)
        self.name = _cast(None, name)
        self.metric = metric
        self.proximal = proximal
        self.distal = distal
    def factory(*args_, **kwargs_):
        if InhomogeneousParam.subclass:
            return InhomogeneousParam.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousParam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMetric(self): return self.metric
    def setMetric(self, metric): self.metric = metric
    def validate_Metric(self, value):
        # Validate type Metric, a restriction on xs:string.
        pass
    def getProximal(self): return self.proximal
    def setProximal(self, proximal): self.proximal = proximal
    def getDistal(self): return self.distal
    def setDistal(self, distal): self.distal = distal
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='InhomogeneousParam', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InhomogeneousParam')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InhomogeneousParam'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InhomogeneousParam', fromsubclass_=False):
        if self.metric is not None:
            showIndent(outfile, level)
            outfile.write('<%smetric>%s</%smetric>\n' % (namespace_, self.gds_format_string(quote_xml(self.metric).encode(ExternalEncoding), input_name='metric'), namespace_))
        if self.proximal is not None:
            self.proximal.export(outfile, level, namespace_, name_='proximal')
        if self.distal is not None:
            self.distal.export(outfile, level, namespace_, name_='distal')
    def hasContent_(self):
        if (
            self.metric is not None or
            self.proximal is not None or
            self.distal is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InhomogeneousParam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metric is not None:
            showIndent(outfile, level)
            outfile.write('metric=%s,\n' % quote_python(self.metric).encode(ExternalEncoding))
        if self.proximal is not None:
            showIndent(outfile, level)
            outfile.write('proximal=model_.proximalType(\n')
            self.proximal.exportLiteral(outfile, level, name_='proximal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distal is not None:
            showIndent(outfile, level)
            outfile.write('distal=model_.distalType(\n')
            self.distal.exportLiteral(outfile, level, name_='distal')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metric':
            metric_ = child_.text
            metric_ = self.gds_validate_string(metric_, node, 'metric')
            self.metric = metric_
            self.validate_Metric(self.metric)    # validate type Metric
        elif nodeName_ == 'proximal':
            obj_ = proximalType.factory()
            obj_.build(child_)
            self.setProximal(obj_)
        elif nodeName_ == 'distal':
            obj_ = distalType.factory()
            obj_.build(child_)
            self.setDistal(obj_)
# end class InhomogeneousParam


class Spine(GeneratedsSuper):
    """A spine with location, shape, and direction.The segment with which
    this spine is associated."""
    subclass = None
    superclass = None
    def __init__(self, volume=None, length=None, shape=None, parent=None, proximal=None, distal=None):
        self.volume = _cast(float, volume)
        self.length = _cast(float, length)
        self.shape = _cast(None, shape)
        self.parent = _cast(None, parent)
        self.proximal = proximal
        self.distal = distal
    def factory(*args_, **kwargs_):
        if Spine.subclass:
            return Spine.subclass(*args_, **kwargs_)
        else:
            return Spine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProximal(self): return self.proximal
    def setProximal(self, proximal): self.proximal = proximal
    def getDistal(self): return self.distal
    def setDistal(self, distal): self.distal = distal
    def getVolume(self): return self.volume
    def setVolume(self, volume): self.volume = volume
    def getLength(self): return self.length
    def setLength(self, length): self.length = length
    def getShape(self): return self.shape
    def setShape(self, shape): self.shape = shape
    def validate_SpineShape(self, value):
        # Validate type SpineShape, a restriction on xs:string.
        pass
    def getParent(self): return self.parent
    def setParent(self, parent): self.parent = parent
    def export(self, outfile, level, namespace_='', name_='Spine', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Spine')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Spine'):
        if self.volume is not None and 'volume' not in already_processed:
            already_processed.append('volume')
            outfile.write(' volume="%s"' % self.gds_format_double(self.volume, input_name='volume'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            outfile.write(' shape=%s' % (quote_attrib(self.shape), ))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            outfile.write(' parent=%s' % (quote_attrib(self.parent), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Spine', fromsubclass_=False):
        if self.proximal is not None:
            self.proximal.export(outfile, level, namespace_, name_='proximal', )
        if self.distal is not None:
            self.distal.export(outfile, level, namespace_, name_='distal')
    def hasContent_(self):
        if (
            self.proximal is not None or
            self.distal is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Spine'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.volume is not None and 'volume' not in already_processed:
            already_processed.append('volume')
            showIndent(outfile, level)
            outfile.write('volume = %e,\n' % (self.volume,))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            showIndent(outfile, level)
            outfile.write('length = %e,\n' % (self.length,))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            showIndent(outfile, level)
            outfile.write('shape = "%s",\n' % (self.shape,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            showIndent(outfile, level)
            outfile.write('parent = %s,\n' % (self.parent,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.proximal is not None:
            showIndent(outfile, level)
            outfile.write('proximal=model_.Point(\n')
            self.proximal.exportLiteral(outfile, level, name_='proximal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distal is not None:
            showIndent(outfile, level)
            outfile.write('distal=model_.Point(\n')
            self.distal.exportLiteral(outfile, level, name_='distal')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('volume', node)
        if value is not None and 'volume' not in already_processed:
            already_processed.append('volume')
            try:
                self.volume = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (volume): %s' % exp)
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.append('length')
            try:
                self.length = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            self.shape = value
            self.validate_SpineShape(self.shape)    # validate type SpineShape
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            self.parent = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'proximal':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setProximal(obj_)
        elif nodeName_ == 'distal':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setDistal(obj_)
# end class Spine


class Feature(GeneratedsSuper):
    """The group of things allowed in features."""
    subclass = None
    superclass = None
    def __init__(self, name=None, notes=None, properties=None, annotation=None, group=None, path=None, freePoints=None, manifold=None, polygon=None, polyhedron=None, sphere=None):
        self.name = _cast(None, name)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        if path is None:
            self.path = []
        else:
            self.path = path
        if freePoints is None:
            self.freePoints = []
        else:
            self.freePoints = freePoints
        if manifold is None:
            self.manifold = []
        else:
            self.manifold = manifold
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if polyhedron is None:
            self.polyhedron = []
        else:
            self.polyhedron = polyhedron
        if sphere is None:
            self.sphere = []
        else:
            self.sphere = sphere
    def factory(*args_, **kwargs_):
        if Feature.subclass:
            return Feature.subclass(*args_, **kwargs_)
        else:
            return Feature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getPath(self): return self.path
    def setPath(self, path): self.path = path
    def addPath(self, value): self.path.append(value)
    def insertPath(self, index, value): self.path[index] = value
    def getFreePoints(self): return self.freePoints
    def setFreePoints(self, freePoints): self.freePoints = freePoints
    def addFreePoints(self, value): self.freePoints.append(value)
    def insertFreePoints(self, index, value): self.freePoints[index] = value
    def getManifold(self): return self.manifold
    def setManifold(self, manifold): self.manifold = manifold
    def addManifold(self, value): self.manifold.append(value)
    def insertManifold(self, index, value): self.manifold[index] = value
    def getPolygon(self): return self.polygon
    def setPolygon(self, polygon): self.polygon = polygon
    def addPolygon(self, value): self.polygon.append(value)
    def insertPolygon(self, index, value): self.polygon[index] = value
    def getPolyhedron(self): return self.polyhedron
    def setPolyhedron(self, polyhedron): self.polyhedron = polyhedron
    def addPolyhedron(self, value): self.polyhedron.append(value)
    def insertPolyhedron(self, index, value): self.polyhedron[index] = value
    def getSphere(self): return self.sphere
    def setSphere(self, sphere): self.sphere = sphere
    def addSphere(self, value): self.sphere.append(value)
    def insertSphere(self, index, value): self.sphere[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Feature', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Feature')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Feature'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Feature', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for path_ in self.path:
            path_.export(outfile, level, namespace_, name_='path')
        for freePoints_ in self.freePoints:
            freePoints_.export(outfile, level, namespace_, name_='freePoints')
        for manifold_ in self.manifold:
            manifold_.export(outfile, level, namespace_, name_='manifold')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for polyhedron_ in self.polyhedron:
            polyhedron_.export(outfile, level, namespace_, name_='polyhedron')
        for sphere_ in self.sphere:
            sphere_.export(outfile, level, namespace_, name_='sphere')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.path or
            self.freePoints or
            self.manifold or
            self.polygon or
            self.polyhedron or
            self.sphere
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Feature'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('path=[\n')
        level += 1
        for path_ in self.path:
            showIndent(outfile, level)
            outfile.write('model_.Path(\n')
            path_.exportLiteral(outfile, level, name_='Path')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('freePoints=[\n')
        level += 1
        for freePoints_ in self.freePoints:
            showIndent(outfile, level)
            outfile.write('model_.FreePoints(\n')
            freePoints_.exportLiteral(outfile, level, name_='FreePoints')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('manifold=[\n')
        level += 1
        for manifold_ in self.manifold:
            showIndent(outfile, level)
            outfile.write('model_.Manifold(\n')
            manifold_.exportLiteral(outfile, level, name_='Manifold')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.Polygon(\n')
            polygon_.exportLiteral(outfile, level, name_='Polygon')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polyhedron=[\n')
        level += 1
        for polyhedron_ in self.polyhedron:
            showIndent(outfile, level)
            outfile.write('model_.Polyhedron(\n')
            polyhedron_.exportLiteral(outfile, level, name_='Polyhedron')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sphere=[\n')
        level += 1
        for sphere_ in self.sphere:
            showIndent(outfile, level)
            outfile.write('model_.Sphere(\n')
            sphere_.exportLiteral(outfile, level, name_='Sphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'path':
            obj_ = Path.factory()
            obj_.build(child_)
            self.path.append(obj_)
        elif nodeName_ == 'freePoints':
            obj_ = FreePoints.factory()
            obj_.build(child_)
            self.freePoints.append(obj_)
        elif nodeName_ == 'manifold':
            obj_ = Manifold.factory()
            obj_.build(child_)
            self.manifold.append(obj_)
        elif nodeName_ == 'polygon':
            obj_ = Polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'polyhedron':
            obj_ = Polyhedron.factory()
            obj_.build(child_)
            self.polyhedron.append(obj_)
        elif nodeName_ == 'sphere':
            obj_ = Sphere.factory()
            obj_.build(child_)
            self.sphere.append(obj_)
# end class Feature


class Point(GeneratedsSuper):
    """A 3D point with optional diameter. Note: the units for these values
    will be specified in the file in which the element is used, e.g.
    in a MorphML file with <b>length_units="micrometer"</b> in the
    morphml element. Assume micrometer if no other units are given."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None, diameter=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        self.diameter = _cast(float, diameter)
        pass
    def factory(*args_, **kwargs_):
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def getDiameter(self): return self.diameter
    def setDiameter(self, diameter): self.diameter = diameter
    def export(self, outfile, level, namespace_='', name_='Point', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter="%s"' % self.gds_format_double(self.diameter, input_name='diameter'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = %e,\n' % (self.diameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            try:
                self.diameter = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (diameter): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point


class Point3D(GeneratedsSuper):
    """A 3D point with no diameter. Note: the units for these values will
    be specified in the file in which the element is used, e.g. in a
    MorphML file with <b>length_units="micrometer"</b> in the
    morphml element. Assume micrometer if no other units are given."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        pass
    def factory(*args_, **kwargs_):
        if Point3D.subclass:
            return Point3D.subclass(*args_, **kwargs_)
        else:
            return Point3D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='Point3D', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point3D')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point3D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point3D', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point3D'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point3D


class Points(GeneratedsSuper):
    """A collection of points."""
    subclass = None
    superclass = None
    def __init__(self, name=None, point=None, extensiontype_=None):
        self.name = _cast(None, name)
        if point is None:
            self.point = []
        else:
            self.point = point
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Points.subclass:
            return Points.subclass(*args_, **kwargs_)
        else:
            return Points(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPoint(self): return self.point
    def setPoint(self, point): self.point = point
    def addPoint(self, value): self.point.append(value)
    def insertPoint(self, index, value): self.point[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Points', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Points')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Points'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Points', fromsubclass_=False):
        for point_ in self.point:
            point_.export(outfile, level, namespace_, name_='point')
    def hasContent_(self):
        if (
            self.point
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Points'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('point=[\n')
        level += 1
        for point_ in self.point:
            showIndent(outfile, level)
            outfile.write('model_.Point(\n')
            point_.exportLiteral(outfile, level, name_='Point')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = Point.factory()
            obj_.build(child_)
            self.point.append(obj_)
# end class Points


class Sphere(GeneratedsSuper):
    """A spherical structure such as a cell body or cell."""
    subclass = None
    superclass = None
    def __init__(self, name=None, center=None):
        self.name = _cast(None, name)
        self.center = center
    def factory(*args_, **kwargs_):
        if Sphere.subclass:
            return Sphere.subclass(*args_, **kwargs_)
        else:
            return Sphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCenter(self): return self.center
    def setCenter(self, center): self.center = center
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Sphere', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sphere')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sphere'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Sphere', fromsubclass_=False):
        if self.center is not None:
            self.center.export(outfile, level, namespace_, name_='center', )
    def hasContent_(self):
        if (
            self.center is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Sphere'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.center is not None:
            showIndent(outfile, level)
            outfile.write('center=model_.Point(\n')
            self.center.exportLiteral(outfile, level, name_='center')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'center':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setCenter(obj_)
# end class Sphere


class RectangularBox(GeneratedsSuper):
    """A Rectangular Box for locating cells in 3D."""
    subclass = None
    superclass = None
    def __init__(self, name=None, corner=None, size=None):
        self.name = _cast(None, name)
        self.corner = corner
        self.size = size
    def factory(*args_, **kwargs_):
        if RectangularBox.subclass:
            return RectangularBox.subclass(*args_, **kwargs_)
        else:
            return RectangularBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCorner(self): return self.corner
    def setCorner(self, corner): self.corner = corner
    def getSize(self): return self.size
    def setSize(self, size): self.size = size
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='RectangularBox', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RectangularBox')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RectangularBox'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RectangularBox', fromsubclass_=False):
        if self.corner is not None:
            self.corner.export(outfile, level, namespace_, name_='corner', )
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', )
    def hasContent_(self):
        if (
            self.corner is not None or
            self.size is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RectangularBox'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.corner is not None:
            showIndent(outfile, level)
            outfile.write('corner=model_.Point(\n')
            self.corner.exportLiteral(outfile, level, name_='corner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=model_.sizeType(\n')
            self.size.exportLiteral(outfile, level, name_='size')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'corner':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setCorner(obj_)
        elif nodeName_ == 'size':
            obj_ = sizeType.factory()
            obj_.build(child_)
            self.setSize(obj_)
# end class RectangularBox


class NonSpatialGrid(GeneratedsSuper):
    """Specifies a grid of up to 3 dimensions, without any explicit 3D
    location information."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(int, y)
        self.x = _cast(int, x)
        self.z = _cast(int, z)
        pass
    def factory(*args_, **kwargs_):
        if NonSpatialGrid.subclass:
            return NonSpatialGrid.subclass(*args_, **kwargs_)
        else:
            return NonSpatialGrid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='NonSpatialGrid', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonSpatialGrid')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonSpatialGrid'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_integer(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='NonSpatialGrid', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NonSpatialGrid'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %d,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %d,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %d,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.y <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.x <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.z <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NonSpatialGrid


class Manifold(Points):
    """A surface."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(Manifold, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if Manifold.subclass:
            return Manifold.subclass(*args_, **kwargs_)
        else:
            return Manifold(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Manifold', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Manifold')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Manifold'):
        super(Manifold, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Manifold')
    def exportChildren(self, outfile, level, namespace_='', name_='Manifold', fromsubclass_=False):
        super(Manifold, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Manifold, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Manifold'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Manifold, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Manifold, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Manifold, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Manifold, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Manifold


class Polygon(Points):
    """A closed structure represented by a list of points where the first
    point connects with the last point."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(Polygon, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if Polygon.subclass:
            return Polygon.subclass(*args_, **kwargs_)
        else:
            return Polygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Polygon', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Polygon')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Polygon'):
        super(Polygon, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Polygon')
    def exportChildren(self, outfile, level, namespace_='', name_='Polygon', fromsubclass_=False):
        super(Polygon, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Polygon, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Polygon'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Polygon, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Polygon, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Polygon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Polygon, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Polygon


class Polyhedron(GeneratedsSuper):
    """A 3d surface to represent the cell body or histological structure."""
    subclass = None
    superclass = None
    def __init__(self, polygons=None):
        self.polygons = polygons
    def factory(*args_, **kwargs_):
        if Polyhedron.subclass:
            return Polyhedron.subclass(*args_, **kwargs_)
        else:
            return Polyhedron(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPolygons(self): return self.polygons
    def setPolygons(self, polygons): self.polygons = polygons
    def export(self, outfile, level, namespace_='', name_='Polyhedron', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Polyhedron')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Polyhedron'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Polyhedron', fromsubclass_=False):
        if self.polygons is not None:
            self.polygons.export(outfile, level, namespace_, name_='polygons', )
    def hasContent_(self):
        if (
            self.polygons is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Polyhedron'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.polygons is not None:
            showIndent(outfile, level)
            outfile.write('polygons=model_.polygonsType(\n')
            self.polygons.exportLiteral(outfile, level, name_='polygons')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygons':
            obj_ = polygonsType.factory()
            obj_.build(child_)
            self.setPolygons(obj_)
# end class Polyhedron


class Annotation(GeneratedsSuper):
    """Concise processing directives for downstream applications."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='Annotation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Annotation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Annotation', fromsubclass_=False):
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Annotation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Annotation')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class Annotation


class Property(GeneratedsSuper):
    """A Tag/Value/Type tuple. Note prior to v1.7.1, tag and value were sub
    elements. The attribute option is now preferred."""
    subclass = None
    superclass = None
    def __init__(self, value_attr=None, tag_attr=None, tag=None, value=None):
        self.value_attr = _cast(None, value_attr)
        self.tag_attr = _cast(None, tag_attr)
        self.tag = tag
        self.value = value
    def factory(*args_, **kwargs_):
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTag(self): return self.tag
    def setTag(self, tag): self.tag = tag
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def getValue_attr(self): return self.value_attr
    def setValue_attr(self, value_attr): self.value_attr = value_attr
    def getTag_attr(self): return self.tag_attr
    def setTag_attr(self, tag_attr): self.tag_attr = tag_attr
    def export(self, outfile, level, namespace_='', name_='Property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Property'):
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            outfile.write(' value_attr=%s' % (self.gds_format_string(quote_attrib(self.value_attr).encode(ExternalEncoding), input_name='value_attr'), ))
        if self.tag_attr is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            outfile.write(' tag_attr=%s' % (self.gds_format_string(quote_attrib(self.tag_attr).encode(ExternalEncoding), input_name='tag_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Property', fromsubclass_=False):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('<%stag>%s</%stag>\n' % (namespace_, self.gds_format_string(quote_xml(self.tag).encode(ExternalEncoding), input_name='tag'), namespace_))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.tag is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            showIndent(outfile, level)
            outfile.write('value_attr = "%s",\n' % (self.value_attr,))
        if self.tag_attr is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            showIndent(outfile, level)
            outfile.write('tag_attr = "%s",\n' % (self.tag_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('tag=%s,\n' % quote_python(self.tag).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value_attr', node)
        if value is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            self.value_attr = value
        value = find_attr_value_('tag_attr', node)
        if value is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            self.tag_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            tag_ = child_.text
            tag_ = self.gds_validate_string(tag_, node, 'tag')
            self.tag = tag_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class Property


class Properties(GeneratedsSuper):
    """A collection of Properties"""
    subclass = None
    superclass = None
    def __init__(self, property=None):
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if Properties.subclass:
            return Properties.subclass(*args_, **kwargs_)
        else:
            return Properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def addProperty(self, value): self.property.append(value)
    def insertProperty(self, index, value): self.property[index] = value
    def export(self, outfile, level, namespace_='', name_='Properties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Properties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Properties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Properties', fromsubclass_=False):
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Properties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.Property(\n')
            property_.exportLiteral(outfile, level, name_='Property')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = Property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class Properties


class PropertyDetail(GeneratedsSuper):
    """Metadata for each Property."""
    subclass = None
    superclass = None
    def __init__(self, property=None, description=None, type_=None):
        self.property = _cast(None, property)
        self.description = description
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if PropertyDetail.subclass:
            return PropertyDetail.subclass(*args_, **kwargs_)
        else:
            return PropertyDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def export(self, outfile, level, namespace_='', name_='PropertyDetail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyDetail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyDetail'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyDetail', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None or
            self.type_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyDetail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            showIndent(outfile, level)
            outfile.write('property = "%s",\n' % (self.property,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.append('property')
            self.property = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class PropertyDetail


class GroupDetail(GeneratedsSuper):
    """Metadata for each Group."""
    subclass = None
    superclass = None
    def __init__(self, group=None, description=None, properties=None):
        self.group = _cast(None, group)
        self.description = description
        if properties is None:
            self.properties = []
        else:
            self.properties = properties
    def factory(*args_, **kwargs_):
        if GroupDetail.subclass:
            return GroupDetail.subclass(*args_, **kwargs_)
        else:
            return GroupDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def addProperties(self, value): self.properties.append(value)
    def insertProperties(self, index, value): self.properties[index] = value
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def export(self, outfile, level, namespace_='', name_='GroupDetail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupDetail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupDetail'):
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            outfile.write(' group=%s' % (self.gds_format_string(quote_attrib(self.group).encode(ExternalEncoding), input_name='group'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GroupDetail', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        for properties_ in self.properties:
            properties_.export(outfile, level, namespace_, name_='properties')
    def hasContent_(self):
        if (
            self.description is not None or
            self.properties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupDetail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            showIndent(outfile, level)
            outfile.write('group = "%s",\n' % (self.group,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('properties=[\n')
        level += 1
        for properties_ in self.properties:
            showIndent(outfile, level)
            outfile.write('model_.Properties(\n')
            properties_.exportLiteral(outfile, level, name_='Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.append('group')
            self.group = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.properties.append(obj_)
# end class GroupDetail


class NeuroMorphoRef(GeneratedsSuper):
    """A reference to an entity in NeuroMorpho.org Note: This element will
    possibly change when a new set of schema files is adopted for
    adding references, authors, citations, etc. See mailing lists
    for latest status"""
    subclass = None
    superclass = None
    def __init__(self, morphologyRef=None, uri=None, comment=None):
        self.morphologyRef = morphologyRef
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NeuroMorphoRef.subclass:
            return NeuroMorphoRef.subclass(*args_, **kwargs_)
        else:
            return NeuroMorphoRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMorphologyRef(self): return self.morphologyRef
    def setMorphologyRef(self, morphologyRef): self.morphologyRef = morphologyRef
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NeuroMorphoRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuroMorphoRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuroMorphoRef'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NeuroMorphoRef', fromsubclass_=False):
        if self.morphologyRef is not None:
            showIndent(outfile, level)
            outfile.write('<%smorphologyRef>%s</%smorphologyRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.morphologyRef).encode(ExternalEncoding), input_name='morphologyRef'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.morphologyRef is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuroMorphoRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.morphologyRef is not None:
            showIndent(outfile, level)
            outfile.write('morphologyRef=%s,\n' % quote_python(self.morphologyRef).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'morphologyRef':
            morphologyRef_ = child_.text
            morphologyRef_ = self.gds_validate_string(morphologyRef_, node, 'morphologyRef')
            self.morphologyRef = morphologyRef_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NeuroMorphoRef


class NeuronDBReference(GeneratedsSuper):
    """A reference to an entity in NeuronDB Note: This element will
    possibly change when a new set of schema files is adopted for
    adding references, authors, citations, etc. See mailing lists
    for latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelName=None, uri=None, comment=None):
        self.modelName = modelName
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NeuronDBReference.subclass:
            return NeuronDBReference.subclass(*args_, **kwargs_)
        else:
            return NeuronDBReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelName(self): return self.modelName
    def setModelName(self, modelName): self.modelName = modelName
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NeuronDBReference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuronDBReference')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuronDBReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NeuronDBReference', fromsubclass_=False):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('<%smodelName>%s</%smodelName>\n' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.modelName is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuronDBReference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NeuronDBReference


class ModelDBReference(GeneratedsSuper):
    """A reference to an entity in ModelDB Note: This element will possibly
    change when a new set of schema files is adopted for adding
    references, authors, citations, etc. See mailing lists for
    latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelName=None, uri=None, comment=None):
        self.modelName = modelName
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ModelDBReference.subclass:
            return ModelDBReference.subclass(*args_, **kwargs_)
        else:
            return ModelDBReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelName(self): return self.modelName
    def setModelName(self, modelName): self.modelName = modelName
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ModelDBReference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelDBReference')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelDBReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelDBReference', fromsubclass_=False):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('<%smodelName>%s</%smodelName>\n' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.modelName is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ModelDBReference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ModelDBReference


class Publication(GeneratedsSuper):
    """A reference to a publication Note: This element will possibly change
    when a new set of schema files is adopted for adding references,
    authors, citations, etc. See mailing lists for latest status"""
    subclass = None
    superclass = None
    def __init__(self, fullTitle=None, pubmedRef=None, comment=None):
        self.fullTitle = fullTitle
        self.pubmedRef = pubmedRef
        self.comment = comment
    def factory(*args_, **kwargs_):
        if Publication.subclass:
            return Publication.subclass(*args_, **kwargs_)
        else:
            return Publication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFullTitle(self): return self.fullTitle
    def setFullTitle(self, fullTitle): self.fullTitle = fullTitle
    def getPubmedRef(self): return self.pubmedRef
    def setPubmedRef(self, pubmedRef): self.pubmedRef = pubmedRef
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='Publication', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Publication')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Publication'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Publication', fromsubclass_=False):
        if self.fullTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sfullTitle>%s</%sfullTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.fullTitle).encode(ExternalEncoding), input_name='fullTitle'), namespace_))
        if self.pubmedRef is not None:
            showIndent(outfile, level)
            outfile.write('<%spubmedRef>%s</%spubmedRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.pubmedRef).encode(ExternalEncoding), input_name='pubmedRef'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.fullTitle is not None or
            self.pubmedRef is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Publication'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fullTitle is not None:
            showIndent(outfile, level)
            outfile.write('fullTitle=%s,\n' % quote_python(self.fullTitle).encode(ExternalEncoding))
        if self.pubmedRef is not None:
            showIndent(outfile, level)
            outfile.write('pubmedRef=%s,\n' % quote_python(self.pubmedRef).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullTitle':
            fullTitle_ = child_.text
            fullTitle_ = self.gds_validate_string(fullTitle_, node, 'fullTitle')
            self.fullTitle = fullTitle_
        elif nodeName_ == 'pubmedRef':
            pubmedRef_ = child_.text
            pubmedRef_ = self.gds_validate_string(pubmedRef_, node, 'pubmedRef')
            self.pubmedRef = pubmedRef_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class Publication


class Authors(GeneratedsSuper):
    """A reference to an author Note: This element will possibly change
    when a new set of schema files is adopted for adding references,
    authors, citations, etc. See mailing lists for latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelAuthor=None, modelTranslator=None):
        if modelAuthor is None:
            self.modelAuthor = []
        else:
            self.modelAuthor = modelAuthor
        if modelTranslator is None:
            self.modelTranslator = []
        else:
            self.modelTranslator = modelTranslator
    def factory(*args_, **kwargs_):
        if Authors.subclass:
            return Authors.subclass(*args_, **kwargs_)
        else:
            return Authors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelAuthor(self): return self.modelAuthor
    def setModelAuthor(self, modelAuthor): self.modelAuthor = modelAuthor
    def addModelAuthor(self, value): self.modelAuthor.append(value)
    def insertModelAuthor(self, index, value): self.modelAuthor[index] = value
    def getModelTranslator(self): return self.modelTranslator
    def setModelTranslator(self, modelTranslator): self.modelTranslator = modelTranslator
    def addModelTranslator(self, value): self.modelTranslator.append(value)
    def insertModelTranslator(self, index, value): self.modelTranslator[index] = value
    def export(self, outfile, level, namespace_='', name_='Authors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Authors')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Authors'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Authors', fromsubclass_=False):
        for modelAuthor_ in self.modelAuthor:
            modelAuthor_.export(outfile, level, namespace_, name_='modelAuthor')
        for modelTranslator_ in self.modelTranslator:
            modelTranslator_.export(outfile, level, namespace_, name_='modelTranslator')
    def hasContent_(self):
        if (
            self.modelAuthor or
            self.modelTranslator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Authors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('modelAuthor=[\n')
        level += 1
        for modelAuthor_ in self.modelAuthor:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            modelAuthor_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelTranslator=[\n')
        level += 1
        for modelTranslator_ in self.modelTranslator:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            modelTranslator_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelAuthor':
            obj_ = Person.factory()
            obj_.build(child_)
            self.modelAuthor.append(obj_)
        elif nodeName_ == 'modelTranslator':
            obj_ = Person.factory()
            obj_.build(child_)
            self.modelTranslator.append(obj_)
# end class Authors


class Person(GeneratedsSuper):
    """A generic reference to a person, for authorship, etc"""
    subclass = None
    superclass = None
    def __init__(self, name=None, institution=None, email=None, comment=None):
        self.name = name
        self.institution = institution
        self.email = email
        self.comment = comment
    def factory(*args_, **kwargs_):
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getInstitution(self): return self.institution
    def setInstitution(self, institution): self.institution = institution
    def getEmail(self): return self.email
    def setEmail(self, email): self.email = email
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='Person', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Person')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Person'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Person', fromsubclass_=False):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstitution>%s</%sinstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.institution).encode(ExternalEncoding), input_name='institution'), namespace_))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('<%semail>%s</%semail>\n' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.institution is not None or
            self.email is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Person'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('institution=%s,\n' % quote_python(self.institution).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'institution':
            institution_ = child_.text
            institution_ = self.gds_validate_string(institution_, node, 'institution')
            self.institution = institution_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class Person


class Status(GeneratedsSuper):
    """Status element giving the stability state of files and some extra
    comments.Currently an enum value of status/in progress/etc."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, issue=None, contributor=None):
        self.value = _cast(None, value)
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        if issue is None:
            self.issue = []
        else:
            self.issue = issue
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
    def factory(*args_, **kwargs_):
        if Status.subclass:
            return Status.subclass(*args_, **kwargs_)
        else:
            return Status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def addComment(self, value): self.comment.append(value)
    def insertComment(self, index, value): self.comment[index] = value
    def getIssue(self): return self.issue
    def setIssue(self, issue): self.issue = issue
    def addIssue(self, value): self.issue.append(value)
    def insertIssue(self, index, value): self.issue[index] = value
    def getContributor(self): return self.contributor
    def setContributor(self, contributor): self.contributor = contributor
    def addContributor(self, value): self.contributor.append(value)
    def insertContributor(self, index, value): self.contributor[index] = value
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def validate_StatusValue(self, value):
        # Validate type StatusValue, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Status', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Status')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Status'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Status', fromsubclass_=False):
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(comment_).encode(ExternalEncoding), input_name='comment'), namespace_))
        for issue_ in self.issue:
            showIndent(outfile, level)
            outfile.write('<%sissue>%s</%sissue>\n' % (namespace_, self.gds_format_string(quote_xml(issue_).encode(ExternalEncoding), input_name='issue'), namespace_))
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
    def hasContent_(self):
        if (
            self.comment or
            self.issue or
            self.contributor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('issue=[\n')
        level += 1
        for issue_ in self.issue:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(issue_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            contributor_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
            self.validate_StatusValue(self.value)    # validate type StatusValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment.append(comment_)
        elif nodeName_ == 'issue':
            issue_ = child_.text
            issue_ = self.gds_validate_string(issue_, node, 'issue')
            self.issue.append(issue_)
        elif nodeName_ == 'contributor':
            obj_ = Person.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
# end class Status


class cellsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cell=None):
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if cellsType.subclass:
            return cellsType.subclass(*args_, **kwargs_)
        else:
            return cellsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCell(self): return self.cell
    def setCell(self, cell): self.cell = cell
    def addCell(self, value): self.cell.append(value)
    def insertCell(self, index, value): self.cell[index] = value
    def export(self, outfile, level, namespace_='', name_='cellsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cellsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cellsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cellsType', fromsubclass_=False):
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cellsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.Cell(\n')
            cell_.exportLiteral(outfile, level, name_='Cell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cell':
            obj_ = Cell.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class cellsType


class featuresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, notes=None, properties=None, annotation=None, group=None, feature=None):
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        if feature is None:
            self.feature = []
        else:
            self.feature = feature
    def factory(*args_, **kwargs_):
        if featuresType.subclass:
            return featuresType.subclass(*args_, **kwargs_)
        else:
            return featuresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getFeature(self): return self.feature
    def setFeature(self, feature): self.feature = feature
    def addFeature(self, value): self.feature.append(value)
    def insertFeature(self, index, value): self.feature[index] = value
    def export(self, outfile, level, namespace_='', name_='featuresType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='featuresType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='featuresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='featuresType', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for feature_ in self.feature:
            feature_.export(outfile, level, namespace_, name_='feature')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.feature
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='featuresType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('feature=[\n')
        level += 1
        for feature_ in self.feature:
            showIndent(outfile, level)
            outfile.write('model_.Feature(\n')
            feature_.exportLiteral(outfile, level, name_='Feature')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'feature':
            obj_ = Feature.factory()
            obj_.build(child_)
            self.feature.append(obj_)
# end class featuresType


class propertyDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, propertyDetail=None):
        if propertyDetail is None:
            self.propertyDetail = []
        else:
            self.propertyDetail = propertyDetail
    def factory(*args_, **kwargs_):
        if propertyDetailsType.subclass:
            return propertyDetailsType.subclass(*args_, **kwargs_)
        else:
            return propertyDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPropertyDetail(self): return self.propertyDetail
    def setPropertyDetail(self, propertyDetail): self.propertyDetail = propertyDetail
    def addPropertyDetail(self, value): self.propertyDetail.append(value)
    def insertPropertyDetail(self, index, value): self.propertyDetail[index] = value
    def export(self, outfile, level, namespace_='', name_='propertyDetailsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyDetailsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='propertyDetailsType', fromsubclass_=False):
        for propertyDetail_ in self.propertyDetail:
            propertyDetail_.export(outfile, level, namespace_, name_='propertyDetail')
    def hasContent_(self):
        if (
            self.propertyDetail
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='propertyDetailsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('propertyDetail=[\n')
        level += 1
        for propertyDetail_ in self.propertyDetail:
            showIndent(outfile, level)
            outfile.write('model_.PropertyDetail(\n')
            propertyDetail_.exportLiteral(outfile, level, name_='PropertyDetail')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'propertyDetail':
            obj_ = PropertyDetail.factory()
            obj_.build(child_)
            self.propertyDetail.append(obj_)
# end class propertyDetailsType


class groupDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, groupDetail=None):
        if groupDetail is None:
            self.groupDetail = []
        else:
            self.groupDetail = groupDetail
    def factory(*args_, **kwargs_):
        if groupDetailsType.subclass:
            return groupDetailsType.subclass(*args_, **kwargs_)
        else:
            return groupDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGroupDetail(self): return self.groupDetail
    def setGroupDetail(self, groupDetail): self.groupDetail = groupDetail
    def addGroupDetail(self, value): self.groupDetail.append(value)
    def insertGroupDetail(self, index, value): self.groupDetail[index] = value
    def export(self, outfile, level, namespace_='', name_='groupDetailsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupDetailsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='groupDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='groupDetailsType', fromsubclass_=False):
        for groupDetail_ in self.groupDetail:
            groupDetail_.export(outfile, level, namespace_, name_='groupDetail')
    def hasContent_(self):
        if (
            self.groupDetail
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='groupDetailsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('groupDetail=[\n')
        level += 1
        for groupDetail_ in self.groupDetail:
            showIndent(outfile, level)
            outfile.write('model_.GroupDetail(\n')
            groupDetail_.exportLiteral(outfile, level, name_='GroupDetail')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'groupDetail':
            obj_ = GroupDetail.factory()
            obj_.build(child_)
            self.groupDetail.append(obj_)
# end class groupDetailsType


class segmentsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, notes=None, properties=None, annotation=None, group=None, segment=None):
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if segmentsType.subclass:
            return segmentsType.subclass(*args_, **kwargs_)
        else:
            return segmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def addSegment(self, value): self.segment.append(value)
    def insertSegment(self, index, value): self.segment[index] = value
    def export(self, outfile, level, namespace_='', name_='segmentsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segmentsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='segmentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='segmentsType', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.segment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='segmentsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment_ in self.segment:
            showIndent(outfile, level)
            outfile.write('model_.Segment(\n')
            segment_.exportLiteral(outfile, level, name_='Segment')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'segment':
            obj_ = Segment.factory()
            obj_.build(child_)
            self.segment.append(obj_)
# end class segmentsType


class cablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, notes=None, properties=None, annotation=None, group=None, cable=None, cablegroup=None):
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        if cable is None:
            self.cable = []
        else:
            self.cable = cable
        if cablegroup is None:
            self.cablegroup = []
        else:
            self.cablegroup = cablegroup
    def factory(*args_, **kwargs_):
        if cablesType.subclass:
            return cablesType.subclass(*args_, **kwargs_)
        else:
            return cablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getCable(self): return self.cable
    def setCable(self, cable): self.cable = cable
    def addCable(self, value): self.cable.append(value)
    def insertCable(self, index, value): self.cable[index] = value
    def getCablegroup(self): return self.cablegroup
    def setCablegroup(self, cablegroup): self.cablegroup = cablegroup
    def addCablegroup(self, value): self.cablegroup.append(value)
    def insertCablegroup(self, index, value): self.cablegroup[index] = value
    def export(self, outfile, level, namespace_='', name_='cablesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cablesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cablesType', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for cable_ in self.cable:
            cable_.export(outfile, level, namespace_, name_='cable')
        for cablegroup_ in self.cablegroup:
            cablegroup_.export(outfile, level, namespace_, name_='cablegroup')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.cable or
            self.cablegroup
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cablesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cable=[\n')
        level += 1
        for cable_ in self.cable:
            showIndent(outfile, level)
            outfile.write('model_.Cable(\n')
            cable_.exportLiteral(outfile, level, name_='Cable')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cablegroup=[\n')
        level += 1
        for cablegroup_ in self.cablegroup:
            showIndent(outfile, level)
            outfile.write('model_.CableGroup(\n')
            cablegroup_.exportLiteral(outfile, level, name_='CableGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'cable':
            obj_ = Cable.factory()
            obj_.build(child_)
            self.cable.append(obj_)
        elif nodeName_ == 'cablegroup':
            obj_ = CableGroup.factory()
            obj_.build(child_)
            self.cablegroup.append(obj_)
# end class cablesType


class cellBodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, notes=None, properties=None, annotation=None, group=None, polygon=None, polyhedron=None, sphere=None):
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.polygon = polygon
        self.polyhedron = polyhedron
        self.sphere = sphere
    def factory(*args_, **kwargs_):
        if cellBodyType.subclass:
            return cellBodyType.subclass(*args_, **kwargs_)
        else:
            return cellBodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getPolygon(self): return self.polygon
    def setPolygon(self, polygon): self.polygon = polygon
    def getPolyhedron(self): return self.polyhedron
    def setPolyhedron(self, polyhedron): self.polyhedron = polyhedron
    def getSphere(self): return self.sphere
    def setSphere(self, sphere): self.sphere = sphere
    def export(self, outfile, level, namespace_='', name_='cellBodyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cellBodyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cellBodyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cellBodyType', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.polygon is not None:
            self.polygon.export(outfile, level, namespace_, name_='polygon', )
        if self.polyhedron is not None:
            self.polyhedron.export(outfile, level, namespace_, name_='polyhedron', )
        if self.sphere is not None:
            self.sphere.export(outfile, level, namespace_, name_='sphere', )
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.polygon is not None or
            self.polyhedron is not None or
            self.sphere is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cellBodyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.polygon is not None:
            showIndent(outfile, level)
            outfile.write('polygon=model_.Polygon(\n')
            self.polygon.exportLiteral(outfile, level, name_='polygon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.polyhedron is not None:
            showIndent(outfile, level)
            outfile.write('polyhedron=model_.Polyhedron(\n')
            self.polyhedron.exportLiteral(outfile, level, name_='polyhedron')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sphere is not None:
            showIndent(outfile, level)
            outfile.write('sphere=model_.Sphere(\n')
            self.sphere.exportLiteral(outfile, level, name_='sphere')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'polygon':
            obj_ = Polygon.factory()
            obj_.build(child_)
            self.setPolygon(obj_)
        elif nodeName_ == 'polyhedron':
            obj_ = Polyhedron.factory()
            obj_.build(child_)
            self.setPolyhedron(obj_)
        elif nodeName_ == 'sphere':
            obj_ = Sphere.factory()
            obj_.build(child_)
            self.setSphere(obj_)
# end class cellBodyType


class spinesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, notes=None, properties=None, annotation=None, group=None, spine=None):
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        if spine is None:
            self.spine = []
        else:
            self.spine = spine
    def factory(*args_, **kwargs_):
        if spinesType.subclass:
            return spinesType.subclass(*args_, **kwargs_)
        else:
            return spinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getSpine(self): return self.spine
    def setSpine(self, spine): self.spine = spine
    def addSpine(self, value): self.spine.append(value)
    def insertSpine(self, index, value): self.spine[index] = value
    def export(self, outfile, level, namespace_='', name_='spinesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='spinesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='spinesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='spinesType', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for spine_ in self.spine:
            spine_.export(outfile, level, namespace_, name_='spine')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.spine
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='spinesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spine=[\n')
        level += 1
        for spine_ in self.spine:
            showIndent(outfile, level)
            outfile.write('model_.Spine(\n')
            spine_.exportLiteral(outfile, level, name_='Spine')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'spine':
            obj_ = Spine.factory()
            obj_.build(child_)
            self.spine.append(obj_)
# end class spinesType


class cableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None):
        self.id = _cast(int, id)
        pass
    def factory(*args_, **kwargs_):
        if cableType.subclass:
            return cableType.subclass(*args_, **kwargs_)
        else:
            return cableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='cableType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cableType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cableType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='cableType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cableType


class proximalType(GeneratedsSuper):
    """The variable is translated to this value at the proximal point"""
    subclass = None
    superclass = None
    def __init__(self, translationStart=None):
        self.translationStart = _cast(float, translationStart)
        pass
    def factory(*args_, **kwargs_):
        if proximalType.subclass:
            return proximalType.subclass(*args_, **kwargs_)
        else:
            return proximalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTranslationStart(self): return self.translationStart
    def setTranslationStart(self, translationStart): self.translationStart = translationStart
    def export(self, outfile, level, namespace_='', name_='proximalType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='proximalType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='proximalType'):
        if self.translationStart is not None and 'translationStart' not in already_processed:
            already_processed.append('translationStart')
            outfile.write(' translationStart="%s"' % self.gds_format_double(self.translationStart, input_name='translationStart'))
    def exportChildren(self, outfile, level, namespace_='', name_='proximalType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='proximalType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.translationStart is not None and 'translationStart' not in already_processed:
            already_processed.append('translationStart')
            showIndent(outfile, level)
            outfile.write('translationStart = %e,\n' % (self.translationStart,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('translationStart', node)
        if value is not None and 'translationStart' not in already_processed:
            already_processed.append('translationStart')
            try:
                self.translationStart = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (translationStart): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class proximalType


class distalType(GeneratedsSuper):
    """The variable is normalised so that it has this value at the distal
    point"""
    subclass = None
    superclass = None
    def __init__(self, normalizationEnd=None):
        self.normalizationEnd = _cast(float, normalizationEnd)
        pass
    def factory(*args_, **kwargs_):
        if distalType.subclass:
            return distalType.subclass(*args_, **kwargs_)
        else:
            return distalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNormalizationEnd(self): return self.normalizationEnd
    def setNormalizationEnd(self, normalizationEnd): self.normalizationEnd = normalizationEnd
    def export(self, outfile, level, namespace_='', name_='distalType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='distalType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='distalType'):
        if self.normalizationEnd is not None and 'normalizationEnd' not in already_processed:
            already_processed.append('normalizationEnd')
            outfile.write(' normalizationEnd="%s"' % self.gds_format_double(self.normalizationEnd, input_name='normalizationEnd'))
    def exportChildren(self, outfile, level, namespace_='', name_='distalType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='distalType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.normalizationEnd is not None and 'normalizationEnd' not in already_processed:
            already_processed.append('normalizationEnd')
            showIndent(outfile, level)
            outfile.write('normalizationEnd = %e,\n' % (self.normalizationEnd,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('normalizationEnd', node)
        if value is not None and 'normalizationEnd' not in already_processed:
            already_processed.append('normalizationEnd')
            try:
                self.normalizationEnd = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (normalizationEnd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class distalType


class sizeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, depth=None, height=None):
        self.width = _cast(float, width)
        self.depth = _cast(float, depth)
        self.height = _cast(float, height)
        pass
    def factory(*args_, **kwargs_):
        if sizeType.subclass:
            return sizeType.subclass(*args_, **kwargs_)
        else:
            return sizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWidth(self): return self.width
    def setWidth(self, width): self.width = width
    def getDepth(self): return self.depth
    def setDepth(self, depth): self.depth = depth
    def getHeight(self): return self.height
    def setHeight(self, height): self.height = height
    def export(self, outfile, level, namespace_='', name_='sizeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sizeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sizeType'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            outfile.write(' depth="%s"' % self.gds_format_double(self.depth, input_name='depth'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='sizeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sizeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = %e,\n' % (self.width,))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            showIndent(outfile, level)
            outfile.write('depth = %e,\n' % (self.depth,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            showIndent(outfile, level)
            outfile.write('height = %e,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            try:
                self.width = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
        value = find_attr_value_('depth', node)
        if value is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            try:
                self.depth = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (depth): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.append('height')
            try:
                self.height = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sizeType


class polygonsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polygon=None):
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
    def factory(*args_, **kwargs_):
        if polygonsType.subclass:
            return polygonsType.subclass(*args_, **kwargs_)
        else:
            return polygonsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPolygon(self): return self.polygon
    def setPolygon(self, polygon): self.polygon = polygon
    def addPolygon(self, value): self.polygon.append(value)
    def insertPolygon(self, index, value): self.polygon[index] = value
    def export(self, outfile, level, namespace_='', name_='polygonsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polygonsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polygonsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polygonsType', fromsubclass_=False):
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
    def hasContent_(self):
        if (
            self.polygon
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polygonsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.Polygon(\n')
            polygon_.exportLiteral(outfile, level, name_='Polygon')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = Polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
# end class polygonsType


class Path(Points):
    """Possibly branching histological structures.A path id. A way to
    connect this path to another."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None, id=None, parent=None):
        super(Path, self).__init__(name, point, )
        self.id = _cast(int, id)
        self.parent = _cast(int, parent)
        pass
    def factory(*args_, **kwargs_):
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def getParent(self): return self.parent
    def setParent(self, parent): self.parent = parent
    def export(self, outfile, level, namespace_='', name_='Path', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Path')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Path'):
        super(Path, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Path')
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            outfile.write(' parent="%s"' % self.gds_format_integer(self.parent, input_name='parent'))
    def exportChildren(self, outfile, level, namespace_='', name_='Path', fromsubclass_=False):
        super(Path, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Path, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Path'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            showIndent(outfile, level)
            outfile.write('parent = %d,\n' % (self.parent,))
        super(Path, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Path, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            try:
                self.parent = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.parent < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(Path, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Path, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Path


class FreePoints(Points):
    """A set of varicosities or synaptic connections."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(FreePoints, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if FreePoints.subclass:
            return FreePoints.subclass(*args_, **kwargs_)
        else:
            return FreePoints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='FreePoints', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreePoints')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreePoints'):
        super(FreePoints, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FreePoints')
    def exportChildren(self, outfile, level, namespace_='', name_='FreePoints', fromsubclass_=False):
        super(FreePoints, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(FreePoints, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreePoints'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FreePoints, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FreePoints, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(FreePoints, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FreePoints, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FreePoints


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'NeuroMLLevel1'
        rootClass = NeuroMLLevel1
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='xmlns:neuroml="http://morphml.org/neuroml/schema"')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'NeuroMLLevel1'
        rootClass = NeuroMLLevel1
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="NeuroMLLevel1",
##         namespacedef_='xmlns:neuroml="http://morphml.org/neuroml/schema"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'NeuroMLLevel1'
        rootClass = NeuroMLLevel1
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from level1 import *\n\n')
##     sys.stdout.write('import level1 as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Annotation",
    "Authors",
    "Cable",
    "CableGroup",
    "Cell",
    "Cells",
    "Feature",
    "FreePoints",
    "GroupDetail",
    "InhomogeneousParam",
    "Manifold",
    "ModelDBReference",
    "Morphology",
    "NeuroMLLevel1",
    "NeuroMorphoRef",
    "NeuronDBReference",
    "NonSpatialGrid",
    "Path",
    "Person",
    "Point",
    "Point3D",
    "Points",
    "Polygon",
    "Polyhedron",
    "Properties",
    "Property",
    "PropertyDetail",
    "Publication",
    "RectangularBox",
    "Segment",
    "Sphere",
    "Spine",
    "Status",
    "cableType",
    "cablesType",
    "cellBodyType",
    "cellsType",
    "distalType",
    "featuresType",
    "groupDetailsType",
    "polygonsType",
    "propertyDetailsType",
    "proximalType",
    "segmentsType",
    "sizeType",
    "spinesType"
    ]
