#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Feb  1 19:21:10 2012 by generateDS.py version 2.7b_pg.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class ChannelML(GeneratedsSuper):
    """Root element containing the ions used in the mechanism, the unit
    system of the file (as attribute), and information on channels
    and/or ion concentration dynamics. Normally only the ion element
    and one of channel_type, synapse_type or ion_concentration
    should be present.Unit system of all quantities. Only SI or
    Physiological units are allowed!"""
    subclass = None
    superclass = None
    def __init__(self, units=None, notes=None, properties=None, annotation=None, group=None, ion=None, channel_type=None, synapse_type=None, ion_concentration=None):
        self.units = _cast(None, units)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        if ion is None:
            self.ion = []
        else:
            self.ion = ion
        if channel_type is None:
            self.channel_type = []
        else:
            self.channel_type = channel_type
        if synapse_type is None:
            self.synapse_type = []
        else:
            self.synapse_type = synapse_type
        if ion_concentration is None:
            self.ion_concentration = []
        else:
            self.ion_concentration = ion_concentration
    def factory(*args_, **kwargs_):
        if ChannelML.subclass:
            return ChannelML.subclass(*args_, **kwargs_)
        else:
            return ChannelML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def addIon(self, value): self.ion.append(value)
    def insertIon(self, index, value): self.ion[index] = value
    def getChannelType(self): return self.channel_type
    def setChannelType(self, channel_type): self.channel_type = channel_type
    def addChannelType(self, value): self.channel_type.append(value)
    def insertChannelType(self, index, value): self.channel_type[index] = value
    def getSynapseType(self): return self.synapse_type
    def setSynapseType(self, synapse_type): self.synapse_type = synapse_type
    def addSynapseType(self, value): self.synapse_type.append(value)
    def insertSynapseType(self, index, value): self.synapse_type[index] = value
    def getIonConcentration(self): return self.ion_concentration
    def setIonConcentration(self, ion_concentration): self.ion_concentration = ion_concentration
    def addIonConcentration(self, value): self.ion_concentration.append(value)
    def insertIonConcentration(self, index, value): self.ion_concentration[index] = value
    def getUnits(self): return self.units
    def setUnits(self, units): self.units = units
    def export(self, outfile, level, namespace_='', name_='ChannelML', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelML')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelML'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelML', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for ion_ in self.ion:
            ion_.export(outfile, level, namespace_, name_='ion')
        for channel_type_ in self.channel_type:
            channel_type_.export(outfile, level, namespace_, name_='channel_type')
        for synapse_type_ in self.synapse_type:
            synapse_type_.export(outfile, level, namespace_, name_='synapse_type')
        for ion_concentration_ in self.ion_concentration:
            ion_concentration_.export(outfile, level, namespace_, name_='ion_concentration')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.ion or
            self.channel_type or
            self.synapse_type or
            self.ion_concentration
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChannelML'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = %s,\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ion=[\n')
        level += 1
        for ion_ in self.ion:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_Ion(\n')
            ion_.exportLiteral(outfile, level, name_='Deprecated_Ion')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('channel_type=[\n')
        level += 1
        for channel_type_ in self.channel_type:
            showIndent(outfile, level)
            outfile.write('model_.ChannelType(\n')
            channel_type_.exportLiteral(outfile, level, name_='ChannelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('synapse_type=[\n')
        level += 1
        for synapse_type_ in self.synapse_type:
            showIndent(outfile, level)
            outfile.write('model_.SynapseType(\n')
            synapse_type_.exportLiteral(outfile, level, name_='SynapseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ion_concentration=[\n')
        level += 1
        for ion_concentration_ in self.ion_concentration:
            showIndent(outfile, level)
            outfile.write('model_.IonConcentration(\n')
            ion_concentration_.exportLiteral(outfile, level, name_='IonConcentration')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'ion':
            obj_ = Deprecated_Ion.factory()
            obj_.build(child_)
            self.ion.append(obj_)
        elif nodeName_ == 'channel_type':
            obj_ = ChannelType.factory()
            obj_.build(child_)
            self.channel_type.append(obj_)
        elif nodeName_ == 'synapse_type':
            obj_ = SynapseType.factory()
            obj_.build(child_)
            self.synapse_type.append(obj_)
        elif nodeName_ == 'ion_concentration':
            obj_ = IonConcentration.factory()
            obj_.build(child_)
            self.ion_concentration.append(obj_)
# end class ChannelML


class Parameters(GeneratedsSuper):
    """Fixed value parameters which can be used in generic expressions"""
    subclass = None
    superclass = None
    def __init__(self, parameter=None):
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if Parameters.subclass:
            return Parameters.subclass(*args_, **kwargs_)
        else:
            return Parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def export(self, outfile, level, namespace_='', name_='Parameters', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parameters')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Parameters', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
    def hasContent_(self):
        if (
            self.parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Parameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.Parameter(\n')
            parameter_.exportLiteral(outfile, level, name_='Parameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = Parameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
# end class Parameters


class Parameter(GeneratedsSuper):
    """A single parameter which can be used in generic expressionsA unique
    name for the parameterThe default value for the parameter"""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(float, value)
        pass
    def factory(*args_, **kwargs_):
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='Parameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='Parameter', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Parameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Parameter


class ChannelType(GeneratedsSuper):
    """Definition of a voltage/concentration dependent cell membrane
    conductanceA unique name for the channel mechanismIs this a
    specification of conductance per unit area? Note: almost all
    channel mechanisms to far have been density mechanisms. This
    attribute is subject to change when use of ChannelML for single
    channel conductances is supported."""
    subclass = None
    superclass = None
    def __init__(self, name=None, density='yes', status=None, notes=None, properties=None, annotation=None, group=None, authorList=None, publication=None, neuronDBref=None, modelDBref=None, neuroMorphoRef=None, parameters=None, current_voltage_relation=None, hh_gate=None, ks_gate=None, impl_prefs=None):
        self.name = _cast(None, name)
        self.density = _cast(None, density)
        self.status = status
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.authorList = authorList
        if publication is None:
            self.publication = []
        else:
            self.publication = publication
        if neuronDBref is None:
            self.neuronDBref = []
        else:
            self.neuronDBref = neuronDBref
        if modelDBref is None:
            self.modelDBref = []
        else:
            self.modelDBref = modelDBref
        if neuroMorphoRef is None:
            self.neuroMorphoRef = []
        else:
            self.neuroMorphoRef = neuroMorphoRef
        self.parameters = parameters
        self.current_voltage_relation = current_voltage_relation
        if hh_gate is None:
            self.hh_gate = []
        else:
            self.hh_gate = hh_gate
        if ks_gate is None:
            self.ks_gate = []
        else:
            self.ks_gate = ks_gate
        self.impl_prefs = impl_prefs
    def factory(*args_, **kwargs_):
        if ChannelType.subclass:
            return ChannelType.subclass(*args_, **kwargs_)
        else:
            return ChannelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getAuthorList(self): return self.authorList
    def setAuthorList(self, authorList): self.authorList = authorList
    def getPublication(self): return self.publication
    def setPublication(self, publication): self.publication = publication
    def addPublication(self, value): self.publication.append(value)
    def insertPublication(self, index, value): self.publication[index] = value
    def getNeuronDBref(self): return self.neuronDBref
    def setNeuronDBref(self, neuronDBref): self.neuronDBref = neuronDBref
    def addNeuronDBref(self, value): self.neuronDBref.append(value)
    def insertNeuronDBref(self, index, value): self.neuronDBref[index] = value
    def getModelDBref(self): return self.modelDBref
    def setModelDBref(self, modelDBref): self.modelDBref = modelDBref
    def addModelDBref(self, value): self.modelDBref.append(value)
    def insertModelDBref(self, index, value): self.modelDBref[index] = value
    def getNeuroMorphoRef(self): return self.neuroMorphoRef
    def setNeuroMorphoRef(self, neuroMorphoRef): self.neuroMorphoRef = neuroMorphoRef
    def addNeuroMorphoRef(self, value): self.neuroMorphoRef.append(value)
    def insertNeuroMorphoRef(self, index, value): self.neuroMorphoRef[index] = value
    def getParameters(self): return self.parameters
    def setParameters(self, parameters): self.parameters = parameters
    def getCurrentVoltageRelation(self): return self.current_voltage_relation
    def setCurrentVoltageRelation(self, current_voltage_relation): self.current_voltage_relation = current_voltage_relation
    def getHh_gate(self): return self.hh_gate
    def setHh_gate(self, hh_gate): self.hh_gate = hh_gate
    def addHh_gate(self, value): self.hh_gate.append(value)
    def insertHh_gate(self, index, value): self.hh_gate[index] = value
    def getKs_gate(self): return self.ks_gate
    def setKs_gate(self, ks_gate): self.ks_gate = ks_gate
    def addKs_gate(self, value): self.ks_gate.append(value)
    def insertKs_gate(self, index, value): self.ks_gate[index] = value
    def getImpl_prefs(self): return self.impl_prefs
    def setImpl_prefs(self, impl_prefs): self.impl_prefs = impl_prefs
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDensity(self): return self.density
    def setDensity(self, density): self.density = density
    def export(self, outfile, level, namespace_='', name_='ChannelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.density is not None and 'density' not in already_processed:
            already_processed.append('density')
            outfile.write(' density=%s' % (quote_attrib(self.density), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelType', fromsubclass_=False):
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.authorList is not None:
            self.authorList.export(outfile, level, namespace_, name_='authorList')
        for publication_ in self.publication:
            publication_.export(outfile, level, namespace_, name_='publication')
        for neuronDBref_ in self.neuronDBref:
            neuronDBref_.export(outfile, level, namespace_, name_='neuronDBref')
        for modelDBref_ in self.modelDBref:
            modelDBref_.export(outfile, level, namespace_, name_='modelDBref')
        for neuroMorphoRef_ in self.neuroMorphoRef:
            neuroMorphoRef_.export(outfile, level, namespace_, name_='neuroMorphoRef')
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_, name_='parameters')
        if self.current_voltage_relation is not None:
            self.current_voltage_relation.export(outfile, level, namespace_, name_='current_voltage_relation', )
        for hh_gate_ in self.hh_gate:
            hh_gate_.export(outfile, level, namespace_, name_='hh_gate')
        for ks_gate_ in self.ks_gate:
            ks_gate_.export(outfile, level, namespace_, name_='ks_gate')
        if self.impl_prefs is not None:
            self.impl_prefs.export(outfile, level, namespace_, name_='impl_prefs')
    def hasContent_(self):
        if (
            self.status is not None or
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.authorList is not None or
            self.publication or
            self.neuronDBref or
            self.modelDBref or
            self.neuroMorphoRef or
            self.parameters is not None or
            self.current_voltage_relation is not None or
            self.hh_gate or
            self.ks_gate or
            self.impl_prefs is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChannelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.density is not None and 'density' not in already_processed:
            already_processed.append('density')
            showIndent(outfile, level)
            outfile.write('density = %s,\n' % (self.density,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.Status(\n')
            self.status.exportLiteral(outfile, level, name_='status')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.authorList is not None:
            showIndent(outfile, level)
            outfile.write('authorList=model_.Authors(\n')
            self.authorList.exportLiteral(outfile, level, name_='authorList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('publication=[\n')
        level += 1
        for publication_ in self.publication:
            showIndent(outfile, level)
            outfile.write('model_.Publication(\n')
            publication_.exportLiteral(outfile, level, name_='Publication')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuronDBref=[\n')
        level += 1
        for neuronDBref_ in self.neuronDBref:
            showIndent(outfile, level)
            outfile.write('model_.NeuronDBReference(\n')
            neuronDBref_.exportLiteral(outfile, level, name_='NeuronDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelDBref=[\n')
        level += 1
        for modelDBref_ in self.modelDBref:
            showIndent(outfile, level)
            outfile.write('model_.ModelDBReference(\n')
            modelDBref_.exportLiteral(outfile, level, name_='ModelDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuroMorphoRef=[\n')
        level += 1
        for neuroMorphoRef_ in self.neuroMorphoRef:
            showIndent(outfile, level)
            outfile.write('model_.NeuroMorphoRef(\n')
            neuroMorphoRef_.exportLiteral(outfile, level, name_='NeuroMorphoRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.parameters is not None:
            showIndent(outfile, level)
            outfile.write('parameters=model_.Parameters(\n')
            self.parameters.exportLiteral(outfile, level, name_='parameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_voltage_relation is not None:
            showIndent(outfile, level)
            outfile.write('current_voltage_relation=model_.CurrentVoltageRelation(\n')
            self.current_voltage_relation.exportLiteral(outfile, level, name_='current_voltage_relation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('hh_gate=[\n')
        level += 1
        for hh_gate_ in self.hh_gate:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_HHGate(\n')
            hh_gate_.exportLiteral(outfile, level, name_='Deprecated_HHGate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ks_gate=[\n')
        level += 1
        for ks_gate_ in self.ks_gate:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_KSGate(\n')
            ks_gate_.exportLiteral(outfile, level, name_='Deprecated_KSGate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.impl_prefs is not None:
            showIndent(outfile, level)
            outfile.write('impl_prefs=model_.ImplementationPrefs(\n')
            self.impl_prefs.exportLiteral(outfile, level, name_='impl_prefs')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('density', node)
        if value is not None and 'density' not in already_processed:
            already_processed.append('density')
            self.density = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = Status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'authorList':
            obj_ = Authors.factory()
            obj_.build(child_)
            self.setAuthorList(obj_)
        elif nodeName_ == 'publication':
            obj_ = Publication.factory()
            obj_.build(child_)
            self.publication.append(obj_)
        elif nodeName_ == 'neuronDBref':
            obj_ = NeuronDBReference.factory()
            obj_.build(child_)
            self.neuronDBref.append(obj_)
        elif nodeName_ == 'modelDBref':
            obj_ = ModelDBReference.factory()
            obj_.build(child_)
            self.modelDBref.append(obj_)
        elif nodeName_ == 'neuroMorphoRef':
            obj_ = NeuroMorphoRef.factory()
            obj_.build(child_)
            self.neuroMorphoRef.append(obj_)
        elif nodeName_ == 'parameters':
            obj_ = Parameters.factory()
            obj_.build(child_)
            self.setParameters(obj_)
        elif nodeName_ == 'current_voltage_relation':
            obj_ = CurrentVoltageRelation.factory()
            obj_.build(child_)
            self.setCurrentVoltageRelation(obj_)
        elif nodeName_ == 'hh_gate':
            obj_ = Deprecated_HHGate.factory()
            obj_.build(child_)
            self.hh_gate.append(obj_)
        elif nodeName_ == 'ks_gate':
            obj_ = Deprecated_KSGate.factory()
            obj_.build(child_)
            self.ks_gate.append(obj_)
        elif nodeName_ == 'impl_prefs':
            obj_ = ImplementationPrefs.factory()
            obj_.build(child_)
            self.setImpl_prefs(obj_)
# end class ChannelType


class SynapseType(GeneratedsSuper):
    """Definition of a synaptic mechanismChoice of electrical synapse, or a
    number of chemical synaptic transmission mechanism"""
    subclass = None
    superclass = None
    def __init__(self, name=None, status=None, notes=None, properties=None, annotation=None, group=None, authorList=None, publication=None, neuronDBref=None, modelDBref=None, neuroMorphoRef=None, electrical_syn=None, doub_exp_syn=None, blocking_syn=None, multi_decay_syn=None, fac_dep_syn=None, stdp_syn=None):
        self.name = _cast(None, name)
        self.status = status
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.authorList = authorList
        if publication is None:
            self.publication = []
        else:
            self.publication = publication
        if neuronDBref is None:
            self.neuronDBref = []
        else:
            self.neuronDBref = neuronDBref
        if modelDBref is None:
            self.modelDBref = []
        else:
            self.modelDBref = modelDBref
        if neuroMorphoRef is None:
            self.neuroMorphoRef = []
        else:
            self.neuroMorphoRef = neuroMorphoRef
        self.electrical_syn = electrical_syn
        self.doub_exp_syn = doub_exp_syn
        self.blocking_syn = blocking_syn
        self.multi_decay_syn = multi_decay_syn
        self.fac_dep_syn = fac_dep_syn
        self.stdp_syn = stdp_syn
    def factory(*args_, **kwargs_):
        if SynapseType.subclass:
            return SynapseType.subclass(*args_, **kwargs_)
        else:
            return SynapseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getAuthorList(self): return self.authorList
    def setAuthorList(self, authorList): self.authorList = authorList
    def getPublication(self): return self.publication
    def setPublication(self, publication): self.publication = publication
    def addPublication(self, value): self.publication.append(value)
    def insertPublication(self, index, value): self.publication[index] = value
    def getNeuronDBref(self): return self.neuronDBref
    def setNeuronDBref(self, neuronDBref): self.neuronDBref = neuronDBref
    def addNeuronDBref(self, value): self.neuronDBref.append(value)
    def insertNeuronDBref(self, index, value): self.neuronDBref[index] = value
    def getModelDBref(self): return self.modelDBref
    def setModelDBref(self, modelDBref): self.modelDBref = modelDBref
    def addModelDBref(self, value): self.modelDBref.append(value)
    def insertModelDBref(self, index, value): self.modelDBref[index] = value
    def getNeuroMorphoRef(self): return self.neuroMorphoRef
    def setNeuroMorphoRef(self, neuroMorphoRef): self.neuroMorphoRef = neuroMorphoRef
    def addNeuroMorphoRef(self, value): self.neuroMorphoRef.append(value)
    def insertNeuroMorphoRef(self, index, value): self.neuroMorphoRef[index] = value
    def getElectrical_syn(self): return self.electrical_syn
    def setElectrical_syn(self, electrical_syn): self.electrical_syn = electrical_syn
    def getDoub_exp_syn(self): return self.doub_exp_syn
    def setDoub_exp_syn(self, doub_exp_syn): self.doub_exp_syn = doub_exp_syn
    def getBlocking_syn(self): return self.blocking_syn
    def setBlocking_syn(self, blocking_syn): self.blocking_syn = blocking_syn
    def getMulti_decay_syn(self): return self.multi_decay_syn
    def setMulti_decay_syn(self, multi_decay_syn): self.multi_decay_syn = multi_decay_syn
    def getFac_dep_syn(self): return self.fac_dep_syn
    def setFac_dep_syn(self, fac_dep_syn): self.fac_dep_syn = fac_dep_syn
    def getStdp_syn(self): return self.stdp_syn
    def setStdp_syn(self, stdp_syn): self.stdp_syn = stdp_syn
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='SynapseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SynapseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SynapseType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SynapseType', fromsubclass_=False):
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.authorList is not None:
            self.authorList.export(outfile, level, namespace_, name_='authorList')
        for publication_ in self.publication:
            publication_.export(outfile, level, namespace_, name_='publication')
        for neuronDBref_ in self.neuronDBref:
            neuronDBref_.export(outfile, level, namespace_, name_='neuronDBref')
        for modelDBref_ in self.modelDBref:
            modelDBref_.export(outfile, level, namespace_, name_='modelDBref')
        for neuroMorphoRef_ in self.neuroMorphoRef:
            neuroMorphoRef_.export(outfile, level, namespace_, name_='neuroMorphoRef')
        if self.electrical_syn is not None:
            self.electrical_syn.export(outfile, level, namespace_, name_='electrical_syn', )
        if self.doub_exp_syn is not None:
            self.doub_exp_syn.export(outfile, level, namespace_, name_='doub_exp_syn', )
        if self.blocking_syn is not None:
            self.blocking_syn.export(outfile, level, namespace_, name_='blocking_syn', )
        if self.multi_decay_syn is not None:
            self.multi_decay_syn.export(outfile, level, namespace_, name_='multi_decay_syn', )
        if self.fac_dep_syn is not None:
            self.fac_dep_syn.export(outfile, level, namespace_, name_='fac_dep_syn', )
        if self.stdp_syn is not None:
            self.stdp_syn.export(outfile, level, namespace_, name_='stdp_syn', )
    def hasContent_(self):
        if (
            self.status is not None or
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.authorList is not None or
            self.publication or
            self.neuronDBref or
            self.modelDBref or
            self.neuroMorphoRef or
            self.electrical_syn is not None or
            self.doub_exp_syn is not None or
            self.blocking_syn is not None or
            self.multi_decay_syn is not None or
            self.fac_dep_syn is not None or
            self.stdp_syn is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SynapseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.Status(\n')
            self.status.exportLiteral(outfile, level, name_='status')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.authorList is not None:
            showIndent(outfile, level)
            outfile.write('authorList=model_.Authors(\n')
            self.authorList.exportLiteral(outfile, level, name_='authorList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('publication=[\n')
        level += 1
        for publication_ in self.publication:
            showIndent(outfile, level)
            outfile.write('model_.Publication(\n')
            publication_.exportLiteral(outfile, level, name_='Publication')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuronDBref=[\n')
        level += 1
        for neuronDBref_ in self.neuronDBref:
            showIndent(outfile, level)
            outfile.write('model_.NeuronDBReference(\n')
            neuronDBref_.exportLiteral(outfile, level, name_='NeuronDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelDBref=[\n')
        level += 1
        for modelDBref_ in self.modelDBref:
            showIndent(outfile, level)
            outfile.write('model_.ModelDBReference(\n')
            modelDBref_.exportLiteral(outfile, level, name_='ModelDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuroMorphoRef=[\n')
        level += 1
        for neuroMorphoRef_ in self.neuroMorphoRef:
            showIndent(outfile, level)
            outfile.write('model_.NeuroMorphoRef(\n')
            neuroMorphoRef_.exportLiteral(outfile, level, name_='NeuroMorphoRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.electrical_syn is not None:
            showIndent(outfile, level)
            outfile.write('electrical_syn=model_.ElectricalSynapse(\n')
            self.electrical_syn.exportLiteral(outfile, level, name_='electrical_syn')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.doub_exp_syn is not None:
            showIndent(outfile, level)
            outfile.write('doub_exp_syn=model_.DoubleExponentialSynapse(\n')
            self.doub_exp_syn.exportLiteral(outfile, level, name_='doub_exp_syn')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.blocking_syn is not None:
            showIndent(outfile, level)
            outfile.write('blocking_syn=model_.BlockingSynapse(\n')
            self.blocking_syn.exportLiteral(outfile, level, name_='blocking_syn')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.multi_decay_syn is not None:
            showIndent(outfile, level)
            outfile.write('multi_decay_syn=model_.MultiDecaySynapse(\n')
            self.multi_decay_syn.exportLiteral(outfile, level, name_='multi_decay_syn')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fac_dep_syn is not None:
            showIndent(outfile, level)
            outfile.write('fac_dep_syn=model_.FacDepSynapse(\n')
            self.fac_dep_syn.exportLiteral(outfile, level, name_='fac_dep_syn')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.stdp_syn is not None:
            showIndent(outfile, level)
            outfile.write('stdp_syn=model_.StdpSynapse(\n')
            self.stdp_syn.exportLiteral(outfile, level, name_='stdp_syn')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = Status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'authorList':
            obj_ = Authors.factory()
            obj_.build(child_)
            self.setAuthorList(obj_)
        elif nodeName_ == 'publication':
            obj_ = Publication.factory()
            obj_.build(child_)
            self.publication.append(obj_)
        elif nodeName_ == 'neuronDBref':
            obj_ = NeuronDBReference.factory()
            obj_.build(child_)
            self.neuronDBref.append(obj_)
        elif nodeName_ == 'modelDBref':
            obj_ = ModelDBReference.factory()
            obj_.build(child_)
            self.modelDBref.append(obj_)
        elif nodeName_ == 'neuroMorphoRef':
            obj_ = NeuroMorphoRef.factory()
            obj_.build(child_)
            self.neuroMorphoRef.append(obj_)
        elif nodeName_ == 'electrical_syn':
            obj_ = ElectricalSynapse.factory()
            obj_.build(child_)
            self.setElectrical_syn(obj_)
        elif nodeName_ == 'doub_exp_syn':
            class_obj_ = self.get_class_obj_(child_, DoubleExponentialSynapse)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.setDoub_exp_syn(obj_)
        elif nodeName_ == 'blocking_syn':
            obj_ = BlockingSynapse.factory()
            obj_.build(child_)
            self.setBlocking_syn(obj_)
        elif nodeName_ == 'multi_decay_syn':
            class_obj_ = self.get_class_obj_(child_, MultiDecaySynapse)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.setMulti_decay_syn(obj_)
        elif nodeName_ == 'fac_dep_syn':
            obj_ = FacDepSynapse.factory()
            obj_.build(child_)
            self.setFac_dep_syn(obj_)
        elif nodeName_ == 'stdp_syn':
            obj_ = StdpSynapse.factory()
            obj_.build(child_)
            self.setStdp_syn(obj_)
# end class SynapseType


class ElectricalSynapse(GeneratedsSuper):
    """Electrical synaptic coupling as at a gap junction. A simple model
    with just a parameter for the (2 way) conductanceThe conductance
    of the electrical connection"""
    subclass = None
    superclass = None
    def __init__(self, conductance=None, notes=None, properties=None, annotation=None, group=None):
        self.conductance = _cast(None, conductance)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if ElectricalSynapse.subclass:
            return ElectricalSynapse.subclass(*args_, **kwargs_)
        else:
            return ElectricalSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getConductance(self): return self.conductance
    def setConductance(self, conductance): self.conductance = conductance
    def export(self, outfile, level, namespace_='', name_='ElectricalSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricalSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricalSynapse'):
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.append('conductance')
            outfile.write(' conductance=%s' % (quote_attrib(self.conductance), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricalSynapse', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ElectricalSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.append('conductance')
            showIndent(outfile, level)
            outfile.write('conductance = %s,\n' % (self.conductance,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.append('conductance')
            self.conductance = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
# end class ElectricalSynapse


class DoubleExponentialSynapse(GeneratedsSuper):
    """A basic synaptic mechanism with a double exponential conductance
    time course. This mechanism maps easily on to mechanisms in both
    NEURON (Exp2Syn) and GENESIS (synchan)The maximum conductance of
    the channelThe characteristic rise time of the conductance
    waveform The characteristic decay time of the conductance
    waveform The reversal potential of the synapse, which (along
    with the membrane potential) will determine the current passing
    through the synapse when the conductance is non zero"""
    subclass = None
    superclass = None
    def __init__(self, max_conductance=None, reversal_potential=None, decay_time=None, rise_time=None, notes=None, properties=None, annotation=None, group=None, extensiontype_=None):
        self.max_conductance = _cast(None, max_conductance)
        self.reversal_potential = _cast(None, reversal_potential)
        self.decay_time = _cast(None, decay_time)
        self.rise_time = _cast(None, rise_time)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DoubleExponentialSynapse.subclass:
            return DoubleExponentialSynapse.subclass(*args_, **kwargs_)
        else:
            return DoubleExponentialSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getMax_conductance(self): return self.max_conductance
    def setMax_conductance(self, max_conductance): self.max_conductance = max_conductance
    def getReversal_potential(self): return self.reversal_potential
    def setReversal_potential(self, reversal_potential): self.reversal_potential = reversal_potential
    def getDecay_time(self): return self.decay_time
    def setDecay_time(self, decay_time): self.decay_time = decay_time
    def getRise_time(self): return self.rise_time
    def setRise_time(self, rise_time): self.rise_time = rise_time
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DoubleExponentialSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleExponentialSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DoubleExponentialSynapse'):
        if self.max_conductance is not None and 'max_conductance' not in already_processed:
            already_processed.append('max_conductance')
            outfile.write(' max_conductance=%s' % (quote_attrib(self.max_conductance), ))
        if self.reversal_potential is not None and 'reversal_potential' not in already_processed:
            already_processed.append('reversal_potential')
            outfile.write(' reversal_potential=%s' % (quote_attrib(self.reversal_potential), ))
        if self.decay_time is not None and 'decay_time' not in already_processed:
            already_processed.append('decay_time')
            outfile.write(' decay_time=%s' % (quote_attrib(self.decay_time), ))
        if self.rise_time is not None and 'rise_time' not in already_processed:
            already_processed.append('rise_time')
            outfile.write(' rise_time=%s' % (quote_attrib(self.rise_time), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DoubleExponentialSynapse', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DoubleExponentialSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max_conductance is not None and 'max_conductance' not in already_processed:
            already_processed.append('max_conductance')
            showIndent(outfile, level)
            outfile.write('max_conductance = %s,\n' % (self.max_conductance,))
        if self.reversal_potential is not None and 'reversal_potential' not in already_processed:
            already_processed.append('reversal_potential')
            showIndent(outfile, level)
            outfile.write('reversal_potential = %s,\n' % (self.reversal_potential,))
        if self.decay_time is not None and 'decay_time' not in already_processed:
            already_processed.append('decay_time')
            showIndent(outfile, level)
            outfile.write('decay_time = %s,\n' % (self.decay_time,))
        if self.rise_time is not None and 'rise_time' not in already_processed:
            already_processed.append('rise_time')
            showIndent(outfile, level)
            outfile.write('rise_time = %s,\n' % (self.rise_time,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_conductance', node)
        if value is not None and 'max_conductance' not in already_processed:
            already_processed.append('max_conductance')
            self.max_conductance = value
        value = find_attr_value_('reversal_potential', node)
        if value is not None and 'reversal_potential' not in already_processed:
            already_processed.append('reversal_potential')
            self.reversal_potential = value
        value = find_attr_value_('decay_time', node)
        if value is not None and 'decay_time' not in already_processed:
            already_processed.append('decay_time')
            self.decay_time = value
        value = find_attr_value_('rise_time', node)
        if value is not None and 'rise_time' not in already_processed:
            already_processed.append('rise_time')
            self.rise_time = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
# end class DoubleExponentialSynapse


class BlockingSynapse(DoubleExponentialSynapse):
    """A synaptic mechanism whose conductance can be blocked by the
    presence of a specific species (ion/molecule). Based on the
    mechanism for blocking of an NMDA receptor by Mg as outlined in
    Gabbiani et al, 1994, Maex DeSchutter 1998"""
    subclass = None
    superclass = DoubleExponentialSynapse
    def __init__(self, max_conductance=None, reversal_potential=None, decay_time=None, rise_time=None, notes=None, properties=None, annotation=None, group=None, block=None):
        super(BlockingSynapse, self).__init__(max_conductance, reversal_potential, decay_time, rise_time, notes, properties, annotation, group, )
        self.block = block
    def factory(*args_, **kwargs_):
        if BlockingSynapse.subclass:
            return BlockingSynapse.subclass(*args_, **kwargs_)
        else:
            return BlockingSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBlock(self): return self.block
    def setBlock(self, block): self.block = block
    def export(self, outfile, level, namespace_='', name_='BlockingSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BlockingSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BlockingSynapse'):
        super(BlockingSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BlockingSynapse')
    def exportChildren(self, outfile, level, namespace_='', name_='BlockingSynapse', fromsubclass_=False):
        super(BlockingSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.block is not None:
            self.block.export(outfile, level, namespace_, name_='block', )
    def hasContent_(self):
        if (
            self.block is not None or
            super(BlockingSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BlockingSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BlockingSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BlockingSynapse, self).exportLiteralChildren(outfile, level, name_)
        if self.block is not None:
            showIndent(outfile, level)
            outfile.write('block=model_.Block(\n')
            self.block.exportLiteral(outfile, level, name_='block')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BlockingSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'block':
            obj_ = Block.factory()
            obj_.build(child_)
            self.setBlock(obj_)
        super(BlockingSynapse, self).buildChildren(child_, node, nodeName_, True)
# end class BlockingSynapse


class Block(GeneratedsSuper):
    """Specification for the influence of a blocking species on the
    conductance of a BlockingSynapse. Based on the mechanism for
    blocking of an NMDA receptor by Mg as outlined in Gabbiani et
    al, 1994, Maex DeSchutter 1998Name of species. For ions use
    lowercase, e.g. mgConcentration of species. Multiplicative
    factor for total conductance: 1/(1 + eta * [conc] * exp(-1*
    gamma * V))Used in multiplicative factor for total conductance:
    1/(1 + eta * [conc] * exp(-1* gamma * V))Used in multiplicative
    factor for total conductance: 1/(1 + eta * [conc] * exp(-1*
    gamma * V))"""
    subclass = None
    superclass = None
    def __init__(self, conc=None, species=None, gamma=None, eta=None):
        self.conc = _cast(None, conc)
        self.species = _cast(None, species)
        self.gamma = _cast(float, gamma)
        self.eta = _cast(float, eta)
        pass
    def factory(*args_, **kwargs_):
        if Block.subclass:
            return Block.subclass(*args_, **kwargs_)
        else:
            return Block(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getConc(self): return self.conc
    def setConc(self, conc): self.conc = conc
    def getSpecies(self): return self.species
    def setSpecies(self, species): self.species = species
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def getEta(self): return self.eta
    def setEta(self, eta): self.eta = eta
    def export(self, outfile, level, namespace_='', name_='Block', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Block')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Block'):
        if self.conc is not None and 'conc' not in already_processed:
            already_processed.append('conc')
            outfile.write(' conc=%s' % (quote_attrib(self.conc), ))
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            outfile.write(' species=%s' % (self.gds_format_string(quote_attrib(self.species).encode(ExternalEncoding), input_name='species'), ))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.append('gamma')
            outfile.write(' gamma="%s"' % self.gds_format_double(self.gamma, input_name='gamma'))
        if self.eta is not None and 'eta' not in already_processed:
            already_processed.append('eta')
            outfile.write(' eta="%s"' % self.gds_format_double(self.eta, input_name='eta'))
    def exportChildren(self, outfile, level, namespace_='', name_='Block', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Block'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.conc is not None and 'conc' not in already_processed:
            already_processed.append('conc')
            showIndent(outfile, level)
            outfile.write('conc = %s,\n' % (self.conc,))
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            showIndent(outfile, level)
            outfile.write('species = "%s",\n' % (self.species,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.append('gamma')
            showIndent(outfile, level)
            outfile.write('gamma = %e,\n' % (self.gamma,))
        if self.eta is not None and 'eta' not in already_processed:
            already_processed.append('eta')
            showIndent(outfile, level)
            outfile.write('eta = %e,\n' % (self.eta,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conc', node)
        if value is not None and 'conc' not in already_processed:
            already_processed.append('conc')
            self.conc = value
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.append('species')
            self.species = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.append('gamma')
            try:
                self.gamma = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
        value = find_attr_value_('eta', node)
        if value is not None and 'eta' not in already_processed:
            already_processed.append('eta')
            try:
                self.eta = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (eta): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Block


class MultiDecaySynapse(DoubleExponentialSynapse):
    """A more complex synaptic mechanism featuring up to 4 exponential
    components (1 rise and 3 decay). Currently there is only an
    implementation of this in a NEURON mod file. Attributed added
    can be gmax_2, tau_decay_2, gmax_3 and tau_decay_3. The overall
    conductance is effectively a linear sum of 3 independent
    conductances, all with the same rise time and different decays.
    Note that the gmaxes are specific for each conductance and
    scaling is calculated for each individually, so the maximum
    total conductance (gmax + gmax_2 + gmax_3) will only be reached
    when tau_decay = tau_decay_2 = tau_decay_3, otherwise peaks will
    not overlap. Extends DoubleExponentialSynapseThe maximum
    conductance and decay constant of the 2nd (normally slower)
    component of the synaptic conductanceThe maximum conductance and
    decay constant of the 3nd (normally slower) component of the
    synaptic conductance. Note that either both attributes or
    neither should be present. Unfortunately attributeGroups can't
    be made optional..."""
    subclass = None
    superclass = DoubleExponentialSynapse
    def __init__(self, max_conductance=None, reversal_potential=None, decay_time=None, rise_time=None, notes=None, properties=None, annotation=None, group=None, decay_time_3=None, decay_time_2=None, max_conductance_2=None, max_conductance_3=None, extensiontype_=None):
        super(MultiDecaySynapse, self).__init__(max_conductance, reversal_potential, decay_time, rise_time, notes, properties, annotation, group, extensiontype_, )
        self.decay_time_3 = _cast(None, decay_time_3)
        self.decay_time_2 = _cast(None, decay_time_2)
        self.max_conductance_2 = _cast(None, max_conductance_2)
        self.max_conductance_3 = _cast(None, max_conductance_3)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MultiDecaySynapse.subclass:
            return MultiDecaySynapse.subclass(*args_, **kwargs_)
        else:
            return MultiDecaySynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDecay_time_3(self): return self.decay_time_3
    def setDecay_time_3(self, decay_time_3): self.decay_time_3 = decay_time_3
    def getDecay_time_2(self): return self.decay_time_2
    def setDecay_time_2(self, decay_time_2): self.decay_time_2 = decay_time_2
    def getMax_conductance_2(self): return self.max_conductance_2
    def setMax_conductance_2(self, max_conductance_2): self.max_conductance_2 = max_conductance_2
    def getMax_conductance_3(self): return self.max_conductance_3
    def setMax_conductance_3(self, max_conductance_3): self.max_conductance_3 = max_conductance_3
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MultiDecaySynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiDecaySynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiDecaySynapse'):
        super(MultiDecaySynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiDecaySynapse')
        if self.decay_time_3 is not None and 'decay_time_3' not in already_processed:
            already_processed.append('decay_time_3')
            outfile.write(' decay_time_3=%s' % (quote_attrib(self.decay_time_3), ))
        if self.decay_time_2 is not None and 'decay_time_2' not in already_processed:
            already_processed.append('decay_time_2')
            outfile.write(' decay_time_2=%s' % (quote_attrib(self.decay_time_2), ))
        if self.max_conductance_2 is not None and 'max_conductance_2' not in already_processed:
            already_processed.append('max_conductance_2')
            outfile.write(' max_conductance_2=%s' % (quote_attrib(self.max_conductance_2), ))
        if self.max_conductance_3 is not None and 'max_conductance_3' not in already_processed:
            already_processed.append('max_conductance_3')
            outfile.write(' max_conductance_3=%s' % (quote_attrib(self.max_conductance_3), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MultiDecaySynapse', fromsubclass_=False):
        super(MultiDecaySynapse, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(MultiDecaySynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiDecaySynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.decay_time_3 is not None and 'decay_time_3' not in already_processed:
            already_processed.append('decay_time_3')
            showIndent(outfile, level)
            outfile.write('decay_time_3 = %s,\n' % (self.decay_time_3,))
        if self.decay_time_2 is not None and 'decay_time_2' not in already_processed:
            already_processed.append('decay_time_2')
            showIndent(outfile, level)
            outfile.write('decay_time_2 = %s,\n' % (self.decay_time_2,))
        if self.max_conductance_2 is not None and 'max_conductance_2' not in already_processed:
            already_processed.append('max_conductance_2')
            showIndent(outfile, level)
            outfile.write('max_conductance_2 = %s,\n' % (self.max_conductance_2,))
        if self.max_conductance_3 is not None and 'max_conductance_3' not in already_processed:
            already_processed.append('max_conductance_3')
            showIndent(outfile, level)
            outfile.write('max_conductance_3 = %s,\n' % (self.max_conductance_3,))
        super(MultiDecaySynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiDecaySynapse, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('decay_time_3', node)
        if value is not None and 'decay_time_3' not in already_processed:
            already_processed.append('decay_time_3')
            self.decay_time_3 = value
        value = find_attr_value_('decay_time_2', node)
        if value is not None and 'decay_time_2' not in already_processed:
            already_processed.append('decay_time_2')
            self.decay_time_2 = value
        value = find_attr_value_('max_conductance_2', node)
        if value is not None and 'max_conductance_2' not in already_processed:
            already_processed.append('max_conductance_2')
            self.max_conductance_2 = value
        value = find_attr_value_('max_conductance_3', node)
        if value is not None and 'max_conductance_3' not in already_processed:
            already_processed.append('max_conductance_3')
            self.max_conductance_3 = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(MultiDecaySynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MultiDecaySynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MultiDecaySynapse


class FacDepSynapse(MultiDecaySynapse):
    """A synaptic type with facilitating and depressing amplitude. Extends
    MultiDecaySynapse"""
    subclass = None
    superclass = MultiDecaySynapse
    def __init__(self, max_conductance=None, reversal_potential=None, decay_time=None, rise_time=None, notes=None, properties=None, annotation=None, group=None, decay_time_3=None, decay_time_2=None, max_conductance_2=None, max_conductance_3=None, plasticity=None):
        super(FacDepSynapse, self).__init__(max_conductance, reversal_potential, decay_time, rise_time, notes, properties, annotation, group, decay_time_3, decay_time_2, max_conductance_2, max_conductance_3, )
        self.plasticity = plasticity
    def factory(*args_, **kwargs_):
        if FacDepSynapse.subclass:
            return FacDepSynapse.subclass(*args_, **kwargs_)
        else:
            return FacDepSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPlasticity(self): return self.plasticity
    def setPlasticity(self, plasticity): self.plasticity = plasticity
    def export(self, outfile, level, namespace_='', name_='FacDepSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacDepSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FacDepSynapse'):
        super(FacDepSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FacDepSynapse')
    def exportChildren(self, outfile, level, namespace_='', name_='FacDepSynapse', fromsubclass_=False):
        super(FacDepSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.plasticity is not None:
            self.plasticity.export(outfile, level, namespace_, name_='plasticity', )
    def hasContent_(self):
        if (
            self.plasticity is not None or
            super(FacDepSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FacDepSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FacDepSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FacDepSynapse, self).exportLiteralChildren(outfile, level, name_)
        if self.plasticity is not None:
            showIndent(outfile, level)
            outfile.write('plasticity=model_.FacDep(\n')
            self.plasticity.exportLiteral(outfile, level, name_='plasticity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(FacDepSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'plasticity':
            obj_ = FacDep.factory()
            obj_.build(child_)
            self.setPlasticity(obj_)
        super(FacDepSynapse, self).buildChildren(child_, node, nodeName_, True)
# end class FacDepSynapse


class StdpSynapse(MultiDecaySynapse):
    """A synaptic mechanism implementing basic Spike Timing Dependent
    Plasticity based on Song and Abbott, 2001Extends
    MultiDecaySynapse"""
    subclass = None
    superclass = MultiDecaySynapse
    def __init__(self, max_conductance=None, reversal_potential=None, decay_time=None, rise_time=None, notes=None, properties=None, annotation=None, group=None, decay_time_3=None, decay_time_2=None, max_conductance_2=None, max_conductance_3=None, spike_time_dep=None):
        super(StdpSynapse, self).__init__(max_conductance, reversal_potential, decay_time, rise_time, notes, properties, annotation, group, decay_time_3, decay_time_2, max_conductance_2, max_conductance_3, )
        self.spike_time_dep = spike_time_dep
    def factory(*args_, **kwargs_):
        if StdpSynapse.subclass:
            return StdpSynapse.subclass(*args_, **kwargs_)
        else:
            return StdpSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSpike_time_dep(self): return self.spike_time_dep
    def setSpike_time_dep(self, spike_time_dep): self.spike_time_dep = spike_time_dep
    def export(self, outfile, level, namespace_='', name_='StdpSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StdpSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StdpSynapse'):
        super(StdpSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StdpSynapse')
    def exportChildren(self, outfile, level, namespace_='', name_='StdpSynapse', fromsubclass_=False):
        super(StdpSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.spike_time_dep is not None:
            self.spike_time_dep.export(outfile, level, namespace_, name_='spike_time_dep', )
    def hasContent_(self):
        if (
            self.spike_time_dep is not None or
            super(StdpSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StdpSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StdpSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StdpSynapse, self).exportLiteralChildren(outfile, level, name_)
        if self.spike_time_dep is not None:
            showIndent(outfile, level)
            outfile.write('spike_time_dep=model_.StdpDep(\n')
            self.spike_time_dep.exportLiteral(outfile, level, name_='spike_time_dep')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StdpSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spike_time_dep':
            obj_ = StdpDep.factory()
            obj_.build(child_)
            self.setSpike_time_dep(obj_)
        super(StdpSynapse, self).buildChildren(child_, node, nodeName_, True)
# end class StdpSynapse


class FacDep(GeneratedsSuper):
    """Facilitating and depressing synaptic parameters. See mapping to
    NEURON mod file for implementation details."""
    subclass = None
    superclass = None
    def __init__(self, tau_fac=None, tau_rec=None, init_release_prob=None):
        self.tau_fac = _cast(None, tau_fac)
        self.tau_rec = _cast(None, tau_rec)
        self.init_release_prob = _cast(float, init_release_prob)
        pass
    def factory(*args_, **kwargs_):
        if FacDep.subclass:
            return FacDep.subclass(*args_, **kwargs_)
        else:
            return FacDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTau_fac(self): return self.tau_fac
    def setTau_fac(self, tau_fac): self.tau_fac = tau_fac
    def getTau_rec(self): return self.tau_rec
    def setTau_rec(self, tau_rec): self.tau_rec = tau_rec
    def getInit_release_prob(self): return self.init_release_prob
    def setInit_release_prob(self, init_release_prob): self.init_release_prob = init_release_prob
    def export(self, outfile, level, namespace_='', name_='FacDep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacDep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FacDep'):
        if self.tau_fac is not None and 'tau_fac' not in already_processed:
            already_processed.append('tau_fac')
            outfile.write(' tau_fac=%s' % (quote_attrib(self.tau_fac), ))
        if self.tau_rec is not None and 'tau_rec' not in already_processed:
            already_processed.append('tau_rec')
            outfile.write(' tau_rec=%s' % (quote_attrib(self.tau_rec), ))
        if self.init_release_prob is not None and 'init_release_prob' not in already_processed:
            already_processed.append('init_release_prob')
            outfile.write(' init_release_prob="%s"' % self.gds_format_double(self.init_release_prob, input_name='init_release_prob'))
    def exportChildren(self, outfile, level, namespace_='', name_='FacDep', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FacDep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tau_fac is not None and 'tau_fac' not in already_processed:
            already_processed.append('tau_fac')
            showIndent(outfile, level)
            outfile.write('tau_fac = %s,\n' % (self.tau_fac,))
        if self.tau_rec is not None and 'tau_rec' not in already_processed:
            already_processed.append('tau_rec')
            showIndent(outfile, level)
            outfile.write('tau_rec = %s,\n' % (self.tau_rec,))
        if self.init_release_prob is not None and 'init_release_prob' not in already_processed:
            already_processed.append('init_release_prob')
            showIndent(outfile, level)
            outfile.write('init_release_prob = %e,\n' % (self.init_release_prob,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tau_fac', node)
        if value is not None and 'tau_fac' not in already_processed:
            already_processed.append('tau_fac')
            self.tau_fac = value
        value = find_attr_value_('tau_rec', node)
        if value is not None and 'tau_rec' not in already_processed:
            already_processed.append('tau_rec')
            self.tau_rec = value
        value = find_attr_value_('init_release_prob', node)
        if value is not None and 'init_release_prob' not in already_processed:
            already_processed.append('init_release_prob')
            try:
                self.init_release_prob = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (init_release_prob): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FacDep


class StdpDep(GeneratedsSuper):
    """A synaptic mechanism implementing basic Spike Timing Dependent
    Plasticity based on Song and Abbott, 2001. See mapping to NEURON
    mod file for implementation details."""
    subclass = None
    superclass = None
    def __init__(self, tau_ltd=None, post_spike_thresh=None, del_weight_ltp=None, max_syn_weight=None, tau_ltp=None, del_weight_ltd=None):
        self.tau_ltd = _cast(None, tau_ltd)
        self.post_spike_thresh = _cast(None, post_spike_thresh)
        self.del_weight_ltp = _cast(float, del_weight_ltp)
        self.max_syn_weight = _cast(float, max_syn_weight)
        self.tau_ltp = _cast(None, tau_ltp)
        self.del_weight_ltd = _cast(float, del_weight_ltd)
        pass
    def factory(*args_, **kwargs_):
        if StdpDep.subclass:
            return StdpDep.subclass(*args_, **kwargs_)
        else:
            return StdpDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTau_ltd(self): return self.tau_ltd
    def setTau_ltd(self, tau_ltd): self.tau_ltd = tau_ltd
    def getPost_spike_thresh(self): return self.post_spike_thresh
    def setPost_spike_thresh(self, post_spike_thresh): self.post_spike_thresh = post_spike_thresh
    def getDel_weight_ltp(self): return self.del_weight_ltp
    def setDel_weight_ltp(self, del_weight_ltp): self.del_weight_ltp = del_weight_ltp
    def getMax_syn_weight(self): return self.max_syn_weight
    def setMax_syn_weight(self, max_syn_weight): self.max_syn_weight = max_syn_weight
    def getTau_ltp(self): return self.tau_ltp
    def setTau_ltp(self, tau_ltp): self.tau_ltp = tau_ltp
    def getDel_weight_ltd(self): return self.del_weight_ltd
    def setDel_weight_ltd(self, del_weight_ltd): self.del_weight_ltd = del_weight_ltd
    def export(self, outfile, level, namespace_='', name_='StdpDep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StdpDep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StdpDep'):
        if self.tau_ltd is not None and 'tau_ltd' not in already_processed:
            already_processed.append('tau_ltd')
            outfile.write(' tau_ltd=%s' % (quote_attrib(self.tau_ltd), ))
        if self.post_spike_thresh is not None and 'post_spike_thresh' not in already_processed:
            already_processed.append('post_spike_thresh')
            outfile.write(' post_spike_thresh=%s' % (quote_attrib(self.post_spike_thresh), ))
        if self.del_weight_ltp is not None and 'del_weight_ltp' not in already_processed:
            already_processed.append('del_weight_ltp')
            outfile.write(' del_weight_ltp="%s"' % self.gds_format_double(self.del_weight_ltp, input_name='del_weight_ltp'))
        if self.max_syn_weight is not None and 'max_syn_weight' not in already_processed:
            already_processed.append('max_syn_weight')
            outfile.write(' max_syn_weight="%s"' % self.gds_format_double(self.max_syn_weight, input_name='max_syn_weight'))
        if self.tau_ltp is not None and 'tau_ltp' not in already_processed:
            already_processed.append('tau_ltp')
            outfile.write(' tau_ltp=%s' % (quote_attrib(self.tau_ltp), ))
        if self.del_weight_ltd is not None and 'del_weight_ltd' not in already_processed:
            already_processed.append('del_weight_ltd')
            outfile.write(' del_weight_ltd="%s"' % self.gds_format_double(self.del_weight_ltd, input_name='del_weight_ltd'))
    def exportChildren(self, outfile, level, namespace_='', name_='StdpDep', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StdpDep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tau_ltd is not None and 'tau_ltd' not in already_processed:
            already_processed.append('tau_ltd')
            showIndent(outfile, level)
            outfile.write('tau_ltd = %s,\n' % (self.tau_ltd,))
        if self.post_spike_thresh is not None and 'post_spike_thresh' not in already_processed:
            already_processed.append('post_spike_thresh')
            showIndent(outfile, level)
            outfile.write('post_spike_thresh = %s,\n' % (self.post_spike_thresh,))
        if self.del_weight_ltp is not None and 'del_weight_ltp' not in already_processed:
            already_processed.append('del_weight_ltp')
            showIndent(outfile, level)
            outfile.write('del_weight_ltp = %e,\n' % (self.del_weight_ltp,))
        if self.max_syn_weight is not None and 'max_syn_weight' not in already_processed:
            already_processed.append('max_syn_weight')
            showIndent(outfile, level)
            outfile.write('max_syn_weight = %e,\n' % (self.max_syn_weight,))
        if self.tau_ltp is not None and 'tau_ltp' not in already_processed:
            already_processed.append('tau_ltp')
            showIndent(outfile, level)
            outfile.write('tau_ltp = %s,\n' % (self.tau_ltp,))
        if self.del_weight_ltd is not None and 'del_weight_ltd' not in already_processed:
            already_processed.append('del_weight_ltd')
            showIndent(outfile, level)
            outfile.write('del_weight_ltd = %e,\n' % (self.del_weight_ltd,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tau_ltd', node)
        if value is not None and 'tau_ltd' not in already_processed:
            already_processed.append('tau_ltd')
            self.tau_ltd = value
        value = find_attr_value_('post_spike_thresh', node)
        if value is not None and 'post_spike_thresh' not in already_processed:
            already_processed.append('post_spike_thresh')
            self.post_spike_thresh = value
        value = find_attr_value_('del_weight_ltp', node)
        if value is not None and 'del_weight_ltp' not in already_processed:
            already_processed.append('del_weight_ltp')
            try:
                self.del_weight_ltp = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (del_weight_ltp): %s' % exp)
        value = find_attr_value_('max_syn_weight', node)
        if value is not None and 'max_syn_weight' not in already_processed:
            already_processed.append('max_syn_weight')
            try:
                self.max_syn_weight = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (max_syn_weight): %s' % exp)
        value = find_attr_value_('tau_ltp', node)
        if value is not None and 'tau_ltp' not in already_processed:
            already_processed.append('tau_ltp')
            self.tau_ltp = value
        value = find_attr_value_('del_weight_ltd', node)
        if value is not None and 'del_weight_ltd' not in already_processed:
            already_processed.append('del_weight_ltd')
            try:
                self.del_weight_ltd = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (del_weight_ltd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StdpDep


class CurrentVoltageRelation(GeneratedsSuper):
    """How the current through the channel depends on the conductance of
    the channel. Only ohmic and integrate_and_fire supported at the
    momentIntroduced in v1.7.3 for new format ChannelML. Specifies
    which type of conductance law to use: ohmic, etc.Introduced in
    v1.7.3 for new format ChannelML. The ion which will flow due to
    the conductance. Note this should be already declared in an Ion
    element at the beginning of the file.Introduced in v1.7.3 for
    new format ChannelML. Maximum conductance density of channel.
    Note this will normally be reset when the channel mechanism is
    placed on a cell, but it it useful to have a default value
    here.Most implementations of these channel mechanisms (e.g. a
    mod file) will need a value for the reversal potential for the
    ion which flows through the channel. However, this is a property
    of the cell, as opposed to the channel. For convenience though,
    a typical value can be used here, so a pretty self contained
    script can be produced, but when used in a real cell the actual
    value for erev must be calculatedElectrical charge of the ion in
    questionFlags whether the reversal potential can be influenced
    from outside the channel (value = no; default) as is normally
    the case (e.g. a Ca channel whose reversal potential is
    influenced by a decaying calcium pool), or whether the rev pot
    remains fixed (just for this channel) at default_erev (value =
    yes)"""
    subclass = None
    superclass = None
    def __init__(self, default_gmax=None, ion=None, charge=None, default_erev=None, cond_law=None, fixed_erev='no', ohmic=None, integrate_and_fire=None, conc_dependence=None, conc_factor=None, q10_settings=None, offset=None, gate=None):
        self.default_gmax = _cast(None, default_gmax)
        self.ion = _cast(None, ion)
        self.charge = _cast(int, charge)
        self.default_erev = _cast(None, default_erev)
        self.cond_law = _cast(None, cond_law)
        self.fixed_erev = _cast(None, fixed_erev)
        self.ohmic = ohmic
        self.integrate_and_fire = integrate_and_fire
        self.conc_dependence = conc_dependence
        self.conc_factor = conc_factor
        if q10_settings is None:
            self.q10_settings = []
        else:
            self.q10_settings = q10_settings
        self.offset = offset
        if gate is None:
            self.gate = []
        else:
            self.gate = gate
    def factory(*args_, **kwargs_):
        if CurrentVoltageRelation.subclass:
            return CurrentVoltageRelation.subclass(*args_, **kwargs_)
        else:
            return CurrentVoltageRelation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getOhmic(self): return self.ohmic
    def setOhmic(self, ohmic): self.ohmic = ohmic
    def getIntegrate_and_fire(self): return self.integrate_and_fire
    def setIntegrate_and_fire(self, integrate_and_fire): self.integrate_and_fire = integrate_and_fire
    def getConc_dependence(self): return self.conc_dependence
    def setConc_dependence(self, conc_dependence): self.conc_dependence = conc_dependence
    def getConc_factor(self): return self.conc_factor
    def setConc_factor(self, conc_factor): self.conc_factor = conc_factor
    def getQ10_settings(self): return self.q10_settings
    def setQ10_settings(self, q10_settings): self.q10_settings = q10_settings
    def addQ10_settings(self, value): self.q10_settings.append(value)
    def insertQ10_settings(self, index, value): self.q10_settings[index] = value
    def getOffset(self): return self.offset
    def setOffset(self, offset): self.offset = offset
    def getGate(self): return self.gate
    def setGate(self, gate): self.gate = gate
    def addGate(self, value): self.gate.append(value)
    def insertGate(self, index, value): self.gate[index] = value
    def getDefault_gmax(self): return self.default_gmax
    def setDefault_gmax(self, default_gmax): self.default_gmax = default_gmax
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def getCharge(self): return self.charge
    def setCharge(self, charge): self.charge = charge
    def getDefault_erev(self): return self.default_erev
    def setDefault_erev(self, default_erev): self.default_erev = default_erev
    def getCond_law(self): return self.cond_law
    def setCond_law(self, cond_law): self.cond_law = cond_law
    def validate_ConductanceLaw(self, value):
        # Validate type ConductanceLaw, a restriction on xs:string.
        pass
    def getFixed_erev(self): return self.fixed_erev
    def setFixed_erev(self, fixed_erev): self.fixed_erev = fixed_erev
    def export(self, outfile, level, namespace_='', name_='CurrentVoltageRelation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentVoltageRelation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentVoltageRelation'):
        if self.default_gmax is not None and 'default_gmax' not in already_processed:
            already_processed.append('default_gmax')
            outfile.write(' default_gmax=%s' % (quote_attrib(self.default_gmax), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            outfile.write(' ion=%s' % (self.gds_format_string(quote_attrib(self.ion).encode(ExternalEncoding), input_name='ion'), ))
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            outfile.write(' charge="%s"' % self.gds_format_integer(self.charge, input_name='charge'))
        if self.default_erev is not None and 'default_erev' not in already_processed:
            already_processed.append('default_erev')
            outfile.write(' default_erev=%s' % (quote_attrib(self.default_erev), ))
        if self.cond_law is not None and 'cond_law' not in already_processed:
            already_processed.append('cond_law')
            outfile.write(' cond_law=%s' % (quote_attrib(self.cond_law), ))
        if self.fixed_erev is not None and 'fixed_erev' not in already_processed:
            already_processed.append('fixed_erev')
            outfile.write(' fixed_erev=%s' % (quote_attrib(self.fixed_erev), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentVoltageRelation', fromsubclass_=False):
        if self.ohmic is not None:
            self.ohmic.export(outfile, level, namespace_, name_='ohmic')
        if self.integrate_and_fire is not None:
            self.integrate_and_fire.export(outfile, level, namespace_, name_='integrate_and_fire')
        if self.conc_dependence is not None:
            self.conc_dependence.export(outfile, level, namespace_, name_='conc_dependence')
        if self.conc_factor is not None:
            self.conc_factor.export(outfile, level, namespace_, name_='conc_factor')
        for q10_settings_ in self.q10_settings:
            q10_settings_.export(outfile, level, namespace_, name_='q10_settings')
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset')
        for gate_ in self.gate:
            gate_.export(outfile, level, namespace_, name_='gate')
    def hasContent_(self):
        if (
            self.ohmic is not None or
            self.integrate_and_fire is not None or
            self.conc_dependence is not None or
            self.conc_factor is not None or
            self.q10_settings or
            self.offset is not None or
            self.gate
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CurrentVoltageRelation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default_gmax is not None and 'default_gmax' not in already_processed:
            already_processed.append('default_gmax')
            showIndent(outfile, level)
            outfile.write('default_gmax = %s,\n' % (self.default_gmax,))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            showIndent(outfile, level)
            outfile.write('ion = "%s",\n' % (self.ion,))
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            showIndent(outfile, level)
            outfile.write('charge = %d,\n' % (self.charge,))
        if self.default_erev is not None and 'default_erev' not in already_processed:
            already_processed.append('default_erev')
            showIndent(outfile, level)
            outfile.write('default_erev = %s,\n' % (self.default_erev,))
        if self.cond_law is not None and 'cond_law' not in already_processed:
            already_processed.append('cond_law')
            showIndent(outfile, level)
            outfile.write('cond_law = "%s",\n' % (self.cond_law,))
        if self.fixed_erev is not None and 'fixed_erev' not in already_processed:
            already_processed.append('fixed_erev')
            showIndent(outfile, level)
            outfile.write('fixed_erev = %s,\n' % (self.fixed_erev,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ohmic is not None:
            showIndent(outfile, level)
            outfile.write('ohmic=model_.Deprecated_Ohmic(\n')
            self.ohmic.exportLiteral(outfile, level, name_='ohmic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.integrate_and_fire is not None:
            showIndent(outfile, level)
            outfile.write('integrate_and_fire=model_.IntegrateAndFire(\n')
            self.integrate_and_fire.exportLiteral(outfile, level, name_='integrate_and_fire')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.conc_dependence is not None:
            showIndent(outfile, level)
            outfile.write('conc_dependence=model_.ConcDependence(\n')
            self.conc_dependence.exportLiteral(outfile, level, name_='conc_dependence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.conc_factor is not None:
            showIndent(outfile, level)
            outfile.write('conc_factor=model_.ConcFactor(\n')
            self.conc_factor.exportLiteral(outfile, level, name_='conc_factor')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('q10_settings=[\n')
        level += 1
        for q10_settings_ in self.q10_settings:
            showIndent(outfile, level)
            outfile.write('model_.Q10Settings(\n')
            q10_settings_.exportLiteral(outfile, level, name_='Q10Settings')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.offset is not None:
            showIndent(outfile, level)
            outfile.write('offset=model_.Offset(\n')
            self.offset.exportLiteral(outfile, level, name_='offset')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('gate=[\n')
        level += 1
        for gate_ in self.gate:
            showIndent(outfile, level)
            outfile.write('model_.GatingComplex(\n')
            gate_.exportLiteral(outfile, level, name_='GatingComplex')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_gmax', node)
        if value is not None and 'default_gmax' not in already_processed:
            already_processed.append('default_gmax')
            self.default_gmax = value
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            self.ion = value
        value = find_attr_value_('charge', node)
        if value is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            try:
                self.charge = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.charge <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('default_erev', node)
        if value is not None and 'default_erev' not in already_processed:
            already_processed.append('default_erev')
            self.default_erev = value
        value = find_attr_value_('cond_law', node)
        if value is not None and 'cond_law' not in already_processed:
            already_processed.append('cond_law')
            self.cond_law = value
            self.validate_ConductanceLaw(self.cond_law)    # validate type ConductanceLaw
        value = find_attr_value_('fixed_erev', node)
        if value is not None and 'fixed_erev' not in already_processed:
            already_processed.append('fixed_erev')
            self.fixed_erev = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ohmic':
            obj_ = Deprecated_Ohmic.factory()
            obj_.build(child_)
            self.setOhmic(obj_)
        elif nodeName_ == 'integrate_and_fire':
            obj_ = IntegrateAndFire.factory()
            obj_.build(child_)
            self.setIntegrate_and_fire(obj_)
        elif nodeName_ == 'conc_dependence':
            obj_ = ConcDependence.factory()
            obj_.build(child_)
            self.setConc_dependence(obj_)
        elif nodeName_ == 'conc_factor':
            obj_ = ConcFactor.factory()
            obj_.build(child_)
            self.setConc_factor(obj_)
        elif nodeName_ == 'q10_settings':
            obj_ = Q10Settings.factory()
            obj_.build(child_)
            self.q10_settings.append(obj_)
        elif nodeName_ == 'offset':
            obj_ = Offset.factory()
            obj_.build(child_)
            self.setOffset(obj_)
        elif nodeName_ == 'gate':
            obj_ = GatingComplex.factory()
            obj_.build(child_)
            self.gate.append(obj_)
# end class CurrentVoltageRelation


class IntegrateAndFire(GeneratedsSuper):
    """Signifies a current which will cause the cell to behave like an
    integrate and fire neuron. There are many ways to describe an
    Integrate and Fire mechanism, this one is based on the
    implementation in NEURON of the COBA IandF cell as described in
    Brette et al (2007)Voltage at which the mechanism causes the
    segment/cell to fire, i.e. membrane potential will be reset to
    v_resetTime after a spike during which the segment will be
    clamped to v_reset (clamping current given by i = g_refrac*(v -
    v_reset))Membrane potential is reset to this after
    spikingConductance during the period t_refrac after a spike,
    when the current due to this mechanism is given by i =
    g_refrac*(v - v_reset), therefore a high value for g_refrac,
    e.g. 100 microsiemens, will effectively clamp the cell at
    v_reset"""
    subclass = None
    superclass = None
    def __init__(self, threshold=None, g_refrac=None, t_refrac=None, v_reset=None):
        self.threshold = _cast(None, threshold)
        self.g_refrac = _cast(None, g_refrac)
        self.t_refrac = _cast(None, t_refrac)
        self.v_reset = _cast(None, v_reset)
        pass
    def factory(*args_, **kwargs_):
        if IntegrateAndFire.subclass:
            return IntegrateAndFire.subclass(*args_, **kwargs_)
        else:
            return IntegrateAndFire(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getThreshold(self): return self.threshold
    def setThreshold(self, threshold): self.threshold = threshold
    def getG_refrac(self): return self.g_refrac
    def setG_refrac(self, g_refrac): self.g_refrac = g_refrac
    def getT_refrac(self): return self.t_refrac
    def setT_refrac(self, t_refrac): self.t_refrac = t_refrac
    def getV_reset(self): return self.v_reset
    def setV_reset(self, v_reset): self.v_reset = v_reset
    def export(self, outfile, level, namespace_='', name_='IntegrateAndFire', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegrateAndFire')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IntegrateAndFire'):
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.append('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
        if self.g_refrac is not None and 'g_refrac' not in already_processed:
            already_processed.append('g_refrac')
            outfile.write(' g_refrac=%s' % (quote_attrib(self.g_refrac), ))
        if self.t_refrac is not None and 't_refrac' not in already_processed:
            already_processed.append('t_refrac')
            outfile.write(' t_refrac=%s' % (quote_attrib(self.t_refrac), ))
        if self.v_reset is not None and 'v_reset' not in already_processed:
            already_processed.append('v_reset')
            outfile.write(' v_reset=%s' % (quote_attrib(self.v_reset), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IntegrateAndFire', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IntegrateAndFire'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.append('threshold')
            showIndent(outfile, level)
            outfile.write('threshold = %s,\n' % (self.threshold,))
        if self.g_refrac is not None and 'g_refrac' not in already_processed:
            already_processed.append('g_refrac')
            showIndent(outfile, level)
            outfile.write('g_refrac = %s,\n' % (self.g_refrac,))
        if self.t_refrac is not None and 't_refrac' not in already_processed:
            already_processed.append('t_refrac')
            showIndent(outfile, level)
            outfile.write('t_refrac = %s,\n' % (self.t_refrac,))
        if self.v_reset is not None and 'v_reset' not in already_processed:
            already_processed.append('v_reset')
            showIndent(outfile, level)
            outfile.write('v_reset = %s,\n' % (self.v_reset,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.append('threshold')
            self.threshold = value
        value = find_attr_value_('g_refrac', node)
        if value is not None and 'g_refrac' not in already_processed:
            already_processed.append('g_refrac')
            self.g_refrac = value
        value = find_attr_value_('t_refrac', node)
        if value is not None and 't_refrac' not in already_processed:
            already_processed.append('t_refrac')
            self.t_refrac = value
        value = find_attr_value_('v_reset', node)
        if value is not None and 'v_reset' not in already_processed:
            already_processed.append('v_reset')
            self.v_reset = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IntegrateAndFire


class Deprecated_Ohmic(GeneratedsSuper):
    """Signifies an ohmic relation; the current is proportional to the
    potential difference across the channel. Deprecated! Will be
    removed in v2.0The ion which will flow due to the conductance.
    Note this should be already declared in an Ion element at the
    beginning of the file."""
    subclass = None
    superclass = None
    def __init__(self, ion=None, conductance=None):
        self.ion = _cast(None, ion)
        self.conductance = conductance
    def factory(*args_, **kwargs_):
        if Deprecated_Ohmic.subclass:
            return Deprecated_Ohmic.subclass(*args_, **kwargs_)
        else:
            return Deprecated_Ohmic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getConductance(self): return self.conductance
    def setConductance(self, conductance): self.conductance = conductance
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def export(self, outfile, level, namespace_='', name_='Deprecated_Ohmic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_Ohmic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_Ohmic'):
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            outfile.write(' ion=%s' % (self.gds_format_string(quote_attrib(self.ion).encode(ExternalEncoding), input_name='ion'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_Ohmic', fromsubclass_=False):
        if self.conductance is not None:
            self.conductance.export(outfile, level, namespace_, name_='conductance', )
    def hasContent_(self):
        if (
            self.conductance is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_Ohmic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            showIndent(outfile, level)
            outfile.write('ion = "%s",\n' % (self.ion,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.conductance is not None:
            showIndent(outfile, level)
            outfile.write('conductance=model_.conductanceType(\n')
            self.conductance.exportLiteral(outfile, level, name_='conductance')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            self.ion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conductance':
            obj_ = conductanceType.factory()
            obj_.build(child_)
            self.setConductance(obj_)
# end class Deprecated_Ohmic


class ImplementationPrefs(GeneratedsSuper):
    """These items ideally shouldn't be in a specification which deals with
    a description of the physiology of the channel. However, some
    channels won't be properly implemented in the scripting
    mechanism of given simulator using the standard mappings unless
    these factors are taken into account, e.g. if the rate equations
    change rapidly, but the default table size isn't large enough."""
    subclass = None
    superclass = None
    def __init__(self, comment=None, table_settings=None):
        self.comment = comment
        self.table_settings = table_settings
    def factory(*args_, **kwargs_):
        if ImplementationPrefs.subclass:
            return ImplementationPrefs.subclass(*args_, **kwargs_)
        else:
            return ImplementationPrefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def getTable_settings(self): return self.table_settings
    def setTable_settings(self, table_settings): self.table_settings = table_settings
    def export(self, outfile, level, namespace_='', name_='ImplementationPrefs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImplementationPrefs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImplementationPrefs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImplementationPrefs', fromsubclass_=False):
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
        if self.table_settings is not None:
            self.table_settings.export(outfile, level, namespace_, name_='table_settings')
    def hasContent_(self):
        if (
            self.comment is not None or
            self.table_settings is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImplementationPrefs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
        if self.table_settings is not None:
            showIndent(outfile, level)
            outfile.write('table_settings=model_.table_settingsType(\n')
            self.table_settings.exportLiteral(outfile, level, name_='table_settings')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
        elif nodeName_ == 'table_settings':
            obj_ = table_settingsType.factory()
            obj_.build(child_)
            self.setTable_settings(obj_)
# end class ImplementationPrefs


class RateAdjustments(GeneratedsSuper):
    """Adjustments necessary to all the rate equations, e.g temperature
    dependencies, voltage offsets introduced when moving between
    species, etc. See the XSL mappings for more information on the
    meaning of these adjustments."""
    subclass = None
    superclass = None
    def __init__(self, q10_settings=None, offset=None):
        if q10_settings is None:
            self.q10_settings = []
        else:
            self.q10_settings = q10_settings
        self.offset = offset
    def factory(*args_, **kwargs_):
        if RateAdjustments.subclass:
            return RateAdjustments.subclass(*args_, **kwargs_)
        else:
            return RateAdjustments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getQ10_settings(self): return self.q10_settings
    def setQ10_settings(self, q10_settings): self.q10_settings = q10_settings
    def addQ10_settings(self, value): self.q10_settings.append(value)
    def insertQ10_settings(self, index, value): self.q10_settings[index] = value
    def getOffset(self): return self.offset
    def setOffset(self, offset): self.offset = offset
    def export(self, outfile, level, namespace_='', name_='RateAdjustments', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateAdjustments')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateAdjustments'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RateAdjustments', fromsubclass_=False):
        for q10_settings_ in self.q10_settings:
            q10_settings_.export(outfile, level, namespace_, name_='q10_settings')
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset')
    def hasContent_(self):
        if (
            self.q10_settings or
            self.offset is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RateAdjustments'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('q10_settings=[\n')
        level += 1
        for q10_settings_ in self.q10_settings:
            showIndent(outfile, level)
            outfile.write('model_.Q10Settings(\n')
            q10_settings_.exportLiteral(outfile, level, name_='Q10Settings')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.offset is not None:
            showIndent(outfile, level)
            outfile.write('offset=model_.Offset(\n')
            self.offset.exportLiteral(outfile, level, name_='offset')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'q10_settings':
            obj_ = Q10Settings.factory()
            obj_.build(child_)
            self.q10_settings.append(obj_)
        elif nodeName_ == 'offset':
            obj_ = Offset.factory()
            obj_.build(child_)
            self.setOffset(obj_)
# end class RateAdjustments


class Offset(GeneratedsSuper):
    """Offset introduced to alter voltage dependence of rate equations, see
    NEURON/GENESIS mappings for details"""
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if Offset.subclass:
            return Offset.subclass(*args_, **kwargs_)
        else:
            return Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='Offset', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Offset'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Offset', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Offset'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %s,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Offset


class Q10Settings(GeneratedsSuper):
    """Q10 scaling affects the tau in the rate equations. It allows rate
    equations determined at one temperature to be used at a
    different temperature. If tauExp is the experimentally measured
    tau, the rate at temperature T is given by tau(T) = tauExp /
    q10_factor ^ ((T - experimental_temp)/10). NOTE: if fixed_q10 is
    specified the expression will be tau(T) = tauExp / fixed_q10,
    and the experimental_temp can be used to check that a simulation
    is running at the desired temperature. The gate to which the Q10
    adjustment should be applied. If this attribute is not present,
    assume the adjustment applies at all gates.Q10 factor if the
    cell is to be run at a different temp than that at which the
    alpha and beta were determined. Only one of fixed_q10 or
    q10_factor should be specified!Q10 factor if the cell is to be
    run at a different temp than that at which the alpha and beta
    were determined. Only one of fixed_q10 or q10_factor should be
    specified!The experimental temperature at which alpha and beta
    rate equations were determined were measured"""
    subclass = None
    superclass = None
    def __init__(self, fixed_q10=None, gate=None, q10_factor=None, experimental_temp=None):
        self.fixed_q10 = _cast(float, fixed_q10)
        self.gate = _cast(None, gate)
        self.q10_factor = _cast(float, q10_factor)
        self.experimental_temp = _cast(None, experimental_temp)
        pass
    def factory(*args_, **kwargs_):
        if Q10Settings.subclass:
            return Q10Settings.subclass(*args_, **kwargs_)
        else:
            return Q10Settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFixed_q10(self): return self.fixed_q10
    def setFixed_q10(self, fixed_q10): self.fixed_q10 = fixed_q10
    def getGate(self): return self.gate
    def setGate(self, gate): self.gate = gate
    def getQ10_factor(self): return self.q10_factor
    def setQ10_factor(self, q10_factor): self.q10_factor = q10_factor
    def getExperimental_temp(self): return self.experimental_temp
    def setExperimental_temp(self, experimental_temp): self.experimental_temp = experimental_temp
    def export(self, outfile, level, namespace_='', name_='Q10Settings', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Q10Settings')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Q10Settings'):
        if self.fixed_q10 is not None and 'fixed_q10' not in already_processed:
            already_processed.append('fixed_q10')
            outfile.write(' fixed_q10="%s"' % self.gds_format_double(self.fixed_q10, input_name='fixed_q10'))
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding), input_name='gate'), ))
        if self.q10_factor is not None and 'q10_factor' not in already_processed:
            already_processed.append('q10_factor')
            outfile.write(' q10_factor="%s"' % self.gds_format_double(self.q10_factor, input_name='q10_factor'))
        if self.experimental_temp is not None and 'experimental_temp' not in already_processed:
            already_processed.append('experimental_temp')
            outfile.write(' experimental_temp=%s' % (quote_attrib(self.experimental_temp), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Q10Settings', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Q10Settings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fixed_q10 is not None and 'fixed_q10' not in already_processed:
            already_processed.append('fixed_q10')
            showIndent(outfile, level)
            outfile.write('fixed_q10 = %e,\n' % (self.fixed_q10,))
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.q10_factor is not None and 'q10_factor' not in already_processed:
            already_processed.append('q10_factor')
            showIndent(outfile, level)
            outfile.write('q10_factor = %e,\n' % (self.q10_factor,))
        if self.experimental_temp is not None and 'experimental_temp' not in already_processed:
            already_processed.append('experimental_temp')
            showIndent(outfile, level)
            outfile.write('experimental_temp = %s,\n' % (self.experimental_temp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fixed_q10', node)
        if value is not None and 'fixed_q10' not in already_processed:
            already_processed.append('fixed_q10')
            try:
                self.fixed_q10 = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (fixed_q10): %s' % exp)
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('q10_factor', node)
        if value is not None and 'q10_factor' not in already_processed:
            already_processed.append('q10_factor')
            try:
                self.q10_factor = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (q10_factor): %s' % exp)
        value = find_attr_value_('experimental_temp', node)
        if value is not None and 'experimental_temp' not in already_processed:
            already_processed.append('experimental_temp')
            self.experimental_temp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Q10Settings


class Deprecated_Ion(GeneratedsSuper):
    """Definition of an ion which is involved in this channel mechanism.
    Note: deprecated since v1.7.3Simple name for the ion. Due to the
    conventions used in NEURON, it is usually best to use the lower
    case form of the chemical symbol, e.g. na, ca, kMost
    implementations of these channel mechanisms (e.g. a mod file)
    will need a value for the reversal potential for the ion which
    flows through the channel. However, this is a property of the
    cell, as opposed to the channel. For convenience though, a
    typical value can be used here, so a pretty self contained
    script can be produced, but when used in a real cell the actual
    value for erev must be calculatedElectrical charge of the ion in
    questionWhat role the ion plays in the dynamics of the
    channel/cell mechanism"""
    subclass = None
    superclass = None
    def __init__(self, charge=None, role='PermeatedSubstance', name=None, default_erev=None, notes=None, properties=None, annotation=None, group=None):
        self.charge = _cast(int, charge)
        self.role = _cast(None, role)
        self.name = _cast(None, name)
        self.default_erev = _cast(None, default_erev)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if Deprecated_Ion.subclass:
            return Deprecated_Ion.subclass(*args_, **kwargs_)
        else:
            return Deprecated_Ion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getCharge(self): return self.charge
    def setCharge(self, charge): self.charge = charge
    def getRole(self): return self.role
    def setRole(self, role): self.role = role
    def validate_Deprecated_IonRole(self, value):
        # Validate type Deprecated_IonRole, a restriction on xs:string.
        pass
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getDefault_erev(self): return self.default_erev
    def setDefault_erev(self, default_erev): self.default_erev = default_erev
    def export(self, outfile, level, namespace_='', name_='Deprecated_Ion', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_Ion')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_Ion'):
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            outfile.write(' charge="%s"' % self.gds_format_integer(self.charge, input_name='charge'))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.default_erev is not None and 'default_erev' not in already_processed:
            already_processed.append('default_erev')
            outfile.write(' default_erev=%s' % (quote_attrib(self.default_erev), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_Ion', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_Ion'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            showIndent(outfile, level)
            outfile.write('charge = %d,\n' % (self.charge,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.default_erev is not None and 'default_erev' not in already_processed:
            already_processed.append('default_erev')
            showIndent(outfile, level)
            outfile.write('default_erev = %s,\n' % (self.default_erev,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('charge', node)
        if value is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            try:
                self.charge = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.charge <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
            self.validate_Deprecated_IonRole(self.role)    # validate type Deprecated_IonRole
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('default_erev', node)
        if value is not None and 'default_erev' not in already_processed:
            already_processed.append('default_erev')
            self.default_erev = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
# end class Deprecated_Ion


class GatingComplex(GeneratedsSuper):
    """Preferred element for defining a gate since v1.7.3. Definition of a
    single voltage/concentration dependent gate, with explicit
    definition of open and closed states and information on the
    transition rates between them.Reference for the gating complex,
    e.g. m, h, nThe number of instances of the gate, i.e. the power
    to which the gating variable is raised in the expression for the
    total conductance"""
    subclass = None
    superclass = None
    def __init__(self, instances=None, name=None, closed_state=None, open_state=None, initialisation=None, transition=None, time_course=None, steady_state=None):
        self.instances = _cast(int, instances)
        self.name = _cast(None, name)
        if closed_state is None:
            self.closed_state = []
        else:
            self.closed_state = closed_state
        if open_state is None:
            self.open_state = []
        else:
            self.open_state = open_state
        self.initialisation = initialisation
        if transition is None:
            self.transition = []
        else:
            self.transition = transition
        if time_course is None:
            self.time_course = []
        else:
            self.time_course = time_course
        if steady_state is None:
            self.steady_state = []
        else:
            self.steady_state = steady_state
    def factory(*args_, **kwargs_):
        if GatingComplex.subclass:
            return GatingComplex.subclass(*args_, **kwargs_)
        else:
            return GatingComplex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getClosed_state(self): return self.closed_state
    def setClosed_state(self, closed_state): self.closed_state = closed_state
    def addClosed_state(self, value): self.closed_state.append(value)
    def insertClosed_state(self, index, value): self.closed_state[index] = value
    def getOpen_state(self): return self.open_state
    def setOpen_state(self, open_state): self.open_state = open_state
    def addOpen_state(self, value): self.open_state.append(value)
    def insertOpen_state(self, index, value): self.open_state[index] = value
    def getInitialisation(self): return self.initialisation
    def setInitialisation(self, initialisation): self.initialisation = initialisation
    def getTransition(self): return self.transition
    def setTransition(self, transition): self.transition = transition
    def addTransition(self, value): self.transition.append(value)
    def insertTransition(self, index, value): self.transition[index] = value
    def getTime_course(self): return self.time_course
    def setTime_course(self, time_course): self.time_course = time_course
    def addTime_course(self, value): self.time_course.append(value)
    def insertTime_course(self, index, value): self.time_course[index] = value
    def getSteady_state(self): return self.steady_state
    def setSteady_state(self, steady_state): self.steady_state = steady_state
    def addSteady_state(self, value): self.steady_state.append(value)
    def insertSteady_state(self, index, value): self.steady_state[index] = value
    def getInstances(self): return self.instances
    def setInstances(self, instances): self.instances = instances
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='GatingComplex', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatingComplex')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatingComplex'):
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GatingComplex', fromsubclass_=False):
        for closed_state_ in self.closed_state:
            closed_state_.export(outfile, level, namespace_, name_='closed_state')
        for open_state_ in self.open_state:
            open_state_.export(outfile, level, namespace_, name_='open_state')
        if self.initialisation is not None:
            self.initialisation.export(outfile, level, namespace_, name_='initialisation')
        for transition_ in self.transition:
            transition_.export(outfile, level, namespace_, name_='transition')
        for time_course_ in self.time_course:
            time_course_.export(outfile, level, namespace_, name_='time_course')
        for steady_state_ in self.steady_state:
            steady_state_.export(outfile, level, namespace_, name_='steady_state')
    def hasContent_(self):
        if (
            self.closed_state or
            self.open_state or
            self.initialisation is not None or
            self.transition or
            self.time_course or
            self.steady_state
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GatingComplex'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            showIndent(outfile, level)
            outfile.write('instances = %d,\n' % (self.instances,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('closed_state=[\n')
        level += 1
        for closed_state_ in self.closed_state:
            showIndent(outfile, level)
            outfile.write('model_.ClosedState(\n')
            closed_state_.exportLiteral(outfile, level, name_='ClosedState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('open_state=[\n')
        level += 1
        for open_state_ in self.open_state:
            showIndent(outfile, level)
            outfile.write('model_.OpenState(\n')
            open_state_.exportLiteral(outfile, level, name_='OpenState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.initialisation is not None:
            showIndent(outfile, level)
            outfile.write('initialisation=model_.Initialisation(\n')
            self.initialisation.exportLiteral(outfile, level, name_='initialisation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('transition=[\n')
        level += 1
        for transition_ in self.transition:
            showIndent(outfile, level)
            outfile.write('model_.Transition(\n')
            transition_.exportLiteral(outfile, level, name_='Transition')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('time_course=[\n')
        level += 1
        for time_course_ in self.time_course:
            showIndent(outfile, level)
            outfile.write('model_.TimeCourse(\n')
            time_course_.exportLiteral(outfile, level, name_='TimeCourse')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('steady_state=[\n')
        level += 1
        for steady_state_ in self.steady_state:
            showIndent(outfile, level)
            outfile.write('model_.SteadyState(\n')
            steady_state_.exportLiteral(outfile, level, name_='SteadyState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            try:
                self.instances = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.instances < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'closed_state':
            obj_ = ClosedState.factory()
            obj_.build(child_)
            self.closed_state.append(obj_)
        elif nodeName_ == 'open_state':
            obj_ = OpenState.factory()
            obj_.build(child_)
            self.open_state.append(obj_)
        elif nodeName_ == 'initialisation':
            obj_ = Initialisation.factory()
            obj_.build(child_)
            self.setInitialisation(obj_)
        elif nodeName_ == 'transition':
            obj_ = Transition.factory()
            obj_.build(child_)
            self.transition.append(obj_)
        elif nodeName_ == 'time_course':
            obj_ = TimeCourse.factory()
            obj_.build(child_)
            self.time_course.append(obj_)
        elif nodeName_ == 'steady_state':
            obj_ = SteadyState.factory()
            obj_.build(child_)
            self.steady_state.append(obj_)
# end class GatingComplex


class ClosedState(GeneratedsSuper):
    """Closed state of a gating complexId to use in transition elements
    when specifying this as the from or to state of the transition."""
    subclass = None
    superclass = None
    def __init__(self, id=None):
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if ClosedState.subclass:
            return ClosedState.subclass(*args_, **kwargs_)
        else:
            return ClosedState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='ClosedState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClosedState')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClosedState'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClosedState', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClosedState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClosedState


class OpenState(GeneratedsSuper):
    """Open state of a gating complexId to use in transition elements when
    specifying this as the from or to state of the transition.The
    fractional conductance of the gate in this state. Has value 1 if
    not present"""
    subclass = None
    superclass = None
    def __init__(self, id=None, fraction='1'):
        self.id = _cast(None, id)
        self.fraction = _cast(None, fraction)
        pass
    def factory(*args_, **kwargs_):
        if OpenState.subclass:
            return OpenState.subclass(*args_, **kwargs_)
        else:
            return OpenState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def getFraction(self): return self.fraction
    def setFraction(self, fraction): self.fraction = fraction
    def export(self, outfile, level, namespace_='', name_='OpenState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OpenState')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OpenState'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.fraction is not None and 'fraction' not in already_processed:
            already_processed.append('fraction')
            outfile.write(' fraction=%s' % (quote_attrib(self.fraction), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OpenState', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OpenState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.fraction is not None and 'fraction' not in already_processed:
            already_processed.append('fraction')
            showIndent(outfile, level)
            outfile.write('fraction = %s,\n' % (self.fraction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('fraction', node)
        if value is not None and 'fraction' not in already_processed:
            already_processed.append('fraction')
            self.fraction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OpenState


class Gate(GeneratedsSuper):
    """Definition of a single voltage/concentration dependent gateThe power
    to which the gate is raised in the expression for the total
    conductance"""
    subclass = None
    superclass = None
    def __init__(self, power=None, state=None):
        self.power = _cast(int, power)
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if Gate.subclass:
            return Gate.subclass(*args_, **kwargs_)
        else:
            return Gate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getState(self): return self.state
    def setState(self, state): self.state = state
    def addState(self, value): self.state.append(value)
    def insertState(self, index, value): self.state[index] = value
    def getPower(self): return self.power
    def setPower(self, power): self.power = power
    def export(self, outfile, level, namespace_='', name_='Gate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Gate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Gate'):
        if self.power is not None and 'power' not in already_processed:
            already_processed.append('power')
            outfile.write(' power="%s"' % self.gds_format_integer(self.power, input_name='power'))
    def exportChildren(self, outfile, level, namespace_='', name_='Gate', fromsubclass_=False):
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.state
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Gate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.power is not None and 'power' not in already_processed:
            already_processed.append('power')
            showIndent(outfile, level)
            outfile.write('power = %d,\n' % (self.power,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.stateType(\n')
            state_.exportLiteral(outfile, level, name_='stateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('power', node)
        if value is not None and 'power' not in already_processed:
            already_processed.append('power')
            try:
                self.power = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.power < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state':
            obj_ = stateType.factory()
            obj_.build(child_)
            self.state.append(obj_)
# end class Gate


class Deprecated_HHGate(GeneratedsSuper):
    """Gate with Hodgkin Huxley like state transitions"""
    subclass = None
    superclass = None
    def __init__(self, state=None, transition=None):
        self.state = _cast(None, state)
        self.transition = transition
    def factory(*args_, **kwargs_):
        if Deprecated_HHGate.subclass:
            return Deprecated_HHGate.subclass(*args_, **kwargs_)
        else:
            return Deprecated_HHGate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTransition(self): return self.transition
    def setTransition(self, transition): self.transition = transition
    def getState(self): return self.state
    def setState(self, state): self.state = state
    def export(self, outfile, level, namespace_='', name_='Deprecated_HHGate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_HHGate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_HHGate'):
        if self.state is not None and 'state' not in already_processed:
            already_processed.append('state')
            outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_HHGate', fromsubclass_=False):
        if self.transition is not None:
            self.transition.export(outfile, level, namespace_, name_='transition', )
    def hasContent_(self):
        if (
            self.transition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_HHGate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.state is not None and 'state' not in already_processed:
            already_processed.append('state')
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.transition is not None:
            showIndent(outfile, level)
            outfile.write('transition=model_.Deprecated_Transition(\n')
            self.transition.exportLiteral(outfile, level, name_='transition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.append('state')
            self.state = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transition':
            obj_ = Deprecated_Transition.factory()
            obj_.build(child_)
            self.setTransition(obj_)
# end class Deprecated_HHGate


class Deprecated_KSGate(GeneratedsSuper):
    """Gate with kinetic scheme transitions"""
    subclass = None
    superclass = None
    def __init__(self, state=None, transition=None):
        if state is None:
            self.state = []
        else:
            self.state = state
        if transition is None:
            self.transition = []
        else:
            self.transition = transition
    def factory(*args_, **kwargs_):
        if Deprecated_KSGate.subclass:
            return Deprecated_KSGate.subclass(*args_, **kwargs_)
        else:
            return Deprecated_KSGate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getState(self): return self.state
    def setState(self, state): self.state = state
    def addState(self, value): self.state.append(value)
    def insertState(self, index, value): self.state[index] = value
    def getTransition(self): return self.transition
    def setTransition(self, transition): self.transition = transition
    def addTransition(self, value): self.transition.append(value)
    def insertTransition(self, index, value): self.transition[index] = value
    def export(self, outfile, level, namespace_='', name_='Deprecated_KSGate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_KSGate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_KSGate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_KSGate', fromsubclass_=False):
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
        for transition_ in self.transition:
            transition_.export(outfile, level, namespace_, name_='transition')
    def hasContent_(self):
        if (
            self.state or
            self.transition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_KSGate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_KSState(\n')
            state_.exportLiteral(outfile, level, name_='Deprecated_KSState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transition=[\n')
        level += 1
        for transition_ in self.transition:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_Transition(\n')
            transition_.exportLiteral(outfile, level, name_='Deprecated_Transition')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state':
            obj_ = Deprecated_KSState.factory()
            obj_.build(child_)
            self.state.append(obj_)
        elif nodeName_ == 'transition':
            obj_ = Deprecated_Transition.factory()
            obj_.build(child_)
            self.transition.append(obj_)
# end class Deprecated_KSGate


class Deprecated_KSState(GeneratedsSuper):
    """Single kinetic scheme state. Transitions will happen between these
    states. Deprecated! Will be removed in v2.0"""
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if Deprecated_KSState.subclass:
            return Deprecated_KSState.subclass(*args_, **kwargs_)
        else:
            return Deprecated_KSState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Deprecated_KSState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_KSState')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_KSState'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_KSState', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_KSState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Deprecated_KSState


class Transition(GeneratedsSuper):
    """Transition between states in a GatingComplexShort name to use to
    refer to the transition, e.g. alpha, beta for forward, backward
    rates in HH gatesForm of expression"""
    subclass = None
    superclass = None
    def __init__(self, scale=None, fromxx=None, name=None, expr=None, midpoint=None, to=None, rate=None, expr_form=None):
        self.scale = _cast(None, scale)
        self.fromxx = _cast(None, fromxx)
        self.name = _cast(None, name)
        self.expr = _cast(None, expr)
        self.midpoint = _cast(None, midpoint)
        self.to = _cast(None, to)
        self.rate = _cast(None, rate)
        self.expr_form = _cast(None, expr_form)
        pass
    def factory(*args_, **kwargs_):
        if Transition.subclass:
            return Transition.subclass(*args_, **kwargs_)
        else:
            return Transition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getScale(self): return self.scale
    def setScale(self, scale): self.scale = scale
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def getMidpoint(self): return self.midpoint
    def setMidpoint(self, midpoint): self.midpoint = midpoint
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def getRate(self): return self.rate
    def setRate(self, rate): self.rate = rate
    def getExpr_form(self): return self.expr_form
    def setExpr_form(self, expr_form): self.expr_form = expr_form
    def validate_CoreEquationType(self, value):
        # Validate type CoreEquationType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Transition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Transition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Transition'):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale).encode(ExternalEncoding), input_name='scale'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            outfile.write(' midpoint=%s' % (self.gds_format_string(quote_attrib(self.midpoint).encode(ExternalEncoding), input_name='midpoint'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            outfile.write(' rate=%s' % (self.gds_format_string(quote_attrib(self.rate).encode(ExternalEncoding), input_name='rate'), ))
        if self.expr_form is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            outfile.write(' expr_form=%s' % (quote_attrib(self.expr_form), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Transition', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Transition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            showIndent(outfile, level)
            outfile.write('scale = "%s",\n' % (self.scale,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            showIndent(outfile, level)
            outfile.write('midpoint = "%s",\n' % (self.midpoint,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            showIndent(outfile, level)
            outfile.write('rate = "%s",\n' % (self.rate,))
        if self.expr_form is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            showIndent(outfile, level)
            outfile.write('expr_form = "%s",\n' % (self.expr_form,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            self.scale = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
        value = find_attr_value_('midpoint', node)
        if value is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            self.midpoint = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            self.rate = value
        value = find_attr_value_('expr_form', node)
        if value is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            self.expr_form = value
            self.validate_CoreEquationType(self.expr_form)    # validate type CoreEquationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Transition


class TimeCourse(GeneratedsSuper):
    """Time course of the transition between states in a GatingComplexShort
    name to use to refer to the time course e.g. tauForm of
    expression"""
    subclass = None
    superclass = None
    def __init__(self, scale=None, fromxx=None, name=None, expr=None, midpoint=None, to=None, rate=None, expr_form=None):
        self.scale = _cast(None, scale)
        self.fromxx = _cast(None, fromxx)
        self.name = _cast(None, name)
        self.expr = _cast(None, expr)
        self.midpoint = _cast(None, midpoint)
        self.to = _cast(None, to)
        self.rate = _cast(None, rate)
        self.expr_form = _cast(None, expr_form)
        pass
    def factory(*args_, **kwargs_):
        if TimeCourse.subclass:
            return TimeCourse.subclass(*args_, **kwargs_)
        else:
            return TimeCourse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getScale(self): return self.scale
    def setScale(self, scale): self.scale = scale
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def getMidpoint(self): return self.midpoint
    def setMidpoint(self, midpoint): self.midpoint = midpoint
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def getRate(self): return self.rate
    def setRate(self, rate): self.rate = rate
    def getExpr_form(self): return self.expr_form
    def setExpr_form(self, expr_form): self.expr_form = expr_form
    def validate_CoreEquationType(self, value):
        # Validate type CoreEquationType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='TimeCourse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCourse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCourse'):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale).encode(ExternalEncoding), input_name='scale'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            outfile.write(' midpoint=%s' % (self.gds_format_string(quote_attrib(self.midpoint).encode(ExternalEncoding), input_name='midpoint'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            outfile.write(' rate=%s' % (self.gds_format_string(quote_attrib(self.rate).encode(ExternalEncoding), input_name='rate'), ))
        if self.expr_form is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            outfile.write(' expr_form=%s' % (quote_attrib(self.expr_form), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCourse', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCourse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            showIndent(outfile, level)
            outfile.write('scale = "%s",\n' % (self.scale,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            showIndent(outfile, level)
            outfile.write('midpoint = "%s",\n' % (self.midpoint,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            showIndent(outfile, level)
            outfile.write('rate = "%s",\n' % (self.rate,))
        if self.expr_form is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            showIndent(outfile, level)
            outfile.write('expr_form = "%s",\n' % (self.expr_form,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            self.scale = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
        value = find_attr_value_('midpoint', node)
        if value is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            self.midpoint = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            self.rate = value
        value = find_attr_value_('expr_form', node)
        if value is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            self.expr_form = value
            self.validate_CoreEquationType(self.expr_form)    # validate type CoreEquationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeCourse


class SteadyState(GeneratedsSuper):
    """Steady state value of the transition between states in a
    GatingComplexShort name to use to refer to the steady state e.g.
    infForm of expression"""
    subclass = None
    superclass = None
    def __init__(self, scale=None, fromxx=None, name=None, expr=None, midpoint=None, to=None, rate=None, expr_form=None):
        self.scale = _cast(None, scale)
        self.fromxx = _cast(None, fromxx)
        self.name = _cast(None, name)
        self.expr = _cast(None, expr)
        self.midpoint = _cast(None, midpoint)
        self.to = _cast(None, to)
        self.rate = _cast(None, rate)
        self.expr_form = _cast(None, expr_form)
        pass
    def factory(*args_, **kwargs_):
        if SteadyState.subclass:
            return SteadyState.subclass(*args_, **kwargs_)
        else:
            return SteadyState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getScale(self): return self.scale
    def setScale(self, scale): self.scale = scale
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def getMidpoint(self): return self.midpoint
    def setMidpoint(self, midpoint): self.midpoint = midpoint
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def getRate(self): return self.rate
    def setRate(self, rate): self.rate = rate
    def getExpr_form(self): return self.expr_form
    def setExpr_form(self, expr_form): self.expr_form = expr_form
    def validate_CoreEquationType(self, value):
        # Validate type CoreEquationType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='SteadyState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SteadyState')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SteadyState'):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale).encode(ExternalEncoding), input_name='scale'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            outfile.write(' midpoint=%s' % (self.gds_format_string(quote_attrib(self.midpoint).encode(ExternalEncoding), input_name='midpoint'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            outfile.write(' rate=%s' % (self.gds_format_string(quote_attrib(self.rate).encode(ExternalEncoding), input_name='rate'), ))
        if self.expr_form is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            outfile.write(' expr_form=%s' % (quote_attrib(self.expr_form), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SteadyState', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SteadyState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            showIndent(outfile, level)
            outfile.write('scale = "%s",\n' % (self.scale,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            showIndent(outfile, level)
            outfile.write('midpoint = "%s",\n' % (self.midpoint,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            showIndent(outfile, level)
            outfile.write('rate = "%s",\n' % (self.rate,))
        if self.expr_form is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            showIndent(outfile, level)
            outfile.write('expr_form = "%s",\n' % (self.expr_form,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.append('scale')
            self.scale = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
        value = find_attr_value_('midpoint', node)
        if value is not None and 'midpoint' not in already_processed:
            already_processed.append('midpoint')
            self.midpoint = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.append('rate')
            self.rate = value
        value = find_attr_value_('expr_form', node)
        if value is not None and 'expr_form' not in already_processed:
            already_processed.append('expr_form')
            self.expr_form = value
            self.validate_CoreEquationType(self.expr_form)    # validate type CoreEquationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SteadyState


class Deprecated_Transition(GeneratedsSuper):
    """Deprecated since v1.7.3. What causes the gate to open and close. A
    dependence on potential difference, or a voltage and (ion)
    concentration dependenceSource state of the transition if used
    in kinetic scheme. Must be used with attribute target. Use this
    in preference to src!!!Target state of the transition if used in
    kinetic scheme. Must be used with attribute src"""
    subclass = None
    superclass = None
    def __init__(self, source=None, target=None, voltage_gate=None, voltage_conc_gate=None):
        self.source = _cast(None, source)
        self.target = _cast(None, target)
        self.voltage_gate = voltage_gate
        self.voltage_conc_gate = voltage_conc_gate
    def factory(*args_, **kwargs_):
        if Deprecated_Transition.subclass:
            return Deprecated_Transition.subclass(*args_, **kwargs_)
        else:
            return Deprecated_Transition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVoltage_gate(self): return self.voltage_gate
    def setVoltage_gate(self, voltage_gate): self.voltage_gate = voltage_gate
    def getVoltage_conc_gate(self): return self.voltage_conc_gate
    def setVoltage_conc_gate(self, voltage_conc_gate): self.voltage_conc_gate = voltage_conc_gate
    def getSource(self): return self.source
    def setSource(self, source): self.source = source
    def getTarget(self): return self.target
    def setTarget(self, target): self.target = target
    def export(self, outfile, level, namespace_='', name_='Deprecated_Transition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_Transition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_Transition'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.append('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding), input_name='source'), ))
        if self.target is not None and 'target' not in already_processed:
            already_processed.append('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_Transition', fromsubclass_=False):
        if self.voltage_gate is not None:
            self.voltage_gate.export(outfile, level, namespace_, name_='voltage_gate', )
        if self.voltage_conc_gate is not None:
            self.voltage_conc_gate.export(outfile, level, namespace_, name_='voltage_conc_gate', )
    def hasContent_(self):
        if (
            self.voltage_gate is not None or
            self.voltage_conc_gate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_Transition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source is not None and 'source' not in already_processed:
            already_processed.append('source')
            showIndent(outfile, level)
            outfile.write('source = "%s",\n' % (self.source,))
        if self.target is not None and 'target' not in already_processed:
            already_processed.append('target')
            showIndent(outfile, level)
            outfile.write('target = "%s",\n' % (self.target,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.voltage_gate is not None:
            showIndent(outfile, level)
            outfile.write('voltage_gate=model_.Deprecated_VoltageGate(\n')
            self.voltage_gate.exportLiteral(outfile, level, name_='voltage_gate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.voltage_conc_gate is not None:
            showIndent(outfile, level)
            outfile.write('voltage_conc_gate=model_.Deprecated_VoltageConcGate(\n')
            self.voltage_conc_gate.exportLiteral(outfile, level, name_='voltage_conc_gate')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.append('source')
            self.source = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.append('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'voltage_gate':
            obj_ = Deprecated_VoltageGate.factory()
            obj_.build(child_)
            self.setVoltage_gate(obj_)
        elif nodeName_ == 'voltage_conc_gate':
            obj_ = Deprecated_VoltageConcGate.factory()
            obj_.build(child_)
            self.setVoltage_conc_gate(obj_)
# end class Deprecated_Transition


class Initialisation(GeneratedsSuper):
    """Element added for *testing purposes only*. Used to "incorrectly"
    initialise a channel when trying to compare it to a mod file
    implementation (e.g. see Traub et al 2005 channels). Value here
    will be ignored if option in neuroConstruct "Force correct
    ChannelML init" is used. Use with caution!!"""
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if Initialisation.subclass:
            return Initialisation.subclass(*args_, **kwargs_)
        else:
            return Initialisation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='Initialisation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Initialisation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Initialisation'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Initialisation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Initialisation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Initialisation


class Deprecated_VoltageGate(GeneratedsSuper):
    """Definition of a voltage gate. Normally this will be specified as
    rate equations for alpha and beta, or for tau and inf.
    Deprecated! Will be removed in v2.0"""
    subclass = None
    superclass = None
    def __init__(self, initialisation=None, alpha=None, beta=None, gamma=None, zeta=None, tau=None, inf=None):
        self.initialisation = initialisation
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.zeta = zeta
        self.tau = tau
        self.inf = inf
    def factory(*args_, **kwargs_):
        if Deprecated_VoltageGate.subclass:
            return Deprecated_VoltageGate.subclass(*args_, **kwargs_)
        else:
            return Deprecated_VoltageGate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInitialisation(self): return self.initialisation
    def setInitialisation(self, initialisation): self.initialisation = initialisation
    def getAlpha(self): return self.alpha
    def setAlpha(self, alpha): self.alpha = alpha
    def getBeta(self): return self.beta
    def setBeta(self, beta): self.beta = beta
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def getZeta(self): return self.zeta
    def setZeta(self, zeta): self.zeta = zeta
    def getTau(self): return self.tau
    def setTau(self, tau): self.tau = tau
    def getInf(self): return self.inf
    def setInf(self, inf): self.inf = inf
    def export(self, outfile, level, namespace_='', name_='Deprecated_VoltageGate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_VoltageGate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_VoltageGate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_VoltageGate', fromsubclass_=False):
        if self.initialisation is not None:
            self.initialisation.export(outfile, level, namespace_, name_='initialisation')
        if self.alpha is not None:
            self.alpha.export(outfile, level, namespace_, name_='alpha')
        if self.beta is not None:
            self.beta.export(outfile, level, namespace_, name_='beta')
        if self.gamma is not None:
            self.gamma.export(outfile, level, namespace_, name_='gamma')
        if self.zeta is not None:
            self.zeta.export(outfile, level, namespace_, name_='zeta')
        if self.tau is not None:
            self.tau.export(outfile, level, namespace_, name_='tau')
        if self.inf is not None:
            self.inf.export(outfile, level, namespace_, name_='inf')
    def hasContent_(self):
        if (
            self.initialisation is not None or
            self.alpha is not None or
            self.beta is not None or
            self.gamma is not None or
            self.zeta is not None or
            self.tau is not None or
            self.inf is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_VoltageGate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.initialisation is not None:
            showIndent(outfile, level)
            outfile.write('initialisation=model_.Initialisation(\n')
            self.initialisation.exportLiteral(outfile, level, name_='initialisation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alpha is not None:
            showIndent(outfile, level)
            outfile.write('alpha=model_.Deprecated_RateConstantEqnChoice(\n')
            self.alpha.exportLiteral(outfile, level, name_='alpha')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.beta is not None:
            showIndent(outfile, level)
            outfile.write('beta=model_.Deprecated_RateConstantEqnChoice(\n')
            self.beta.exportLiteral(outfile, level, name_='beta')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gamma is not None:
            showIndent(outfile, level)
            outfile.write('gamma=model_.Deprecated_RateConstantEqnChoice(\n')
            self.gamma.exportLiteral(outfile, level, name_='gamma')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.zeta is not None:
            showIndent(outfile, level)
            outfile.write('zeta=model_.Deprecated_RateConstantEqnChoice(\n')
            self.zeta.exportLiteral(outfile, level, name_='zeta')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tau is not None:
            showIndent(outfile, level)
            outfile.write('tau=model_.Deprecated_RateConstantEqnChoice(\n')
            self.tau.exportLiteral(outfile, level, name_='tau')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.inf is not None:
            showIndent(outfile, level)
            outfile.write('inf=model_.Deprecated_RateConstantEqnChoice(\n')
            self.inf.exportLiteral(outfile, level, name_='inf')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialisation':
            obj_ = Initialisation.factory()
            obj_.build(child_)
            self.setInitialisation(obj_)
        elif nodeName_ == 'alpha':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setAlpha(obj_)
        elif nodeName_ == 'beta':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setBeta(obj_)
        elif nodeName_ == 'gamma':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setGamma(obj_)
        elif nodeName_ == 'zeta':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setZeta(obj_)
        elif nodeName_ == 'tau':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setTau(obj_)
        elif nodeName_ == 'inf':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setInf(obj_)
# end class Deprecated_VoltageGate


class Deprecated_VoltageConcGate(GeneratedsSuper):
    """Definition of a mechanics of a gate which depends on voltage and
    concentration (e.g. Calcium conc dependent K channel). Normally
    this will be specified as rate equations for alpha and beta (in
    terms of v and conc), or for tau and inf. Deprecated! Will be
    removed in v2.0"""
    subclass = None
    superclass = None
    def __init__(self, initialisation=None, conc_dependence=None, alpha=None, beta=None, gamma=None, zeta=None, tau=None, inf=None):
        self.initialisation = initialisation
        self.conc_dependence = conc_dependence
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.zeta = zeta
        self.tau = tau
        self.inf = inf
    def factory(*args_, **kwargs_):
        if Deprecated_VoltageConcGate.subclass:
            return Deprecated_VoltageConcGate.subclass(*args_, **kwargs_)
        else:
            return Deprecated_VoltageConcGate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInitialisation(self): return self.initialisation
    def setInitialisation(self, initialisation): self.initialisation = initialisation
    def getConc_dependence(self): return self.conc_dependence
    def setConc_dependence(self, conc_dependence): self.conc_dependence = conc_dependence
    def getAlpha(self): return self.alpha
    def setAlpha(self, alpha): self.alpha = alpha
    def getBeta(self): return self.beta
    def setBeta(self, beta): self.beta = beta
    def getGamma(self): return self.gamma
    def setGamma(self, gamma): self.gamma = gamma
    def getZeta(self): return self.zeta
    def setZeta(self, zeta): self.zeta = zeta
    def getTau(self): return self.tau
    def setTau(self, tau): self.tau = tau
    def getInf(self): return self.inf
    def setInf(self, inf): self.inf = inf
    def export(self, outfile, level, namespace_='', name_='Deprecated_VoltageConcGate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_VoltageConcGate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_VoltageConcGate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_VoltageConcGate', fromsubclass_=False):
        if self.initialisation is not None:
            self.initialisation.export(outfile, level, namespace_, name_='initialisation')
        if self.conc_dependence is not None:
            self.conc_dependence.export(outfile, level, namespace_, name_='conc_dependence', )
        if self.alpha is not None:
            self.alpha.export(outfile, level, namespace_, name_='alpha')
        if self.beta is not None:
            self.beta.export(outfile, level, namespace_, name_='beta')
        if self.gamma is not None:
            self.gamma.export(outfile, level, namespace_, name_='gamma')
        if self.zeta is not None:
            self.zeta.export(outfile, level, namespace_, name_='zeta')
        if self.tau is not None:
            self.tau.export(outfile, level, namespace_, name_='tau')
        if self.inf is not None:
            self.inf.export(outfile, level, namespace_, name_='inf')
    def hasContent_(self):
        if (
            self.initialisation is not None or
            self.conc_dependence is not None or
            self.alpha is not None or
            self.beta is not None or
            self.gamma is not None or
            self.zeta is not None or
            self.tau is not None or
            self.inf is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_VoltageConcGate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.initialisation is not None:
            showIndent(outfile, level)
            outfile.write('initialisation=model_.Initialisation(\n')
            self.initialisation.exportLiteral(outfile, level, name_='initialisation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.conc_dependence is not None:
            showIndent(outfile, level)
            outfile.write('conc_dependence=model_.ConcDependence(\n')
            self.conc_dependence.exportLiteral(outfile, level, name_='conc_dependence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alpha is not None:
            showIndent(outfile, level)
            outfile.write('alpha=model_.Deprecated_RateConstVoltConcDep(\n')
            self.alpha.exportLiteral(outfile, level, name_='alpha')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.beta is not None:
            showIndent(outfile, level)
            outfile.write('beta=model_.Deprecated_RateConstVoltConcDep(\n')
            self.beta.exportLiteral(outfile, level, name_='beta')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gamma is not None:
            showIndent(outfile, level)
            outfile.write('gamma=model_.Deprecated_RateConstantEqnChoice(\n')
            self.gamma.exportLiteral(outfile, level, name_='gamma')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.zeta is not None:
            showIndent(outfile, level)
            outfile.write('zeta=model_.Deprecated_RateConstantEqnChoice(\n')
            self.zeta.exportLiteral(outfile, level, name_='zeta')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tau is not None:
            showIndent(outfile, level)
            outfile.write('tau=model_.Deprecated_RateConstVoltConcDep(\n')
            self.tau.exportLiteral(outfile, level, name_='tau')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.inf is not None:
            showIndent(outfile, level)
            outfile.write('inf=model_.Deprecated_RateConstVoltConcDep(\n')
            self.inf.exportLiteral(outfile, level, name_='inf')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialisation':
            obj_ = Initialisation.factory()
            obj_.build(child_)
            self.setInitialisation(obj_)
        elif nodeName_ == 'conc_dependence':
            obj_ = ConcDependence.factory()
            obj_.build(child_)
            self.setConc_dependence(obj_)
        elif nodeName_ == 'alpha':
            obj_ = Deprecated_RateConstVoltConcDep.factory()
            obj_.build(child_)
            self.setAlpha(obj_)
        elif nodeName_ == 'beta':
            obj_ = Deprecated_RateConstVoltConcDep.factory()
            obj_.build(child_)
            self.setBeta(obj_)
        elif nodeName_ == 'gamma':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setGamma(obj_)
        elif nodeName_ == 'zeta':
            obj_ = Deprecated_RateConstantEqnChoice.factory()
            obj_.build(child_)
            self.setZeta(obj_)
        elif nodeName_ == 'tau':
            obj_ = Deprecated_RateConstVoltConcDep.factory()
            obj_.build(child_)
            self.setTau(obj_)
        elif nodeName_ == 'inf':
            obj_ = Deprecated_RateConstVoltConcDep.factory()
            obj_.build(child_)
            self.setInf(obj_)
# end class Deprecated_VoltageConcGate


class ConcFactor(GeneratedsSuper):
    """Specification of the time independent scaling factor for a
    concentration dependent conductance. This factor will not be
    used n alpha, beta, etc. but the expression in expr will scale
    the total conductance at each time step.Name of the
    ionElectrical charge of the ion in question. Assumes charge of 1
    if not presentHow the value of conductance will be expressed in
    the equationsExpression for the time independent multiplicative
    factor for the concentration dependenceMinimum expected
    concentration. May be needed by simulators (e.g. for generating
    tables)Maximum expected concentration. May be needed by
    simulators (e.g. for generating tables)"""
    subclass = None
    superclass = None
    def __init__(self, max_conc=None, expr=None, min_conc=None, ion=None, charge=1, variable_name=None):
        self.max_conc = _cast(None, max_conc)
        self.expr = _cast(None, expr)
        self.min_conc = _cast(None, min_conc)
        self.ion = _cast(None, ion)
        self.charge = _cast(int, charge)
        self.variable_name = _cast(None, variable_name)
        pass
    def factory(*args_, **kwargs_):
        if ConcFactor.subclass:
            return ConcFactor.subclass(*args_, **kwargs_)
        else:
            return ConcFactor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMax_conc(self): return self.max_conc
    def setMax_conc(self, max_conc): self.max_conc = max_conc
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def getMin_conc(self): return self.min_conc
    def setMin_conc(self, min_conc): self.min_conc = min_conc
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def getCharge(self): return self.charge
    def setCharge(self, charge): self.charge = charge
    def getVariable_name(self): return self.variable_name
    def setVariable_name(self, variable_name): self.variable_name = variable_name
    def export(self, outfile, level, namespace_='', name_='ConcFactor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConcFactor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConcFactor'):
        if self.max_conc is not None and 'max_conc' not in already_processed:
            already_processed.append('max_conc')
            outfile.write(' max_conc=%s' % (quote_attrib(self.max_conc), ))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
        if self.min_conc is not None and 'min_conc' not in already_processed:
            already_processed.append('min_conc')
            outfile.write(' min_conc=%s' % (quote_attrib(self.min_conc), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            outfile.write(' ion=%s' % (self.gds_format_string(quote_attrib(self.ion).encode(ExternalEncoding), input_name='ion'), ))
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            outfile.write(' charge="%s"' % self.gds_format_integer(self.charge, input_name='charge'))
        if self.variable_name is not None and 'variable_name' not in already_processed:
            already_processed.append('variable_name')
            outfile.write(' variable_name=%s' % (self.gds_format_string(quote_attrib(self.variable_name).encode(ExternalEncoding), input_name='variable_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConcFactor', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConcFactor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max_conc is not None and 'max_conc' not in already_processed:
            already_processed.append('max_conc')
            showIndent(outfile, level)
            outfile.write('max_conc = %s,\n' % (self.max_conc,))
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
        if self.min_conc is not None and 'min_conc' not in already_processed:
            already_processed.append('min_conc')
            showIndent(outfile, level)
            outfile.write('min_conc = %s,\n' % (self.min_conc,))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            showIndent(outfile, level)
            outfile.write('ion = "%s",\n' % (self.ion,))
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            showIndent(outfile, level)
            outfile.write('charge = %d,\n' % (self.charge,))
        if self.variable_name is not None and 'variable_name' not in already_processed:
            already_processed.append('variable_name')
            showIndent(outfile, level)
            outfile.write('variable_name = "%s",\n' % (self.variable_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_conc', node)
        if value is not None and 'max_conc' not in already_processed:
            already_processed.append('max_conc')
            self.max_conc = value
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
        value = find_attr_value_('min_conc', node)
        if value is not None and 'min_conc' not in already_processed:
            already_processed.append('min_conc')
            self.min_conc = value
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            self.ion = value
        value = find_attr_value_('charge', node)
        if value is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            try:
                self.charge = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('variable_name', node)
        if value is not None and 'variable_name' not in already_processed:
            already_processed.append('variable_name')
            self.variable_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConcFactor


class ConcDependence(GeneratedsSuper):
    """Specification of the factor to use in the concentration dependence
    of the rate expressions of a gateName of substance, just for
    referenceName of the ionElectrical charge of the ion in
    question. Assumes charge of 1 if not presentHow the value of
    conductance will be expressed in the rate equationsMinimum
    expected concentration. Quite likely to be needed by simulators
    (e.g. for generating tables)Maximum expected concentration.
    Quite likely to be needed by simulators (e.g. for generating
    tables)"""
    subclass = None
    superclass = None
    def __init__(self, max_conc=None, name=None, min_conc=None, ion=None, charge=1, variable_name=None):
        self.max_conc = _cast(None, max_conc)
        self.name = _cast(None, name)
        self.min_conc = _cast(None, min_conc)
        self.ion = _cast(None, ion)
        self.charge = _cast(int, charge)
        self.variable_name = _cast(None, variable_name)
        pass
    def factory(*args_, **kwargs_):
        if ConcDependence.subclass:
            return ConcDependence.subclass(*args_, **kwargs_)
        else:
            return ConcDependence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMax_conc(self): return self.max_conc
    def setMax_conc(self, max_conc): self.max_conc = max_conc
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getMin_conc(self): return self.min_conc
    def setMin_conc(self, min_conc): self.min_conc = min_conc
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def getCharge(self): return self.charge
    def setCharge(self, charge): self.charge = charge
    def getVariable_name(self): return self.variable_name
    def setVariable_name(self, variable_name): self.variable_name = variable_name
    def export(self, outfile, level, namespace_='', name_='ConcDependence', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConcDependence')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConcDependence'):
        if self.max_conc is not None and 'max_conc' not in already_processed:
            already_processed.append('max_conc')
            outfile.write(' max_conc=%s' % (quote_attrib(self.max_conc), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.min_conc is not None and 'min_conc' not in already_processed:
            already_processed.append('min_conc')
            outfile.write(' min_conc=%s' % (quote_attrib(self.min_conc), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            outfile.write(' ion=%s' % (self.gds_format_string(quote_attrib(self.ion).encode(ExternalEncoding), input_name='ion'), ))
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            outfile.write(' charge="%s"' % self.gds_format_integer(self.charge, input_name='charge'))
        if self.variable_name is not None and 'variable_name' not in already_processed:
            already_processed.append('variable_name')
            outfile.write(' variable_name=%s' % (self.gds_format_string(quote_attrib(self.variable_name).encode(ExternalEncoding), input_name='variable_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConcDependence', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConcDependence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max_conc is not None and 'max_conc' not in already_processed:
            already_processed.append('max_conc')
            showIndent(outfile, level)
            outfile.write('max_conc = %s,\n' % (self.max_conc,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.min_conc is not None and 'min_conc' not in already_processed:
            already_processed.append('min_conc')
            showIndent(outfile, level)
            outfile.write('min_conc = %s,\n' % (self.min_conc,))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            showIndent(outfile, level)
            outfile.write('ion = "%s",\n' % (self.ion,))
        if self.charge is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            showIndent(outfile, level)
            outfile.write('charge = %d,\n' % (self.charge,))
        if self.variable_name is not None and 'variable_name' not in already_processed:
            already_processed.append('variable_name')
            showIndent(outfile, level)
            outfile.write('variable_name = "%s",\n' % (self.variable_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_conc', node)
        if value is not None and 'max_conc' not in already_processed:
            already_processed.append('max_conc')
            self.max_conc = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('min_conc', node)
        if value is not None and 'min_conc' not in already_processed:
            already_processed.append('min_conc')
            self.min_conc = value
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            self.ion = value
        value = find_attr_value_('charge', node)
        if value is not None and 'charge' not in already_processed:
            already_processed.append('charge')
            try:
                self.charge = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('variable_name', node)
        if value is not None and 'variable_name' not in already_processed:
            already_processed.append('variable_name')
            self.variable_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConcDependence


class Deprecated_RateConstantEqnChoice(GeneratedsSuper):
    """Choice of the various rate constant expressions allowed"""
    subclass = None
    superclass = None
    def __init__(self, notes=None, properties=None, annotation=None, group=None, parameterised_hh=None, generic_equation_hh=None, generic=None):
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.parameterised_hh = parameterised_hh
        self.generic_equation_hh = generic_equation_hh
        self.generic = generic
    def factory(*args_, **kwargs_):
        if Deprecated_RateConstantEqnChoice.subclass:
            return Deprecated_RateConstantEqnChoice.subclass(*args_, **kwargs_)
        else:
            return Deprecated_RateConstantEqnChoice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getParameterised_hh(self): return self.parameterised_hh
    def setParameterised_hh(self, parameterised_hh): self.parameterised_hh = parameterised_hh
    def getGeneric_equation_hh(self): return self.generic_equation_hh
    def setGeneric_equation_hh(self, generic_equation_hh): self.generic_equation_hh = generic_equation_hh
    def getGeneric(self): return self.generic
    def setGeneric(self, generic): self.generic = generic
    def export(self, outfile, level, namespace_='', name_='Deprecated_RateConstantEqnChoice', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_RateConstantEqnChoice')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_RateConstantEqnChoice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_RateConstantEqnChoice', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.parameterised_hh is not None:
            self.parameterised_hh.export(outfile, level, namespace_, name_='parameterised_hh', )
        if self.generic_equation_hh is not None:
            self.generic_equation_hh.export(outfile, level, namespace_, name_='generic_equation_hh', )
        if self.generic is not None:
            self.generic.export(outfile, level, namespace_, name_='generic', )
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.parameterised_hh is not None or
            self.generic_equation_hh is not None or
            self.generic is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_RateConstantEqnChoice'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.parameterised_hh is not None:
            showIndent(outfile, level)
            outfile.write('parameterised_hh=model_.Deprecated_AkdEquation(\n')
            self.parameterised_hh.exportLiteral(outfile, level, name_='parameterised_hh')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_equation_hh is not None:
            showIndent(outfile, level)
            outfile.write('generic_equation_hh=model_.Deprecated_GenericEquation(\n')
            self.generic_equation_hh.exportLiteral(outfile, level, name_='generic_equation_hh')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic is not None:
            showIndent(outfile, level)
            outfile.write('generic=model_.Deprecated_GenericEquation(\n')
            self.generic.exportLiteral(outfile, level, name_='generic')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'parameterised_hh':
            obj_ = Deprecated_AkdEquation.factory()
            obj_.build(child_)
            self.setParameterised_hh(obj_)
        elif nodeName_ == 'generic_equation_hh':
            obj_ = Deprecated_GenericEquation.factory()
            obj_.build(child_)
            self.setGeneric_equation_hh(obj_)
        elif nodeName_ == 'generic':
            obj_ = Deprecated_GenericEquation.factory()
            obj_.build(child_)
            self.setGeneric(obj_)
# end class Deprecated_RateConstantEqnChoice


class Deprecated_RateConstVoltConcDep(GeneratedsSuper):
    """Rate constant expressions allowed for voltage and conc dependent
    channels. Note, at this stage no Akd like expression for a
    generic voltage/conc dep experssion. Time will tell if there's
    an expression common enough across different models to be
    expressed in such a way"""
    subclass = None
    superclass = None
    def __init__(self, generic_equation_hh=None, generic=None):
        self.generic_equation_hh = generic_equation_hh
        self.generic = generic
    def factory(*args_, **kwargs_):
        if Deprecated_RateConstVoltConcDep.subclass:
            return Deprecated_RateConstVoltConcDep.subclass(*args_, **kwargs_)
        else:
            return Deprecated_RateConstVoltConcDep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGeneric_equation_hh(self): return self.generic_equation_hh
    def setGeneric_equation_hh(self, generic_equation_hh): self.generic_equation_hh = generic_equation_hh
    def getGeneric(self): return self.generic
    def setGeneric(self, generic): self.generic = generic
    def export(self, outfile, level, namespace_='', name_='Deprecated_RateConstVoltConcDep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_RateConstVoltConcDep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_RateConstVoltConcDep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_RateConstVoltConcDep', fromsubclass_=False):
        if self.generic_equation_hh is not None:
            self.generic_equation_hh.export(outfile, level, namespace_, name_='generic_equation_hh', )
        if self.generic is not None:
            self.generic.export(outfile, level, namespace_, name_='generic', )
    def hasContent_(self):
        if (
            self.generic_equation_hh is not None or
            self.generic is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_RateConstVoltConcDep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.generic_equation_hh is not None:
            showIndent(outfile, level)
            outfile.write('generic_equation_hh=model_.Deprecated_GenericEquation(\n')
            self.generic_equation_hh.exportLiteral(outfile, level, name_='generic_equation_hh')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic is not None:
            showIndent(outfile, level)
            outfile.write('generic=model_.Deprecated_GenericEquation(\n')
            self.generic.exportLiteral(outfile, level, name_='generic')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'generic_equation_hh':
            obj_ = Deprecated_GenericEquation.factory()
            obj_.build(child_)
            self.setGeneric_equation_hh(obj_)
        elif nodeName_ == 'generic':
            obj_ = Deprecated_GenericEquation.factory()
            obj_.build(child_)
            self.setGeneric(obj_)
# end class Deprecated_RateConstVoltConcDep


class Deprecated_RateConstantEqn(GeneratedsSuper):
    """Definition of a rate constant equation."""
    subclass = None
    superclass = None
    def __init__(self, expr=None, type_=None, parameter=None):
        self.expr = _cast(None, expr)
        self.type_ = _cast(None, type_)
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if Deprecated_RateConstantEqn.subclass:
            return Deprecated_RateConstantEqn.subclass(*args_, **kwargs_)
        else:
            return Deprecated_RateConstantEqn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='Deprecated_RateConstantEqn', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_RateConstantEqn')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_RateConstantEqn'):
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_RateConstantEqn', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
    def hasContent_(self):
        if (
            self.parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_RateConstantEqn'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_Parameter(\n')
            parameter_.exportLiteral(outfile, level, name_='Deprecated_Parameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = Deprecated_Parameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
# end class Deprecated_RateConstantEqn


class Deprecated_AkdEquation(Deprecated_RateConstantEqn):
    """Definition of a type of rate constant equation which takes
    parameters A, k, d and maps to either exponential, sigmoidal or
    linoidal.Note: this expression is has been useful to include
    when the type is, e.g. linoid, to remind users of the form of
    the equation. However, it's use should be discouraged, as it
    could be assumed that changing this attribute can change the
    form of the equation (as for generic_equation_hh). It's better
    to include the form of the equation as a comment, as in the
    examples. This attribute may be removed in v2.0"""
    subclass = None
    superclass = Deprecated_RateConstantEqn
    def __init__(self, expr=None, type_=None, parameter=None):
        super(Deprecated_AkdEquation, self).__init__(expr, type_, parameter, )
        self.expr = _cast(None, expr)
        self.type_ = _cast(None, type_)
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if Deprecated_AkdEquation.subclass:
            return Deprecated_AkdEquation.subclass(*args_, **kwargs_)
        else:
            return Deprecated_AkdEquation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def validate_Deprecated_CoreEquationType(self, value):
        # Validate type Deprecated_CoreEquationType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Deprecated_AkdEquation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_AkdEquation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_AkdEquation'):
        super(Deprecated_AkdEquation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_AkdEquation')
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_AkdEquation', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
    def hasContent_(self):
        if (
            self.parameter or
            super(Deprecated_AkdEquation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_AkdEquation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        super(Deprecated_AkdEquation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Deprecated_AkdEquation, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.Deprecated_Parameter(\n')
            parameter_.exportLiteral(outfile, level, name_='Deprecated_Parameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_Deprecated_CoreEquationType(self.type_)    # validate type Deprecated_CoreEquationType
        super(Deprecated_AkdEquation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = Deprecated_Parameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
# end class Deprecated_AkdEquation


class Deprecated_GenericEquation(GeneratedsSuper):
    """Definition of a type of rate constant equationNote: only variable
    allowed in expression is v (or for an expression for tau or inf,
    alpha and beta can be used too). Also, liberal use of brackets,
    e.g. 5.0*(exp (-50*(v +46))) instead of 5.0* exp (-50*(v +46))
    is advised, due to GENESIS's handling of exp, abs, etc."""
    subclass = None
    superclass = None
    def __init__(self, expr=None):
        self.expr = _cast(None, expr)
        pass
    def factory(*args_, **kwargs_):
        if Deprecated_GenericEquation.subclass:
            return Deprecated_GenericEquation.subclass(*args_, **kwargs_)
        else:
            return Deprecated_GenericEquation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExpr(self): return self.expr
    def setExpr(self, expr): self.expr = expr
    def export(self, outfile, level, namespace_='', name_='Deprecated_GenericEquation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_GenericEquation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_GenericEquation'):
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            outfile.write(' expr=%s' % (self.gds_format_string(quote_attrib(self.expr).encode(ExternalEncoding), input_name='expr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_GenericEquation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_GenericEquation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.expr is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            showIndent(outfile, level)
            outfile.write('expr = "%s",\n' % (self.expr,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expr', node)
        if value is not None and 'expr' not in already_processed:
            already_processed.append('expr')
            self.expr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Deprecated_GenericEquation


class IonConcentration(GeneratedsSuper):
    """Specification of how an ion concentration alters with time, e.g.
    calcium dynamics. This may influence other channels (e.g. Ca
    dependent K channels), and other mechanisms may have a
    contribution to the concentration of the ion specified here.A
    unique name for this ion concentration mechanism, as opposed to
    name of the ion used."""
    subclass = None
    superclass = None
    def __init__(self, name=None, status=None, notes=None, properties=None, annotation=None, group=None, authorList=None, publication=None, neuronDBref=None, modelDBref=None, neuroMorphoRef=None, ion_species=None, decaying_pool_model=None):
        self.name = _cast(None, name)
        self.status = status
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.authorList = authorList
        if publication is None:
            self.publication = []
        else:
            self.publication = publication
        if neuronDBref is None:
            self.neuronDBref = []
        else:
            self.neuronDBref = neuronDBref
        if modelDBref is None:
            self.modelDBref = []
        else:
            self.modelDBref = modelDBref
        if neuroMorphoRef is None:
            self.neuroMorphoRef = []
        else:
            self.neuroMorphoRef = neuroMorphoRef
        self.ion_species = ion_species
        self.decaying_pool_model = decaying_pool_model
    def factory(*args_, **kwargs_):
        if IonConcentration.subclass:
            return IonConcentration.subclass(*args_, **kwargs_)
        else:
            return IonConcentration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStatus(self): return self.status
    def setStatus(self, status): self.status = status
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getAuthorList(self): return self.authorList
    def setAuthorList(self, authorList): self.authorList = authorList
    def getPublication(self): return self.publication
    def setPublication(self, publication): self.publication = publication
    def addPublication(self, value): self.publication.append(value)
    def insertPublication(self, index, value): self.publication[index] = value
    def getNeuronDBref(self): return self.neuronDBref
    def setNeuronDBref(self, neuronDBref): self.neuronDBref = neuronDBref
    def addNeuronDBref(self, value): self.neuronDBref.append(value)
    def insertNeuronDBref(self, index, value): self.neuronDBref[index] = value
    def getModelDBref(self): return self.modelDBref
    def setModelDBref(self, modelDBref): self.modelDBref = modelDBref
    def addModelDBref(self, value): self.modelDBref.append(value)
    def insertModelDBref(self, index, value): self.modelDBref[index] = value
    def getNeuroMorphoRef(self): return self.neuroMorphoRef
    def setNeuroMorphoRef(self, neuroMorphoRef): self.neuroMorphoRef = neuroMorphoRef
    def addNeuroMorphoRef(self, value): self.neuroMorphoRef.append(value)
    def insertNeuroMorphoRef(self, index, value): self.neuroMorphoRef[index] = value
    def getIon_species(self): return self.ion_species
    def setIon_species(self, ion_species): self.ion_species = ion_species
    def getDecaying_pool_model(self): return self.decaying_pool_model
    def setDecaying_pool_model(self, decaying_pool_model): self.decaying_pool_model = decaying_pool_model
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='IonConcentration', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IonConcentration')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IonConcentration'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IonConcentration', fromsubclass_=False):
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.authorList is not None:
            self.authorList.export(outfile, level, namespace_, name_='authorList')
        for publication_ in self.publication:
            publication_.export(outfile, level, namespace_, name_='publication')
        for neuronDBref_ in self.neuronDBref:
            neuronDBref_.export(outfile, level, namespace_, name_='neuronDBref')
        for modelDBref_ in self.modelDBref:
            modelDBref_.export(outfile, level, namespace_, name_='modelDBref')
        for neuroMorphoRef_ in self.neuroMorphoRef:
            neuroMorphoRef_.export(outfile, level, namespace_, name_='neuroMorphoRef')
        if self.ion_species is not None:
            self.ion_species.export(outfile, level, namespace_, name_='ion_species', )
        if self.decaying_pool_model is not None:
            self.decaying_pool_model.export(outfile, level, namespace_, name_='decaying_pool_model', )
    def hasContent_(self):
        if (
            self.status is not None or
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.authorList is not None or
            self.publication or
            self.neuronDBref or
            self.modelDBref or
            self.neuroMorphoRef or
            self.ion_species is not None or
            self.decaying_pool_model is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IonConcentration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.Status(\n')
            self.status.exportLiteral(outfile, level, name_='status')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.authorList is not None:
            showIndent(outfile, level)
            outfile.write('authorList=model_.Authors(\n')
            self.authorList.exportLiteral(outfile, level, name_='authorList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('publication=[\n')
        level += 1
        for publication_ in self.publication:
            showIndent(outfile, level)
            outfile.write('model_.Publication(\n')
            publication_.exportLiteral(outfile, level, name_='Publication')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuronDBref=[\n')
        level += 1
        for neuronDBref_ in self.neuronDBref:
            showIndent(outfile, level)
            outfile.write('model_.NeuronDBReference(\n')
            neuronDBref_.exportLiteral(outfile, level, name_='NeuronDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelDBref=[\n')
        level += 1
        for modelDBref_ in self.modelDBref:
            showIndent(outfile, level)
            outfile.write('model_.ModelDBReference(\n')
            modelDBref_.exportLiteral(outfile, level, name_='ModelDBReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('neuroMorphoRef=[\n')
        level += 1
        for neuroMorphoRef_ in self.neuroMorphoRef:
            showIndent(outfile, level)
            outfile.write('model_.NeuroMorphoRef(\n')
            neuroMorphoRef_.exportLiteral(outfile, level, name_='NeuroMorphoRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ion_species is not None:
            showIndent(outfile, level)
            outfile.write('ion_species=model_.IonSpecies(\n')
            self.ion_species.exportLiteral(outfile, level, name_='ion_species')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.decaying_pool_model is not None:
            showIndent(outfile, level)
            outfile.write('decaying_pool_model=model_.DecayingPoolModel(\n')
            self.decaying_pool_model.exportLiteral(outfile, level, name_='decaying_pool_model')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = Status.factory()
            obj_.build(child_)
            self.setStatus(obj_)
        elif nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'authorList':
            obj_ = Authors.factory()
            obj_.build(child_)
            self.setAuthorList(obj_)
        elif nodeName_ == 'publication':
            obj_ = Publication.factory()
            obj_.build(child_)
            self.publication.append(obj_)
        elif nodeName_ == 'neuronDBref':
            obj_ = NeuronDBReference.factory()
            obj_.build(child_)
            self.neuronDBref.append(obj_)
        elif nodeName_ == 'modelDBref':
            obj_ = ModelDBReference.factory()
            obj_.build(child_)
            self.modelDBref.append(obj_)
        elif nodeName_ == 'neuroMorphoRef':
            obj_ = NeuroMorphoRef.factory()
            obj_.build(child_)
            self.neuroMorphoRef.append(obj_)
        elif nodeName_ == 'ion_species':
            obj_ = IonSpecies.factory()
            obj_.build(child_)
            self.setIon_species(obj_)
        elif nodeName_ == 'decaying_pool_model':
            obj_ = DecayingPoolModel.factory()
            obj_.build(child_)
            self.setDecaying_pool_model(obj_)
# end class IonConcentration


class IonSpecies(GeneratedsSuper):
    """Which ion is involved in an ion_concentration mechanism. Note in
    v2.0 the attribute form for defining the name will be required."""
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IonSpecies.subclass:
            return IonSpecies.subclass(*args_, **kwargs_)
        else:
            return IonSpecies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='IonSpecies', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IonSpecies')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IonSpecies'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IonSpecies', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IonSpecies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IonSpecies


class DecayingPoolModel(GeneratedsSuper):
    """Element for parameters in a decaying pool model of ion concentration
    (e.g. calcium pool)Resting concentration of ion. NOTE: In v2.0
    the option for a resting_conc element will be removed. Attribute
    resting_conc will be required instead.Exponential decay time of
    pool. Either decay_constant or inv_decay_constant must be
    included. NOTE: In v2.0 the option for a
    decay_constant/inv_decay_constant element will be removed.
    Attribute decay_constant/inv_decay_constant will be used
    instead.Reciprocal of exponential decay time of pool. Either
    decay_constant or inv_decay_constant must be included. NOTE: In
    v2.0 the option for a decay_constant/inv_decay_constant element
    will be removed. Attribute decay_constant/inv_decay_constant
    will be used instead.The maximum concentration which the ion
    pool should be allowed get to. NOTE: In v2.0 the option for a
    ceiling element will be removed. Attribute ceiling will be used
    instead."""
    subclass = None
    superclass = None
    def __init__(self, inv_decay_constant_attr=None, resting_conc_attr=None, decay_constant_attr=None, ceiling_attr=None, resting_conc=None, decay_constant=None, inv_decay_constant=None, ceiling=None, pool_volume_info=None, fixed_pool_info=None):
        self.inv_decay_constant_attr = _cast(None, inv_decay_constant_attr)
        self.resting_conc_attr = _cast(None, resting_conc_attr)
        self.decay_constant_attr = _cast(None, decay_constant_attr)
        self.ceiling_attr = _cast(None, ceiling_attr)
        self.resting_conc = resting_conc
        self.decay_constant = decay_constant
        self.inv_decay_constant = inv_decay_constant
        self.ceiling = ceiling
        self.pool_volume_info = pool_volume_info
        self.fixed_pool_info = fixed_pool_info
    def factory(*args_, **kwargs_):
        if DecayingPoolModel.subclass:
            return DecayingPoolModel.subclass(*args_, **kwargs_)
        else:
            return DecayingPoolModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getResting_conc(self): return self.resting_conc
    def setResting_conc(self, resting_conc): self.resting_conc = resting_conc
    def validate_ConcentrationValue(self, value):
        # Validate type ConcentrationValue, a restriction on xs:double.
        pass
    def getDecay_constant(self): return self.decay_constant
    def setDecay_constant(self, decay_constant): self.decay_constant = decay_constant
    def validate_TimeConstantValue(self, value):
        # Validate type TimeConstantValue, a restriction on xs:double.
        pass
    def getInv_decay_constant(self): return self.inv_decay_constant
    def setInv_decay_constant(self, inv_decay_constant): self.inv_decay_constant = inv_decay_constant
    def validate_InvTimeConstantValue(self, value):
        # Validate type InvTimeConstantValue, a restriction on xs:double.
        pass
    def getCeiling(self): return self.ceiling
    def setCeiling(self, ceiling): self.ceiling = ceiling
    def getPool_volume_info(self): return self.pool_volume_info
    def setPool_volume_info(self, pool_volume_info): self.pool_volume_info = pool_volume_info
    def getFixed_pool_info(self): return self.fixed_pool_info
    def setFixed_pool_info(self, fixed_pool_info): self.fixed_pool_info = fixed_pool_info
    def getInv_decay_constant_attr(self): return self.inv_decay_constant_attr
    def setInv_decay_constant_attr(self, inv_decay_constant_attr): self.inv_decay_constant_attr = inv_decay_constant_attr
    def getResting_conc_attr(self): return self.resting_conc_attr
    def setResting_conc_attr(self, resting_conc_attr): self.resting_conc_attr = resting_conc_attr
    def getDecay_constant_attr(self): return self.decay_constant_attr
    def setDecay_constant_attr(self, decay_constant_attr): self.decay_constant_attr = decay_constant_attr
    def getCeiling_attr(self): return self.ceiling_attr
    def setCeiling_attr(self, ceiling_attr): self.ceiling_attr = ceiling_attr
    def export(self, outfile, level, namespace_='', name_='DecayingPoolModel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DecayingPoolModel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DecayingPoolModel'):
        if self.inv_decay_constant_attr is not None and 'inv_decay_constant_attr' not in already_processed:
            already_processed.append('inv_decay_constant_attr')
            outfile.write(' inv_decay_constant_attr=%s' % (self.gds_format_string(quote_attrib(self.inv_decay_constant_attr).encode(ExternalEncoding), input_name='inv_decay_constant_attr'), ))
        if self.resting_conc_attr is not None and 'resting_conc_attr' not in already_processed:
            already_processed.append('resting_conc_attr')
            outfile.write(' resting_conc_attr=%s' % (self.gds_format_string(quote_attrib(self.resting_conc_attr).encode(ExternalEncoding), input_name='resting_conc_attr'), ))
        if self.decay_constant_attr is not None and 'decay_constant_attr' not in already_processed:
            already_processed.append('decay_constant_attr')
            outfile.write(' decay_constant_attr=%s' % (self.gds_format_string(quote_attrib(self.decay_constant_attr).encode(ExternalEncoding), input_name='decay_constant_attr'), ))
        if self.ceiling_attr is not None and 'ceiling_attr' not in already_processed:
            already_processed.append('ceiling_attr')
            outfile.write(' ceiling_attr=%s' % (self.gds_format_string(quote_attrib(self.ceiling_attr).encode(ExternalEncoding), input_name='ceiling_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DecayingPoolModel', fromsubclass_=False):
        if self.resting_conc is not None:
            showIndent(outfile, level)
            outfile.write('<%sresting_conc>%s</%sresting_conc>\n' % (namespace_, self.gds_format_double(self.resting_conc, input_name='resting_conc'), namespace_))
        if self.decay_constant is not None:
            showIndent(outfile, level)
            outfile.write('<%sdecay_constant>%s</%sdecay_constant>\n' % (namespace_, self.gds_format_double(self.decay_constant, input_name='decay_constant'), namespace_))
        if self.inv_decay_constant is not None:
            showIndent(outfile, level)
            outfile.write('<%sinv_decay_constant>%s</%sinv_decay_constant>\n' % (namespace_, self.gds_format_double(self.inv_decay_constant, input_name='inv_decay_constant'), namespace_))
        if self.ceiling is not None:
            showIndent(outfile, level)
            outfile.write('<%sceiling>%s</%sceiling>\n' % (namespace_, self.gds_format_double(self.ceiling, input_name='ceiling'), namespace_))
        if self.pool_volume_info is not None:
            self.pool_volume_info.export(outfile, level, namespace_, name_='pool_volume_info', )
        if self.fixed_pool_info is not None:
            self.fixed_pool_info.export(outfile, level, namespace_, name_='fixed_pool_info', )
    def hasContent_(self):
        if (
            self.resting_conc is not None or
            self.decay_constant is not None or
            self.inv_decay_constant is not None or
            self.ceiling is not None or
            self.pool_volume_info is not None or
            self.fixed_pool_info is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DecayingPoolModel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.inv_decay_constant_attr is not None and 'inv_decay_constant_attr' not in already_processed:
            already_processed.append('inv_decay_constant_attr')
            showIndent(outfile, level)
            outfile.write('inv_decay_constant_attr = "%s",\n' % (self.inv_decay_constant_attr,))
        if self.resting_conc_attr is not None and 'resting_conc_attr' not in already_processed:
            already_processed.append('resting_conc_attr')
            showIndent(outfile, level)
            outfile.write('resting_conc_attr = "%s",\n' % (self.resting_conc_attr,))
        if self.decay_constant_attr is not None and 'decay_constant_attr' not in already_processed:
            already_processed.append('decay_constant_attr')
            showIndent(outfile, level)
            outfile.write('decay_constant_attr = "%s",\n' % (self.decay_constant_attr,))
        if self.ceiling_attr is not None and 'ceiling_attr' not in already_processed:
            already_processed.append('ceiling_attr')
            showIndent(outfile, level)
            outfile.write('ceiling_attr = "%s",\n' % (self.ceiling_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resting_conc is not None:
            showIndent(outfile, level)
            outfile.write('resting_conc=%e,\n' % self.resting_conc)
        if self.decay_constant is not None:
            showIndent(outfile, level)
            outfile.write('decay_constant=%e,\n' % self.decay_constant)
        if self.inv_decay_constant is not None:
            showIndent(outfile, level)
            outfile.write('inv_decay_constant=%e,\n' % self.inv_decay_constant)
        if self.ceiling is not None:
            showIndent(outfile, level)
            outfile.write('ceiling=%e,\n' % self.ceiling)
        if self.pool_volume_info is not None:
            showIndent(outfile, level)
            outfile.write('pool_volume_info=model_.PoolVolumeInfo(\n')
            self.pool_volume_info.exportLiteral(outfile, level, name_='pool_volume_info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fixed_pool_info is not None:
            showIndent(outfile, level)
            outfile.write('fixed_pool_info=model_.FixedPoolInfo(\n')
            self.fixed_pool_info.exportLiteral(outfile, level, name_='fixed_pool_info')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inv_decay_constant_attr', node)
        if value is not None and 'inv_decay_constant_attr' not in already_processed:
            already_processed.append('inv_decay_constant_attr')
            self.inv_decay_constant_attr = value
        value = find_attr_value_('resting_conc_attr', node)
        if value is not None and 'resting_conc_attr' not in already_processed:
            already_processed.append('resting_conc_attr')
            self.resting_conc_attr = value
        value = find_attr_value_('decay_constant_attr', node)
        if value is not None and 'decay_constant_attr' not in already_processed:
            already_processed.append('decay_constant_attr')
            self.decay_constant_attr = value
        value = find_attr_value_('ceiling_attr', node)
        if value is not None and 'ceiling_attr' not in already_processed:
            already_processed.append('ceiling_attr')
            self.ceiling_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resting_conc':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'resting_conc')
            self.resting_conc = fval_
            self.validate_ConcentrationValue(self.resting_conc)    # validate type ConcentrationValue
        elif nodeName_ == 'decay_constant':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'decay_constant')
            self.decay_constant = fval_
            self.validate_TimeConstantValue(self.decay_constant)    # validate type TimeConstantValue
        elif nodeName_ == 'inv_decay_constant':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'inv_decay_constant')
            self.inv_decay_constant = fval_
            self.validate_InvTimeConstantValue(self.inv_decay_constant)    # validate type InvTimeConstantValue
        elif nodeName_ == 'ceiling':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ceiling')
            self.ceiling = fval_
            self.validate_ConcentrationValue(self.ceiling)    # validate type ConcentrationValue
        elif nodeName_ == 'pool_volume_info':
            obj_ = PoolVolumeInfo.factory()
            obj_.build(child_)
            self.setPool_volume_info(obj_)
        elif nodeName_ == 'fixed_pool_info':
            obj_ = FixedPoolInfo.factory()
            obj_.build(child_)
            self.setFixed_pool_info(obj_)
# end class DecayingPoolModel


class PoolVolumeInfo(GeneratedsSuper):
    """Information on the volume of the ion poolThe volume of the pool is
    calculated from the thickness of the shell inside the membrane.
    This will have to be multiplied by the surface area of the
    relevant compartment. NOTE: In v2.0 the option for a
    shell_thickness element will be removed. Attribute
    shell_thickness will be used instead."""
    subclass = None
    superclass = None
    def __init__(self, shell_thickness_attr=None, shell_thickness=None):
        self.shell_thickness_attr = _cast(None, shell_thickness_attr)
        self.shell_thickness = shell_thickness
    def factory(*args_, **kwargs_):
        if PoolVolumeInfo.subclass:
            return PoolVolumeInfo.subclass(*args_, **kwargs_)
        else:
            return PoolVolumeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getShell_thickness(self): return self.shell_thickness
    def setShell_thickness(self, shell_thickness): self.shell_thickness = shell_thickness
    def validate_LengthValue(self, value):
        # Validate type LengthValue, a restriction on xs:double.
        pass
    def getShell_thickness_attr(self): return self.shell_thickness_attr
    def setShell_thickness_attr(self, shell_thickness_attr): self.shell_thickness_attr = shell_thickness_attr
    def export(self, outfile, level, namespace_='', name_='PoolVolumeInfo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolVolumeInfo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PoolVolumeInfo'):
        if self.shell_thickness_attr is not None and 'shell_thickness_attr' not in already_processed:
            already_processed.append('shell_thickness_attr')
            outfile.write(' shell_thickness_attr=%s' % (self.gds_format_string(quote_attrib(self.shell_thickness_attr).encode(ExternalEncoding), input_name='shell_thickness_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PoolVolumeInfo', fromsubclass_=False):
        if self.shell_thickness is not None:
            showIndent(outfile, level)
            outfile.write('<%sshell_thickness>%s</%sshell_thickness>\n' % (namespace_, self.gds_format_double(self.shell_thickness, input_name='shell_thickness'), namespace_))
    def hasContent_(self):
        if (
            self.shell_thickness is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PoolVolumeInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.shell_thickness_attr is not None and 'shell_thickness_attr' not in already_processed:
            already_processed.append('shell_thickness_attr')
            showIndent(outfile, level)
            outfile.write('shell_thickness_attr = "%s",\n' % (self.shell_thickness_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.shell_thickness is not None:
            showIndent(outfile, level)
            outfile.write('shell_thickness=%e,\n' % self.shell_thickness)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shell_thickness_attr', node)
        if value is not None and 'shell_thickness_attr' not in already_processed:
            already_processed.append('shell_thickness_attr')
            self.shell_thickness_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'shell_thickness':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'shell_thickness')
            self.shell_thickness = fval_
            self.validate_LengthValue(self.shell_thickness)    # validate type LengthValue
# end class PoolVolumeInfo


class FixedPoolInfo(GeneratedsSuper):
    """(IN PROGRESS, not stable!!!!) In this case the parameter which
    determines how quickly the internal pool 'fills' is given as a
    fixed value. Note this is a far from ideal way to express this
    value, but needed to be included as this was the parameter which
    was all that was present in a number of models, e.g. Traub et
    al. 2003 Layer 2/3 cell.The dC/dt will be calculated from dC/dt
    = - phi * Ica + [Ca]/decay_constant. See mod/GENESIS impl for
    more details"""
    subclass = None
    superclass = None
    def __init__(self, phi=None):
        self.phi = phi
    def factory(*args_, **kwargs_):
        if FixedPoolInfo.subclass:
            return FixedPoolInfo.subclass(*args_, **kwargs_)
        else:
            return FixedPoolInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPhi(self): return self.phi
    def setPhi(self, phi): self.phi = phi
    def export(self, outfile, level, namespace_='', name_='FixedPoolInfo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedPoolInfo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedPoolInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedPoolInfo', fromsubclass_=False):
        if self.phi is not None:
            showIndent(outfile, level)
            outfile.write('<%sphi>%s</%sphi>\n' % (namespace_, self.gds_format_double(self.phi, input_name='phi'), namespace_))
    def hasContent_(self):
        if (
            self.phi is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedPoolInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.phi is not None:
            showIndent(outfile, level)
            outfile.write('phi=%e,\n' % self.phi)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'phi':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'phi')
            self.phi = fval_
# end class FixedPoolInfo


class Deprecated_Parameter(GeneratedsSuper):
    """Generic parameter used in rate equations"""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, notes=None, properties=None, annotation=None, group=None):
        self.name = _cast(None, name)
        self.value = _cast(float, value)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if Deprecated_Parameter.subclass:
            return Deprecated_Parameter.subclass(*args_, **kwargs_)
        else:
            return Deprecated_Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='Deprecated_Parameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deprecated_Parameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deprecated_Parameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='Deprecated_Parameter', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Deprecated_Parameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
# end class Deprecated_Parameter


class Point(GeneratedsSuper):
    """A 3D point with optional diameter. Note: the units for these values
    will be specified in the file in which the element is used, e.g.
    in a MorphML file with <b>length_units="micrometer"</b> in the
    morphml element. Assume micrometer if no other units are given."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None, diameter=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        self.diameter = _cast(float, diameter)
        pass
    def factory(*args_, **kwargs_):
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def getDiameter(self): return self.diameter
    def setDiameter(self, diameter): self.diameter = diameter
    def export(self, outfile, level, namespace_='', name_='Point', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter="%s"' % self.gds_format_double(self.diameter, input_name='diameter'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = %e,\n' % (self.diameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            try:
                self.diameter = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (diameter): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point


class Point3D(GeneratedsSuper):
    """A 3D point with no diameter. Note: the units for these values will
    be specified in the file in which the element is used, e.g. in a
    MorphML file with <b>length_units="micrometer"</b> in the
    morphml element. Assume micrometer if no other units are given."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        pass
    def factory(*args_, **kwargs_):
        if Point3D.subclass:
            return Point3D.subclass(*args_, **kwargs_)
        else:
            return Point3D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='Point3D', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point3D')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point3D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point3D', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point3D'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point3D


class Points(GeneratedsSuper):
    """A collection of points."""
    subclass = None
    superclass = None
    def __init__(self, name=None, point=None, extensiontype_=None):
        self.name = _cast(None, name)
        if point is None:
            self.point = []
        else:
            self.point = point
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Points.subclass:
            return Points.subclass(*args_, **kwargs_)
        else:
            return Points(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPoint(self): return self.point
    def setPoint(self, point): self.point = point
    def addPoint(self, value): self.point.append(value)
    def insertPoint(self, index, value): self.point[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Points', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Points')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Points'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Points', fromsubclass_=False):
        for point_ in self.point:
            point_.export(outfile, level, namespace_, name_='point')
    def hasContent_(self):
        if (
            self.point
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Points'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('point=[\n')
        level += 1
        for point_ in self.point:
            showIndent(outfile, level)
            outfile.write('model_.Point(\n')
            point_.exportLiteral(outfile, level, name_='Point')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = Point.factory()
            obj_.build(child_)
            self.point.append(obj_)
# end class Points


class Sphere(GeneratedsSuper):
    """A spherical structure such as a cell body or cell."""
    subclass = None
    superclass = None
    def __init__(self, name=None, center=None):
        self.name = _cast(None, name)
        self.center = center
    def factory(*args_, **kwargs_):
        if Sphere.subclass:
            return Sphere.subclass(*args_, **kwargs_)
        else:
            return Sphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCenter(self): return self.center
    def setCenter(self, center): self.center = center
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Sphere', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sphere')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sphere'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Sphere', fromsubclass_=False):
        if self.center is not None:
            self.center.export(outfile, level, namespace_, name_='center', )
    def hasContent_(self):
        if (
            self.center is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Sphere'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.center is not None:
            showIndent(outfile, level)
            outfile.write('center=model_.Point(\n')
            self.center.exportLiteral(outfile, level, name_='center')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'center':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setCenter(obj_)
# end class Sphere


class RectangularBox(GeneratedsSuper):
    """A Rectangular Box for locating cells in 3D."""
    subclass = None
    superclass = None
    def __init__(self, name=None, corner=None, size=None):
        self.name = _cast(None, name)
        self.corner = corner
        self.size = size
    def factory(*args_, **kwargs_):
        if RectangularBox.subclass:
            return RectangularBox.subclass(*args_, **kwargs_)
        else:
            return RectangularBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getCorner(self): return self.corner
    def setCorner(self, corner): self.corner = corner
    def getSize(self): return self.size
    def setSize(self, size): self.size = size
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='RectangularBox', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RectangularBox')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RectangularBox'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RectangularBox', fromsubclass_=False):
        if self.corner is not None:
            self.corner.export(outfile, level, namespace_, name_='corner', )
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', )
    def hasContent_(self):
        if (
            self.corner is not None or
            self.size is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RectangularBox'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.corner is not None:
            showIndent(outfile, level)
            outfile.write('corner=model_.Point(\n')
            self.corner.exportLiteral(outfile, level, name_='corner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=model_.sizeType(\n')
            self.size.exportLiteral(outfile, level, name_='size')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'corner':
            obj_ = Point.factory()
            obj_.build(child_)
            self.setCorner(obj_)
        elif nodeName_ == 'size':
            obj_ = sizeType.factory()
            obj_.build(child_)
            self.setSize(obj_)
# end class RectangularBox


class NonSpatialGrid(GeneratedsSuper):
    """Specifies a grid of up to 3 dimensions, without any explicit 3D
    location information."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(int, y)
        self.x = _cast(int, x)
        self.z = _cast(int, z)
        pass
    def factory(*args_, **kwargs_):
        if NonSpatialGrid.subclass:
            return NonSpatialGrid.subclass(*args_, **kwargs_)
        else:
            return NonSpatialGrid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='NonSpatialGrid', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonSpatialGrid')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonSpatialGrid'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_integer(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='NonSpatialGrid', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NonSpatialGrid'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %d,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %d,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %d,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.y <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.x <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.z <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NonSpatialGrid


class Manifold(Points):
    """A surface."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(Manifold, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if Manifold.subclass:
            return Manifold.subclass(*args_, **kwargs_)
        else:
            return Manifold(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Manifold', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Manifold')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Manifold'):
        super(Manifold, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Manifold')
    def exportChildren(self, outfile, level, namespace_='', name_='Manifold', fromsubclass_=False):
        super(Manifold, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Manifold, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Manifold'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Manifold, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Manifold, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Manifold, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Manifold, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Manifold


class Polygon(Points):
    """A closed structure represented by a list of points where the first
    point connects with the last point."""
    subclass = None
    superclass = Points
    def __init__(self, name=None, point=None):
        super(Polygon, self).__init__(name, point, )
        pass
    def factory(*args_, **kwargs_):
        if Polygon.subclass:
            return Polygon.subclass(*args_, **kwargs_)
        else:
            return Polygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Polygon', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Polygon')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Polygon'):
        super(Polygon, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Polygon')
    def exportChildren(self, outfile, level, namespace_='', name_='Polygon', fromsubclass_=False):
        super(Polygon, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Polygon, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Polygon'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Polygon, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Polygon, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Polygon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Polygon, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Polygon


class Polyhedron(GeneratedsSuper):
    """A 3d surface to represent the cell body or histological structure."""
    subclass = None
    superclass = None
    def __init__(self, polygons=None):
        self.polygons = polygons
    def factory(*args_, **kwargs_):
        if Polyhedron.subclass:
            return Polyhedron.subclass(*args_, **kwargs_)
        else:
            return Polyhedron(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPolygons(self): return self.polygons
    def setPolygons(self, polygons): self.polygons = polygons
    def export(self, outfile, level, namespace_='', name_='Polyhedron', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Polyhedron')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Polyhedron'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Polyhedron', fromsubclass_=False):
        if self.polygons is not None:
            self.polygons.export(outfile, level, namespace_, name_='polygons', )
    def hasContent_(self):
        if (
            self.polygons is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Polyhedron'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.polygons is not None:
            showIndent(outfile, level)
            outfile.write('polygons=model_.polygonsType(\n')
            self.polygons.exportLiteral(outfile, level, name_='polygons')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygons':
            obj_ = polygonsType.factory()
            obj_.build(child_)
            self.setPolygons(obj_)
# end class Polyhedron


class Annotation(GeneratedsSuper):
    """Concise processing directives for downstream applications."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='Annotation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Annotation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Annotation', fromsubclass_=False):
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Annotation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Annotation')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class Annotation


class Property(GeneratedsSuper):
    """A Tag/Value/Type tuple. Note prior to v1.7.1, tag and value were sub
    elements. The attribute option is now preferred."""
    subclass = None
    superclass = None
    def __init__(self, value_attr=None, tag_attr=None, tag=None, value=None):
        self.value_attr = _cast(None, value_attr)
        self.tag_attr = _cast(None, tag_attr)
        self.tag = tag
        self.value = value
    def factory(*args_, **kwargs_):
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTag(self): return self.tag
    def setTag(self, tag): self.tag = tag
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def getValue_attr(self): return self.value_attr
    def setValue_attr(self, value_attr): self.value_attr = value_attr
    def getTag_attr(self): return self.tag_attr
    def setTag_attr(self, tag_attr): self.tag_attr = tag_attr
    def export(self, outfile, level, namespace_='', name_='Property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Property'):
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            outfile.write(' value_attr=%s' % (self.gds_format_string(quote_attrib(self.value_attr).encode(ExternalEncoding), input_name='value_attr'), ))
        if self.tag_attr is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            outfile.write(' tag_attr=%s' % (self.gds_format_string(quote_attrib(self.tag_attr).encode(ExternalEncoding), input_name='tag_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Property', fromsubclass_=False):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('<%stag>%s</%stag>\n' % (namespace_, self.gds_format_string(quote_xml(self.tag).encode(ExternalEncoding), input_name='tag'), namespace_))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.tag is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            showIndent(outfile, level)
            outfile.write('value_attr = "%s",\n' % (self.value_attr,))
        if self.tag_attr is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            showIndent(outfile, level)
            outfile.write('tag_attr = "%s",\n' % (self.tag_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('tag=%s,\n' % quote_python(self.tag).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value_attr', node)
        if value is not None and 'value_attr' not in already_processed:
            already_processed.append('value_attr')
            self.value_attr = value
        value = find_attr_value_('tag_attr', node)
        if value is not None and 'tag_attr' not in already_processed:
            already_processed.append('tag_attr')
            self.tag_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            tag_ = child_.text
            tag_ = self.gds_validate_string(tag_, node, 'tag')
            self.tag = tag_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class Property


class Properties(GeneratedsSuper):
    """A collection of Properties"""
    subclass = None
    superclass = None
    def __init__(self, property=None):
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if Properties.subclass:
            return Properties.subclass(*args_, **kwargs_)
        else:
            return Properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def addProperty(self, value): self.property.append(value)
    def insertProperty(self, index, value): self.property[index] = value
    def export(self, outfile, level, namespace_='', name_='Properties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Properties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Properties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Properties', fromsubclass_=False):
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Properties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.Property(\n')
            property_.exportLiteral(outfile, level, name_='Property')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = Property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class Properties


class PropertyDetail(GeneratedsSuper):
    """Metadata for each Property."""
    subclass = None
    superclass = None
    def __init__(self, property=None, description=None, type_=None):
        self.property = _cast(None, property)
        self.description = description
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if PropertyDetail.subclass:
            return PropertyDetail.subclass(*args_, **kwargs_)
        else:
            return PropertyDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getProperty(self): return self.property
    def setProperty(self, property): self.property = property
    def export(self, outfile, level, namespace_='', name_='PropertyDetail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyDetail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyDetail'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyDetail', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None or
            self.type_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyDetail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.append('property')
            showIndent(outfile, level)
            outfile.write('property = "%s",\n' % (self.property,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.append('property')
            self.property = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class PropertyDetail


class GroupDetail(GeneratedsSuper):
    """Metadata for each Group."""
    subclass = None
    superclass = None
    def __init__(self, group=None, description=None, properties=None):
        self.group = _cast(None, group)
        self.description = description
        if properties is None:
            self.properties = []
        else:
            self.properties = properties
    def factory(*args_, **kwargs_):
        if GroupDetail.subclass:
            return GroupDetail.subclass(*args_, **kwargs_)
        else:
            return GroupDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def addProperties(self, value): self.properties.append(value)
    def insertProperties(self, index, value): self.properties[index] = value
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def export(self, outfile, level, namespace_='', name_='GroupDetail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupDetail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupDetail'):
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            outfile.write(' group=%s' % (self.gds_format_string(quote_attrib(self.group).encode(ExternalEncoding), input_name='group'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GroupDetail', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        for properties_ in self.properties:
            properties_.export(outfile, level, namespace_, name_='properties')
    def hasContent_(self):
        if (
            self.description is not None or
            self.properties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupDetail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            showIndent(outfile, level)
            outfile.write('group = "%s",\n' % (self.group,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('properties=[\n')
        level += 1
        for properties_ in self.properties:
            showIndent(outfile, level)
            outfile.write('model_.Properties(\n')
            properties_.exportLiteral(outfile, level, name_='Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.append('group')
            self.group = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.properties.append(obj_)
# end class GroupDetail


class NeuroMorphoRef(GeneratedsSuper):
    """A reference to an entity in NeuroMorpho.org Note: This element will
    possibly change when a new set of schema files is adopted for
    adding references, authors, citations, etc. See mailing lists
    for latest status"""
    subclass = None
    superclass = None
    def __init__(self, morphologyRef=None, uri=None, comment=None):
        self.morphologyRef = morphologyRef
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NeuroMorphoRef.subclass:
            return NeuroMorphoRef.subclass(*args_, **kwargs_)
        else:
            return NeuroMorphoRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMorphologyRef(self): return self.morphologyRef
    def setMorphologyRef(self, morphologyRef): self.morphologyRef = morphologyRef
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NeuroMorphoRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuroMorphoRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuroMorphoRef'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NeuroMorphoRef', fromsubclass_=False):
        if self.morphologyRef is not None:
            showIndent(outfile, level)
            outfile.write('<%smorphologyRef>%s</%smorphologyRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.morphologyRef).encode(ExternalEncoding), input_name='morphologyRef'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.morphologyRef is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuroMorphoRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.morphologyRef is not None:
            showIndent(outfile, level)
            outfile.write('morphologyRef=%s,\n' % quote_python(self.morphologyRef).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'morphologyRef':
            morphologyRef_ = child_.text
            morphologyRef_ = self.gds_validate_string(morphologyRef_, node, 'morphologyRef')
            self.morphologyRef = morphologyRef_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NeuroMorphoRef


class NeuronDBReference(GeneratedsSuper):
    """A reference to an entity in NeuronDB Note: This element will
    possibly change when a new set of schema files is adopted for
    adding references, authors, citations, etc. See mailing lists
    for latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelName=None, uri=None, comment=None):
        self.modelName = modelName
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NeuronDBReference.subclass:
            return NeuronDBReference.subclass(*args_, **kwargs_)
        else:
            return NeuronDBReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelName(self): return self.modelName
    def setModelName(self, modelName): self.modelName = modelName
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NeuronDBReference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuronDBReference')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuronDBReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NeuronDBReference', fromsubclass_=False):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('<%smodelName>%s</%smodelName>\n' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.modelName is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NeuronDBReference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NeuronDBReference


class ModelDBReference(GeneratedsSuper):
    """A reference to an entity in ModelDB Note: This element will possibly
    change when a new set of schema files is adopted for adding
    references, authors, citations, etc. See mailing lists for
    latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelName=None, uri=None, comment=None):
        self.modelName = modelName
        self.uri = uri
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ModelDBReference.subclass:
            return ModelDBReference.subclass(*args_, **kwargs_)
        else:
            return ModelDBReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelName(self): return self.modelName
    def setModelName(self, modelName): self.modelName = modelName
    def getUri(self): return self.uri
    def setUri(self, uri): self.uri = uri
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ModelDBReference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelDBReference')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelDBReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelDBReference', fromsubclass_=False):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('<%smodelName>%s</%smodelName>\n' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('<%suri>%s</%suri>\n' % (namespace_, self.gds_format_string(quote_xml(self.uri).encode(ExternalEncoding), input_name='uri'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.modelName is not None or
            self.uri is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ModelDBReference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=%s,\n' % quote_python(self.uri).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'uri':
            uri_ = child_.text
            uri_ = self.gds_validate_string(uri_, node, 'uri')
            self.uri = uri_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ModelDBReference


class Publication(GeneratedsSuper):
    """A reference to a publication Note: This element will possibly change
    when a new set of schema files is adopted for adding references,
    authors, citations, etc. See mailing lists for latest status"""
    subclass = None
    superclass = None
    def __init__(self, fullTitle=None, pubmedRef=None, comment=None):
        self.fullTitle = fullTitle
        self.pubmedRef = pubmedRef
        self.comment = comment
    def factory(*args_, **kwargs_):
        if Publication.subclass:
            return Publication.subclass(*args_, **kwargs_)
        else:
            return Publication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFullTitle(self): return self.fullTitle
    def setFullTitle(self, fullTitle): self.fullTitle = fullTitle
    def getPubmedRef(self): return self.pubmedRef
    def setPubmedRef(self, pubmedRef): self.pubmedRef = pubmedRef
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='Publication', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Publication')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Publication'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Publication', fromsubclass_=False):
        if self.fullTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sfullTitle>%s</%sfullTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.fullTitle).encode(ExternalEncoding), input_name='fullTitle'), namespace_))
        if self.pubmedRef is not None:
            showIndent(outfile, level)
            outfile.write('<%spubmedRef>%s</%spubmedRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.pubmedRef).encode(ExternalEncoding), input_name='pubmedRef'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.fullTitle is not None or
            self.pubmedRef is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Publication'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fullTitle is not None:
            showIndent(outfile, level)
            outfile.write('fullTitle=%s,\n' % quote_python(self.fullTitle).encode(ExternalEncoding))
        if self.pubmedRef is not None:
            showIndent(outfile, level)
            outfile.write('pubmedRef=%s,\n' % quote_python(self.pubmedRef).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullTitle':
            fullTitle_ = child_.text
            fullTitle_ = self.gds_validate_string(fullTitle_, node, 'fullTitle')
            self.fullTitle = fullTitle_
        elif nodeName_ == 'pubmedRef':
            pubmedRef_ = child_.text
            pubmedRef_ = self.gds_validate_string(pubmedRef_, node, 'pubmedRef')
            self.pubmedRef = pubmedRef_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class Publication


class Authors(GeneratedsSuper):
    """A reference to an author Note: This element will possibly change
    when a new set of schema files is adopted for adding references,
    authors, citations, etc. See mailing lists for latest status"""
    subclass = None
    superclass = None
    def __init__(self, modelAuthor=None, modelTranslator=None):
        if modelAuthor is None:
            self.modelAuthor = []
        else:
            self.modelAuthor = modelAuthor
        if modelTranslator is None:
            self.modelTranslator = []
        else:
            self.modelTranslator = modelTranslator
    def factory(*args_, **kwargs_):
        if Authors.subclass:
            return Authors.subclass(*args_, **kwargs_)
        else:
            return Authors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getModelAuthor(self): return self.modelAuthor
    def setModelAuthor(self, modelAuthor): self.modelAuthor = modelAuthor
    def addModelAuthor(self, value): self.modelAuthor.append(value)
    def insertModelAuthor(self, index, value): self.modelAuthor[index] = value
    def getModelTranslator(self): return self.modelTranslator
    def setModelTranslator(self, modelTranslator): self.modelTranslator = modelTranslator
    def addModelTranslator(self, value): self.modelTranslator.append(value)
    def insertModelTranslator(self, index, value): self.modelTranslator[index] = value
    def export(self, outfile, level, namespace_='', name_='Authors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Authors')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Authors'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Authors', fromsubclass_=False):
        for modelAuthor_ in self.modelAuthor:
            modelAuthor_.export(outfile, level, namespace_, name_='modelAuthor')
        for modelTranslator_ in self.modelTranslator:
            modelTranslator_.export(outfile, level, namespace_, name_='modelTranslator')
    def hasContent_(self):
        if (
            self.modelAuthor or
            self.modelTranslator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Authors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('modelAuthor=[\n')
        level += 1
        for modelAuthor_ in self.modelAuthor:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            modelAuthor_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('modelTranslator=[\n')
        level += 1
        for modelTranslator_ in self.modelTranslator:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            modelTranslator_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modelAuthor':
            obj_ = Person.factory()
            obj_.build(child_)
            self.modelAuthor.append(obj_)
        elif nodeName_ == 'modelTranslator':
            obj_ = Person.factory()
            obj_.build(child_)
            self.modelTranslator.append(obj_)
# end class Authors


class Person(GeneratedsSuper):
    """A generic reference to a person, for authorship, etc"""
    subclass = None
    superclass = None
    def __init__(self, name=None, institution=None, email=None, comment=None):
        self.name = name
        self.institution = institution
        self.email = email
        self.comment = comment
    def factory(*args_, **kwargs_):
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getInstitution(self): return self.institution
    def setInstitution(self, institution): self.institution = institution
    def getEmail(self): return self.email
    def setEmail(self, email): self.email = email
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='Person', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Person')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Person'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Person', fromsubclass_=False):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstitution>%s</%sinstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.institution).encode(ExternalEncoding), input_name='institution'), namespace_))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('<%semail>%s</%semail>\n' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.institution is not None or
            self.email is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Person'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('institution=%s,\n' % quote_python(self.institution).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'institution':
            institution_ = child_.text
            institution_ = self.gds_validate_string(institution_, node, 'institution')
            self.institution = institution_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class Person


class Status(GeneratedsSuper):
    """Status element giving the stability state of files and some extra
    comments.Currently an enum value of status/in progress/etc."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, issue=None, contributor=None):
        self.value = _cast(None, value)
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        if issue is None:
            self.issue = []
        else:
            self.issue = issue
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
    def factory(*args_, **kwargs_):
        if Status.subclass:
            return Status.subclass(*args_, **kwargs_)
        else:
            return Status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getComment(self): return self.comment
    def setComment(self, comment): self.comment = comment
    def addComment(self, value): self.comment.append(value)
    def insertComment(self, index, value): self.comment[index] = value
    def getIssue(self): return self.issue
    def setIssue(self, issue): self.issue = issue
    def addIssue(self, value): self.issue.append(value)
    def insertIssue(self, index, value): self.issue[index] = value
    def getContributor(self): return self.contributor
    def setContributor(self, contributor): self.contributor = contributor
    def addContributor(self, value): self.contributor.append(value)
    def insertContributor(self, index, value): self.contributor[index] = value
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def validate_StatusValue(self, value):
        # Validate type StatusValue, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Status', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Status')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Status'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Status', fromsubclass_=False):
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(comment_).encode(ExternalEncoding), input_name='comment'), namespace_))
        for issue_ in self.issue:
            showIndent(outfile, level)
            outfile.write('<%sissue>%s</%sissue>\n' % (namespace_, self.gds_format_string(quote_xml(issue_).encode(ExternalEncoding), input_name='issue'), namespace_))
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
    def hasContent_(self):
        if (
            self.comment or
            self.issue or
            self.contributor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('issue=[\n')
        level += 1
        for issue_ in self.issue:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(issue_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.Person(\n')
            contributor_.exportLiteral(outfile, level, name_='Person')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
            self.validate_StatusValue(self.value)    # validate type StatusValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment.append(comment_)
        elif nodeName_ == 'issue':
            issue_ = child_.text
            issue_ = self.gds_validate_string(issue_, node, 'issue')
            self.issue.append(issue_)
        elif nodeName_ == 'contributor':
            obj_ = Person.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
# end class Status


class Biophysics(GeneratedsSuper):
    """Description of biophysical properties of a cell.Unit system of all
    quantities."""
    subclass = None
    superclass = None
    def __init__(self, units=None, mechanism=None, specificCapacitance=None, spec_capacitance=None, specificAxialResistance=None, spec_axial_resistance=None, initialMembPotential=None, init_memb_potential=None, ionProperties=None, ion_props=None):
        self.units = _cast(None, units)
        if mechanism is None:
            self.mechanism = []
        else:
            self.mechanism = mechanism
        self.specificCapacitance = specificCapacitance
        self.spec_capacitance = spec_capacitance
        self.specificAxialResistance = specificAxialResistance
        self.spec_axial_resistance = spec_axial_resistance
        self.initialMembPotential = initialMembPotential
        self.init_memb_potential = init_memb_potential
        self.ionProperties = ionProperties
        if ion_props is None:
            self.ion_props = []
        else:
            self.ion_props = ion_props
    def factory(*args_, **kwargs_):
        if Biophysics.subclass:
            return Biophysics.subclass(*args_, **kwargs_)
        else:
            return Biophysics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMechanism(self): return self.mechanism
    def setMechanism(self, mechanism): self.mechanism = mechanism
    def addMechanism(self, value): self.mechanism.append(value)
    def insertMechanism(self, index, value): self.mechanism[index] = value
    def getSpecificCapacitance(self): return self.specificCapacitance
    def setSpecificCapacitance(self, specificCapacitance): self.specificCapacitance = specificCapacitance
    def getSpecCapacitance(self): return self.spec_capacitance
    def setSpecCapacitance(self, spec_capacitance): self.spec_capacitance = spec_capacitance
    def getSpecificAxialResistance(self): return self.specificAxialResistance
    def setSpecificAxialResistance(self, specificAxialResistance): self.specificAxialResistance = specificAxialResistance
    def getSpecAxialResistance(self): return self.spec_axial_resistance
    def setSpecAxialResistance(self, spec_axial_resistance): self.spec_axial_resistance = spec_axial_resistance
    def getInitialMembPotential(self): return self.initialMembPotential
    def setInitialMembPotential(self, initialMembPotential): self.initialMembPotential = initialMembPotential
    def getInit_memb_potential(self): return self.init_memb_potential
    def setInit_memb_potential(self, init_memb_potential): self.init_memb_potential = init_memb_potential
    def getIonProperties(self): return self.ionProperties
    def setIonProperties(self, ionProperties): self.ionProperties = ionProperties
    def getIon_props(self): return self.ion_props
    def setIon_props(self, ion_props): self.ion_props = ion_props
    def addIon_props(self, value): self.ion_props.append(value)
    def insertIon_props(self, index, value): self.ion_props[index] = value
    def getUnits(self): return self.units
    def setUnits(self, units): self.units = units
    def export(self, outfile, level, namespace_='', name_='Biophysics', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Biophysics')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Biophysics'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Biophysics', fromsubclass_=False):
        for mechanism_ in self.mechanism:
            mechanism_.export(outfile, level, namespace_, name_='mechanism')
        if self.specificCapacitance is not None:
            self.specificCapacitance.export(outfile, level, namespace_, name_='specificCapacitance', )
        if self.spec_capacitance is not None:
            self.spec_capacitance.export(outfile, level, namespace_, name_='spec_capacitance', )
        if self.specificAxialResistance is not None:
            self.specificAxialResistance.export(outfile, level, namespace_, name_='specificAxialResistance', )
        if self.spec_axial_resistance is not None:
            self.spec_axial_resistance.export(outfile, level, namespace_, name_='spec_axial_resistance', )
        if self.initialMembPotential is not None:
            self.initialMembPotential.export(outfile, level, namespace_, name_='initialMembPotential')
        if self.init_memb_potential is not None:
            self.init_memb_potential.export(outfile, level, namespace_, name_='init_memb_potential')
        if self.ionProperties is not None:
            self.ionProperties.export(outfile, level, namespace_, name_='ionProperties')
        for ion_props_ in self.ion_props:
            ion_props_.export(outfile, level, namespace_, name_='ion_props')
    def hasContent_(self):
        if (
            self.mechanism or
            self.specificCapacitance is not None or
            self.spec_capacitance is not None or
            self.specificAxialResistance is not None or
            self.spec_axial_resistance is not None or
            self.initialMembPotential is not None or
            self.init_memb_potential is not None or
            self.ionProperties is not None or
            self.ion_props
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Biophysics'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = %s,\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mechanism=[\n')
        level += 1
        for mechanism_ in self.mechanism:
            showIndent(outfile, level)
            outfile.write('model_.Mechanism(\n')
            mechanism_.exportLiteral(outfile, level, name_='Mechanism')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.specificCapacitance is not None:
            showIndent(outfile, level)
            outfile.write('specificCapacitance=model_.SpecCapacitance(\n')
            self.specificCapacitance.exportLiteral(outfile, level, name_='specificCapacitance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spec_capacitance is not None:
            showIndent(outfile, level)
            outfile.write('spec_capacitance=model_.SpecCapacitance(\n')
            self.spec_capacitance.exportLiteral(outfile, level, name_='spec_capacitance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.specificAxialResistance is not None:
            showIndent(outfile, level)
            outfile.write('specificAxialResistance=model_.SpecAxialResistance(\n')
            self.specificAxialResistance.exportLiteral(outfile, level, name_='specificAxialResistance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spec_axial_resistance is not None:
            showIndent(outfile, level)
            outfile.write('spec_axial_resistance=model_.SpecAxialResistance(\n')
            self.spec_axial_resistance.exportLiteral(outfile, level, name_='spec_axial_resistance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.initialMembPotential is not None:
            showIndent(outfile, level)
            outfile.write('initialMembPotential=model_.InitialMembPotential(\n')
            self.initialMembPotential.exportLiteral(outfile, level, name_='initialMembPotential')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.init_memb_potential is not None:
            showIndent(outfile, level)
            outfile.write('init_memb_potential=model_.InitialMembPotential(\n')
            self.init_memb_potential.exportLiteral(outfile, level, name_='init_memb_potential')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ionProperties is not None:
            showIndent(outfile, level)
            outfile.write('ionProperties=model_.IonProperties(\n')
            self.ionProperties.exportLiteral(outfile, level, name_='ionProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ion_props=[\n')
        level += 1
        for ion_props_ in self.ion_props:
            showIndent(outfile, level)
            outfile.write('model_.IonProperties(\n')
            ion_props_.exportLiteral(outfile, level, name_='IonProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mechanism':
            obj_ = Mechanism.factory()
            obj_.build(child_)
            self.mechanism.append(obj_)
        elif nodeName_ == 'specificCapacitance':
            obj_ = SpecCapacitance.factory()
            obj_.build(child_)
            self.setSpecificCapacitance(obj_)
        elif nodeName_ == 'spec_capacitance':
            obj_ = SpecCapacitance.factory()
            obj_.build(child_)
            self.setSpecCapacitance(obj_)
        elif nodeName_ == 'specificAxialResistance':
            obj_ = SpecAxialResistance.factory()
            obj_.build(child_)
            self.setSpecificAxialResistance(obj_)
        elif nodeName_ == 'spec_axial_resistance':
            obj_ = SpecAxialResistance.factory()
            obj_.build(child_)
            self.setSpecAxialResistance(obj_)
        elif nodeName_ == 'initialMembPotential':
            obj_ = InitialMembPotential.factory()
            obj_.build(child_)
            self.setInitialMembPotential(obj_)
        elif nodeName_ == 'init_memb_potential':
            obj_ = InitialMembPotential.factory()
            obj_.build(child_)
            self.setInit_memb_potential(obj_)
        elif nodeName_ == 'ionProperties':
            obj_ = IonProperties.factory()
            obj_.build(child_)
            self.setIonProperties(obj_)
        elif nodeName_ == 'ion_props':
            obj_ = IonProperties.factory()
            obj_.build(child_)
            self.ion_props.append(obj_)
# end class Biophysics


class Mechanism(GeneratedsSuper):
    """Definition of placement of a single electrophysiological mechanism
    (e.g. channel mechanism) on a group of cables of a cellName of
    the mechanism. Should refer to a named mechanism in a ChannelML
    fileSpecifies the type of cellular mechanism (Channel
    Mechanism/Ion Concentration). Note could be used for any type of
    electrophysiological property of a section of a cellWhether this
    is a passive/leak conductance. In this case, 2 params, gmax and
    e should be sufficient to fully specify the mechanism,
    independent of any implementation. Useful e.g. for mapping to
    and from inbuilt mechanisms in simulators (e.g. pas in NEURON,
    Em/Rm in GENESIS). NOTE: this attribute will be required in
    v2.0!! Don't use passiveConductance anymore. Changed for
    consistency with ChannelML and NetworkML naming
    conventions.Whether this is a passive/leak conductance. NOTE:
    this attribute will be removed in v2.0!! Use passive_conductance
    instead. Changed for consistency with ChannelML and NetworkML
    naming conventions."""
    subclass = None
    superclass = None
    def __init__(self, passive_conductance=False, passiveConductance=False, type_=None, name=None, parameter=None, variableParameter=None, variable_parameter=None):
        self.passive_conductance = _cast(bool, passive_conductance)
        self.passiveConductance = _cast(bool, passiveConductance)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        if variable_parameter is None:
            self.variable_parameter = []
        else:
            self.variable_parameter = variable_parameter
    def factory(*args_, **kwargs_):
        if Mechanism.subclass:
            return Mechanism.subclass(*args_, **kwargs_)
        else:
            return Mechanism(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getVariableParameter(self): return self.variableParameter
    def setVariableParameter(self, variableParameter): self.variableParameter = variableParameter
    def addVariableParameter(self, value): self.variableParameter.append(value)
    def insertVariableParameter(self, index, value): self.variableParameter[index] = value
    def getVariableParameter(self): return self.variable_parameter
    def setVariableParameter(self, variable_parameter): self.variable_parameter = variable_parameter
    def addVariableParameter(self, value): self.variable_parameter.append(value)
    def insertVariableParameter(self, index, value): self.variable_parameter[index] = value
    def getPassive_conductance(self): return self.passive_conductance
    def setPassive_conductance(self, passive_conductance): self.passive_conductance = passive_conductance
    def getPassiveConductance(self): return self.passiveConductance
    def setPassiveConductance(self, passiveConductance): self.passiveConductance = passiveConductance
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def validate_MechanismType(self, value):
        # Validate type MechanismType, a restriction on xs:string.
        pass
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Mechanism', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mechanism')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Mechanism'):
        if self.passive_conductance is not None and 'passive_conductance' not in already_processed:
            already_processed.append('passive_conductance')
            outfile.write(' passive_conductance="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.passive_conductance)), input_name='passive_conductance'))
        if self.passiveConductance is not None and 'passiveConductance' not in already_processed:
            already_processed.append('passiveConductance')
            outfile.write(' passiveConductance="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.passiveConductance)), input_name='passiveConductance'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Mechanism', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
        for variableParameter_ in self.variableParameter:
            variableParameter_.export(outfile, level, namespace_, name_='variableParameter')
        for variable_parameter_ in self.variable_parameter:
            variable_parameter_.export(outfile, level, namespace_, name_='variable_parameter')
    def hasContent_(self):
        if (
            self.parameter or
            self.variableParameter or
            self.variable_parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Mechanism'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.passive_conductance is not None and 'passive_conductance' not in already_processed:
            already_processed.append('passive_conductance')
            showIndent(outfile, level)
            outfile.write('passive_conductance = %s,\n' % (self.passive_conductance,))
        if self.passiveConductance is not None and 'passiveConductance' not in already_processed:
            already_processed.append('passiveConductance')
            showIndent(outfile, level)
            outfile.write('passiveConductance = %s,\n' % (self.passiveConductance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.NamedParameter(\n')
            parameter_.exportLiteral(outfile, level, name_='NamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variableParameter=[\n')
        level += 1
        for variableParameter_ in self.variableParameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableNamedParameter(\n')
            variableParameter_.exportLiteral(outfile, level, name_='VariableNamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variable_parameter=[\n')
        level += 1
        for variable_parameter_ in self.variable_parameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableNamedParameter(\n')
            variable_parameter_.exportLiteral(outfile, level, name_='VariableNamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('passive_conductance', node)
        if value is not None and 'passive_conductance' not in already_processed:
            already_processed.append('passive_conductance')
            if value in ('true', '1'):
                self.passive_conductance = True
            elif value in ('false', '0'):
                self.passive_conductance = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('passiveConductance', node)
        if value is not None and 'passiveConductance' not in already_processed:
            already_processed.append('passiveConductance')
            if value in ('true', '1'):
                self.passiveConductance = True
            elif value in ('false', '0'):
                self.passiveConductance = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_MechanismType(self.type_)    # validate type MechanismType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = NamedParameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
        elif nodeName_ == 'variableParameter':
            obj_ = VariableNamedParameter.factory()
            obj_.build(child_)
            self.variableParameter.append(obj_)
        elif nodeName_ == 'variable_parameter':
            obj_ = VariableNamedParameter.factory()
            obj_.build(child_)
            self.variable_parameter.append(obj_)
# end class Mechanism


class SpecCapacitance(GeneratedsSuper):
    """Capacitance per unit area of a group of sections"""
    subclass = None
    superclass = None
    def __init__(self, parameter=None, variableParameter=None, variable_parameter=None):
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        if variable_parameter is None:
            self.variable_parameter = []
        else:
            self.variable_parameter = variable_parameter
    def factory(*args_, **kwargs_):
        if SpecCapacitance.subclass:
            return SpecCapacitance.subclass(*args_, **kwargs_)
        else:
            return SpecCapacitance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getVariableParameter(self): return self.variableParameter
    def setVariableParameter(self, variableParameter): self.variableParameter = variableParameter
    def addVariableParameter(self, value): self.variableParameter.append(value)
    def insertVariableParameter(self, index, value): self.variableParameter[index] = value
    def getVariableParameter(self): return self.variable_parameter
    def setVariableParameter(self, variable_parameter): self.variable_parameter = variable_parameter
    def addVariableParameter(self, value): self.variable_parameter.append(value)
    def insertVariableParameter(self, index, value): self.variable_parameter[index] = value
    def export(self, outfile, level, namespace_='', name_='SpecCapacitance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecCapacitance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecCapacitance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecCapacitance', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
        for variableParameter_ in self.variableParameter:
            variableParameter_.export(outfile, level, namespace_, name_='variableParameter')
        for variable_parameter_ in self.variable_parameter:
            variable_parameter_.export(outfile, level, namespace_, name_='variable_parameter')
    def hasContent_(self):
        if (
            self.parameter or
            self.variableParameter or
            self.variable_parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecCapacitance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.UnnamedParameter(\n')
            parameter_.exportLiteral(outfile, level, name_='UnnamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variableParameter=[\n')
        level += 1
        for variableParameter_ in self.variableParameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variableParameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variable_parameter=[\n')
        level += 1
        for variable_parameter_ in self.variable_parameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variable_parameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = UnnamedParameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
        elif nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variableParameter.append(obj_)
        elif nodeName_ == 'variable_parameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variable_parameter.append(obj_)
# end class SpecCapacitance


class SpecAxialResistance(GeneratedsSuper):
    """Specific axial resistance of a group of sections"""
    subclass = None
    superclass = None
    def __init__(self, parameter=None, variableParameter=None, variable_parameter=None):
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        if variable_parameter is None:
            self.variable_parameter = []
        else:
            self.variable_parameter = variable_parameter
    def factory(*args_, **kwargs_):
        if SpecAxialResistance.subclass:
            return SpecAxialResistance.subclass(*args_, **kwargs_)
        else:
            return SpecAxialResistance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getVariableParameter(self): return self.variableParameter
    def setVariableParameter(self, variableParameter): self.variableParameter = variableParameter
    def addVariableParameter(self, value): self.variableParameter.append(value)
    def insertVariableParameter(self, index, value): self.variableParameter[index] = value
    def getVariableParameter(self): return self.variable_parameter
    def setVariableParameter(self, variable_parameter): self.variable_parameter = variable_parameter
    def addVariableParameter(self, value): self.variable_parameter.append(value)
    def insertVariableParameter(self, index, value): self.variable_parameter[index] = value
    def export(self, outfile, level, namespace_='', name_='SpecAxialResistance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecAxialResistance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecAxialResistance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecAxialResistance', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
        for variableParameter_ in self.variableParameter:
            variableParameter_.export(outfile, level, namespace_, name_='variableParameter')
        for variable_parameter_ in self.variable_parameter:
            variable_parameter_.export(outfile, level, namespace_, name_='variable_parameter')
    def hasContent_(self):
        if (
            self.parameter or
            self.variableParameter or
            self.variable_parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecAxialResistance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.UnnamedParameter(\n')
            parameter_.exportLiteral(outfile, level, name_='UnnamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variableParameter=[\n')
        level += 1
        for variableParameter_ in self.variableParameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variableParameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variable_parameter=[\n')
        level += 1
        for variable_parameter_ in self.variable_parameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variable_parameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = UnnamedParameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
        elif nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variableParameter.append(obj_)
        elif nodeName_ == 'variable_parameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variable_parameter.append(obj_)
# end class SpecAxialResistance


class InitialMembPotential(GeneratedsSuper):
    """This quantity is often required for computational simulations and
    specifies the potential difference across the membrane at the
    start of the simulation. This is an optional field"""
    subclass = None
    superclass = None
    def __init__(self, parameter=None, variableParameter=None):
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
    def factory(*args_, **kwargs_):
        if InitialMembPotential.subclass:
            return InitialMembPotential.subclass(*args_, **kwargs_)
        else:
            return InitialMembPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getVariableParameter(self): return self.variableParameter
    def setVariableParameter(self, variableParameter): self.variableParameter = variableParameter
    def addVariableParameter(self, value): self.variableParameter.append(value)
    def insertVariableParameter(self, index, value): self.variableParameter[index] = value
    def export(self, outfile, level, namespace_='', name_='InitialMembPotential', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitialMembPotential')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitialMembPotential'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InitialMembPotential', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
        for variableParameter_ in self.variableParameter:
            variableParameter_.export(outfile, level, namespace_, name_='variableParameter')
    def hasContent_(self):
        if (
            self.parameter or
            self.variableParameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InitialMembPotential'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.UnnamedParameter(\n')
            parameter_.exportLiteral(outfile, level, name_='UnnamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variableParameter=[\n')
        level += 1
        for variableParameter_ in self.variableParameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variableParameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = UnnamedParameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
        elif nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variableParameter.append(obj_)
# end class InitialMembPotential


class IonProperties(GeneratedsSuper):
    """Some properties accociated with an ion type which takes part in the
    mechanisms on the cell"""
    subclass = None
    superclass = None
    def __init__(self, name=None, parameter=None):
        self.name = _cast(None, name)
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if IonProperties.subclass:
            return IonProperties.subclass(*args_, **kwargs_)
        else:
            return IonProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def addParameter(self, value): self.parameter.append(value)
    def insertParameter(self, index, value): self.parameter[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='IonProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IonProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IonProperties'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IonProperties', fromsubclass_=False):
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
    def hasContent_(self):
        if (
            self.parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IonProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.NamedParameter(\n')
            parameter_.exportLiteral(outfile, level, name_='NamedParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            obj_ = NamedParameter.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
# end class IonProperties


class NamedParameter(GeneratedsSuper):
    """Definition of a value for a quantity and the associated groups of
    cables which have this value. Can have any name, but gmax and e
    are special...2 names have special meaning: gmax for the maximum
    conductance density, and e for the reversal potential of a
    passive channel"""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, group=None):
        self.name = _cast(None, name)
        self.value = _cast(float, value)
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if NamedParameter.subclass:
            return NamedParameter.subclass(*args_, **kwargs_)
        else:
            return NamedParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='NamedParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamedParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NamedParameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='NamedParameter', fromsubclass_=False):
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NamedParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
# end class NamedParameter


class VariableParameter(GeneratedsSuper):
    """Definition of a value for a quantity which varies over a given group
    of cables"""
    subclass = None
    superclass = None
    def __init__(self, name=None, group=None, inhomogeneous_value=None):
        self.name = _cast(None, name)
        if group is None:
            self.group = []
        else:
            self.group = group
        if inhomogeneous_value is None:
            self.inhomogeneous_value = []
        else:
            self.inhomogeneous_value = inhomogeneous_value
    def factory(*args_, **kwargs_):
        if VariableParameter.subclass:
            return VariableParameter.subclass(*args_, **kwargs_)
        else:
            return VariableParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def getInhomogeneous_value(self): return self.inhomogeneous_value
    def setInhomogeneous_value(self, inhomogeneous_value): self.inhomogeneous_value = inhomogeneous_value
    def addInhomogeneous_value(self, value): self.inhomogeneous_value.append(value)
    def insertInhomogeneous_value(self, index, value): self.inhomogeneous_value[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='VariableParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VariableParameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VariableParameter', fromsubclass_=False):
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for inhomogeneous_value_ in self.inhomogeneous_value:
            inhomogeneous_value_.export(outfile, level, namespace_, name_='inhomogeneous_value')
    def hasContent_(self):
        if (
            self.group or
            self.inhomogeneous_value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('inhomogeneous_value=[\n')
        level += 1
        for inhomogeneous_value_ in self.inhomogeneous_value:
            showIndent(outfile, level)
            outfile.write('model_.InhomogeneousValue(\n')
            inhomogeneous_value_.exportLiteral(outfile, level, name_='InhomogeneousValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
        elif nodeName_ == 'inhomogeneous_value':
            obj_ = InhomogeneousValue.factory()
            obj_.build(child_)
            self.inhomogeneous_value.append(obj_)
# end class VariableParameter


class VariableNamedParameter(GeneratedsSuper):
    """Definition of a value for a quantity which varies over a given group
    of cables"""
    subclass = None
    superclass = None
    def __init__(self, name=None, group=None, inhomogeneous_value=None):
        self.name = _cast(None, name)
        if group is None:
            self.group = []
        else:
            self.group = group
        if inhomogeneous_value is None:
            self.inhomogeneous_value = []
        else:
            self.inhomogeneous_value = inhomogeneous_value
    def factory(*args_, **kwargs_):
        if VariableNamedParameter.subclass:
            return VariableNamedParameter.subclass(*args_, **kwargs_)
        else:
            return VariableNamedParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def getInhomogeneous_value(self): return self.inhomogeneous_value
    def setInhomogeneous_value(self, inhomogeneous_value): self.inhomogeneous_value = inhomogeneous_value
    def addInhomogeneous_value(self, value): self.inhomogeneous_value.append(value)
    def insertInhomogeneous_value(self, index, value): self.inhomogeneous_value[index] = value
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='VariableNamedParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableNamedParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VariableNamedParameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VariableNamedParameter', fromsubclass_=False):
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        for inhomogeneous_value_ in self.inhomogeneous_value:
            inhomogeneous_value_.export(outfile, level, namespace_, name_='inhomogeneous_value')
    def hasContent_(self):
        if (
            self.group or
            self.inhomogeneous_value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableNamedParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('inhomogeneous_value=[\n')
        level += 1
        for inhomogeneous_value_ in self.inhomogeneous_value:
            showIndent(outfile, level)
            outfile.write('model_.InhomogeneousValue(\n')
            inhomogeneous_value_.exportLiteral(outfile, level, name_='InhomogeneousValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
        elif nodeName_ == 'inhomogeneous_value':
            obj_ = InhomogeneousValue.factory()
            obj_.build(child_)
            self.inhomogeneous_value.append(obj_)
# end class VariableNamedParameter


class InhomogeneousValue(GeneratedsSuper):
    """How a value changes over the cable group. Implementation here based
    on NEURON inhomogeneous parameter specification. See example for
    usage of this elementName used in the inhomogeneous_param
    element in the cable groupEquation showing how parameter changes
    as function of variable attribute in inhomogeneous_param element"""
    subclass = None
    superclass = None
    def __init__(self, param_name=None, value=None):
        self.param_name = _cast(None, param_name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if InhomogeneousValue.subclass:
            return InhomogeneousValue.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParam_name(self): return self.param_name
    def setParam_name(self, param_name): self.param_name = param_name
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='InhomogeneousValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InhomogeneousValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InhomogeneousValue'):
        if self.param_name is not None and 'param_name' not in already_processed:
            already_processed.append('param_name')
            outfile.write(' param_name=%s' % (self.gds_format_string(quote_attrib(self.param_name).encode(ExternalEncoding), input_name='param_name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InhomogeneousValue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InhomogeneousValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.param_name is not None and 'param_name' not in already_processed:
            already_processed.append('param_name')
            showIndent(outfile, level)
            outfile.write('param_name = "%s",\n' % (self.param_name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('param_name', node)
        if value is not None and 'param_name' not in already_processed:
            already_processed.append('param_name')
            self.param_name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InhomogeneousValue


class UnnamedParameter(GeneratedsSuper):
    """Definition of a value for a quantity and the associated groups of
    cables which have this value. The quantity referred to will be
    clear from the usage, e.g. InitialMembPotential"""
    subclass = None
    superclass = None
    def __init__(self, value=None, group=None):
        self.value = _cast(float, value)
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if UnnamedParameter.subclass:
            return UnnamedParameter.subclass(*args_, **kwargs_)
        else:
            return UnnamedParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='UnnamedParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnnamedParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnnamedParameter'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='UnnamedParameter', fromsubclass_=False):
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnnamedParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
# end class UnnamedParameter


class conductanceType(GeneratedsSuper):
    """Maximum conductance density of channel"""
    subclass = None
    superclass = None
    def __init__(self, default_gmax=None, notes=None, properties=None, annotation=None, group=None, rate_adjustments=None, conc_factor=None, gate=None):
        self.default_gmax = _cast(None, default_gmax)
        self.notes = notes
        self.properties = properties
        self.annotation = annotation
        if group is None:
            self.group = []
        else:
            self.group = group
        self.rate_adjustments = rate_adjustments
        self.conc_factor = conc_factor
        if gate is None:
            self.gate = []
        else:
            self.gate = gate
    def factory(*args_, **kwargs_):
        if conductanceType.subclass:
            return conductanceType.subclass(*args_, **kwargs_)
        else:
            return conductanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getProperties(self): return self.properties
    def setProperties(self, properties): self.properties = properties
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getGroup(self): return self.group
    def setGroup(self, group): self.group = group
    def addGroup(self, value): self.group.append(value)
    def insertGroup(self, index, value): self.group[index] = value
    def validate_Group(self, value):
        # Validate type Group, a restriction on xs:string.
        pass
    def getRate_adjustments(self): return self.rate_adjustments
    def setRate_adjustments(self, rate_adjustments): self.rate_adjustments = rate_adjustments
    def getConc_factor(self): return self.conc_factor
    def setConc_factor(self, conc_factor): self.conc_factor = conc_factor
    def getGate(self): return self.gate
    def setGate(self, gate): self.gate = gate
    def addGate(self, value): self.gate.append(value)
    def insertGate(self, index, value): self.gate[index] = value
    def getDefault_gmax(self): return self.default_gmax
    def setDefault_gmax(self, default_gmax): self.default_gmax = default_gmax
    def export(self, outfile, level, namespace_='', name_='conductanceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conductanceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conductanceType'):
        if self.default_gmax is not None and 'default_gmax' not in already_processed:
            already_processed.append('default_gmax')
            outfile.write(' default_gmax=%s' % (quote_attrib(self.default_gmax), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conductanceType', fromsubclass_=False):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.gds_format_string(quote_xml(group_).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.rate_adjustments is not None:
            self.rate_adjustments.export(outfile, level, namespace_, name_='rate_adjustments')
        if self.conc_factor is not None:
            self.conc_factor.export(outfile, level, namespace_, name_='conc_factor')
        for gate_ in self.gate:
            gate_.export(outfile, level, namespace_, name_='gate')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.properties is not None or
            self.annotation is not None or
            self.group or
            self.rate_adjustments is not None or
            self.conc_factor is not None or
            self.gate
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='conductanceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default_gmax is not None and 'default_gmax' not in already_processed:
            already_processed.append('default_gmax')
            showIndent(outfile, level)
            outfile.write('default_gmax = %s,\n' % (self.default_gmax,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.Properties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(group_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.rate_adjustments is not None:
            showIndent(outfile, level)
            outfile.write('rate_adjustments=model_.RateAdjustments(\n')
            self.rate_adjustments.exportLiteral(outfile, level, name_='rate_adjustments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.conc_factor is not None:
            showIndent(outfile, level)
            outfile.write('conc_factor=model_.ConcFactor(\n')
            self.conc_factor.exportLiteral(outfile, level, name_='conc_factor')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('gate=[\n')
        level += 1
        for gate_ in self.gate:
            showIndent(outfile, level)
            outfile.write('model_.Gate(\n')
            gate_.exportLiteral(outfile, level, name_='Gate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_gmax', node)
        if value is not None and 'default_gmax' not in already_processed:
            already_processed.append('default_gmax')
            self.default_gmax = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.setProperties(obj_)
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group.append(group_)
            self.validate_Group(self.group)    # validate type Group
        elif nodeName_ == 'rate_adjustments':
            obj_ = RateAdjustments.factory()
            obj_.build(child_)
            self.setRate_adjustments(obj_)
        elif nodeName_ == 'conc_factor':
            obj_ = ConcFactor.factory()
            obj_.build(child_)
            self.setConc_factor(obj_)
        elif nodeName_ == 'gate':
            obj_ = Gate.factory()
            obj_.build(child_)
            self.gate.append(obj_)
# end class conductanceType


class table_settingsType(GeneratedsSuper):
    """The maximum potential from which to calculate the tables of rate
    valuesThe minimum potential from which to calculate the tables
    of rate valuesThe number of divisions in the table"""
    subclass = None
    superclass = None
    def __init__(self, max_v=70, min_v=-100, table_divisions=200):
        self.max_v = _cast(float, max_v)
        self.min_v = _cast(float, min_v)
        self.table_divisions = _cast(int, table_divisions)
        pass
    def factory(*args_, **kwargs_):
        if table_settingsType.subclass:
            return table_settingsType.subclass(*args_, **kwargs_)
        else:
            return table_settingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMax_v(self): return self.max_v
    def setMax_v(self, max_v): self.max_v = max_v
    def getMin_v(self): return self.min_v
    def setMin_v(self, min_v): self.min_v = min_v
    def getTable_divisions(self): return self.table_divisions
    def setTable_divisions(self, table_divisions): self.table_divisions = table_divisions
    def export(self, outfile, level, namespace_='', name_='table_settingsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='table_settingsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='table_settingsType'):
        if self.max_v is not None and 'max_v' not in already_processed:
            already_processed.append('max_v')
            outfile.write(' max_v="%s"' % self.gds_format_double(self.max_v, input_name='max_v'))
        if self.min_v is not None and 'min_v' not in already_processed:
            already_processed.append('min_v')
            outfile.write(' min_v="%s"' % self.gds_format_double(self.min_v, input_name='min_v'))
        if self.table_divisions is not None and 'table_divisions' not in already_processed:
            already_processed.append('table_divisions')
            outfile.write(' table_divisions="%s"' % self.gds_format_integer(self.table_divisions, input_name='table_divisions'))
    def exportChildren(self, outfile, level, namespace_='', name_='table_settingsType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='table_settingsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max_v is not None and 'max_v' not in already_processed:
            already_processed.append('max_v')
            showIndent(outfile, level)
            outfile.write('max_v = %e,\n' % (self.max_v,))
        if self.min_v is not None and 'min_v' not in already_processed:
            already_processed.append('min_v')
            showIndent(outfile, level)
            outfile.write('min_v = %e,\n' % (self.min_v,))
        if self.table_divisions is not None and 'table_divisions' not in already_processed:
            already_processed.append('table_divisions')
            showIndent(outfile, level)
            outfile.write('table_divisions = %d,\n' % (self.table_divisions,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_v', node)
        if value is not None and 'max_v' not in already_processed:
            already_processed.append('max_v')
            try:
                self.max_v = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (max_v): %s' % exp)
        value = find_attr_value_('min_v', node)
        if value is not None and 'min_v' not in already_processed:
            already_processed.append('min_v')
            try:
                self.min_v = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (min_v): %s' % exp)
        value = find_attr_value_('table_divisions', node)
        if value is not None and 'table_divisions' not in already_processed:
            already_processed.append('table_divisions')
            try:
                self.table_divisions = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.table_divisions <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class table_settingsType


class stateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, fraction='1'):
        self.name = _cast(None, name)
        self.fraction = _cast(None, fraction)
        pass
    def factory(*args_, **kwargs_):
        if stateType.subclass:
            return stateType.subclass(*args_, **kwargs_)
        else:
            return stateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def getFraction(self): return self.fraction
    def setFraction(self, fraction): self.fraction = fraction
    def export(self, outfile, level, namespace_='', name_='stateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stateType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fraction is not None and 'fraction' not in already_processed:
            already_processed.append('fraction')
            outfile.write(' fraction=%s' % (quote_attrib(self.fraction), ))
    def exportChildren(self, outfile, level, namespace_='', name_='stateType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fraction is not None and 'fraction' not in already_processed:
            already_processed.append('fraction')
            showIndent(outfile, level)
            outfile.write('fraction = %s,\n' % (self.fraction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('fraction', node)
        if value is not None and 'fraction' not in already_processed:
            already_processed.append('fraction')
            self.fraction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stateType


class sizeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, depth=None, height=None):
        self.width = _cast(float, width)
        self.depth = _cast(float, depth)
        self.height = _cast(float, height)
        pass
    def factory(*args_, **kwargs_):
        if sizeType.subclass:
            return sizeType.subclass(*args_, **kwargs_)
        else:
            return sizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getWidth(self): return self.width
    def setWidth(self, width): self.width = width
    def getDepth(self): return self.depth
    def setDepth(self, depth): self.depth = depth
    def getHeight(self): return self.height
    def setHeight(self, height): self.height = height
    def export(self, outfile, level, namespace_='', name_='sizeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sizeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sizeType'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            outfile.write(' depth="%s"' % self.gds_format_double(self.depth, input_name='depth'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='sizeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sizeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = %e,\n' % (self.width,))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            showIndent(outfile, level)
            outfile.write('depth = %e,\n' % (self.depth,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.append('height')
            showIndent(outfile, level)
            outfile.write('height = %e,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            try:
                self.width = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
        value = find_attr_value_('depth', node)
        if value is not None and 'depth' not in already_processed:
            already_processed.append('depth')
            try:
                self.depth = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (depth): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.append('height')
            try:
                self.height = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sizeType


class polygonsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polygon=None):
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
    def factory(*args_, **kwargs_):
        if polygonsType.subclass:
            return polygonsType.subclass(*args_, **kwargs_)
        else:
            return polygonsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPolygon(self): return self.polygon
    def setPolygon(self, polygon): self.polygon = polygon
    def addPolygon(self, value): self.polygon.append(value)
    def insertPolygon(self, index, value): self.polygon[index] = value
    def export(self, outfile, level, namespace_='', name_='polygonsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polygonsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='polygonsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='polygonsType', fromsubclass_=False):
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
    def hasContent_(self):
        if (
            self.polygon
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polygonsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.Polygon(\n')
            polygon_.exportLiteral(outfile, level, name_='Polygon')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = Polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
# end class polygonsType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ChannelML'
        rootClass = ChannelML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='xmlns:neuroml="http://morphml.org/channelml/schema"')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ChannelML'
        rootClass = ChannelML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="ChannelML",
##         namespacedef_='xmlns:neuroml="http://morphml.org/channelml/schema"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ChannelML'
        rootClass = ChannelML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from channel import *\n\n')
##     sys.stdout.write('import channel as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Annotation",
    "Authors",
    "Biophysics",
    "Block",
    "BlockingSynapse",
    "ChannelML",
    "ChannelType",
    "ClosedState",
    "ConcDependence",
    "ConcFactor",
    "CurrentVoltageRelation",
    "DecayingPoolModel",
    "Deprecated_AkdEquation",
    "Deprecated_GenericEquation",
    "Deprecated_HHGate",
    "Deprecated_Ion",
    "Deprecated_KSGate",
    "Deprecated_KSState",
    "Deprecated_Ohmic",
    "Deprecated_Parameter",
    "Deprecated_RateConstVoltConcDep",
    "Deprecated_RateConstantEqn",
    "Deprecated_RateConstantEqnChoice",
    "Deprecated_Transition",
    "Deprecated_VoltageConcGate",
    "Deprecated_VoltageGate",
    "DoubleExponentialSynapse",
    "ElectricalSynapse",
    "FacDep",
    "FacDepSynapse",
    "FixedPoolInfo",
    "Gate",
    "GatingComplex",
    "GroupDetail",
    "ImplementationPrefs",
    "InhomogeneousValue",
    "InitialMembPotential",
    "Initialisation",
    "IntegrateAndFire",
    "IonConcentration",
    "IonProperties",
    "IonSpecies",
    "Manifold",
    "Mechanism",
    "ModelDBReference",
    "MultiDecaySynapse",
    "NamedParameter",
    "NeuroMorphoRef",
    "NeuronDBReference",
    "NonSpatialGrid",
    "Offset",
    "OpenState",
    "Parameter",
    "Parameters",
    "Person",
    "Point",
    "Point3D",
    "Points",
    "Polygon",
    "Polyhedron",
    "PoolVolumeInfo",
    "Properties",
    "Property",
    "PropertyDetail",
    "Publication",
    "Q10Settings",
    "RateAdjustments",
    "RectangularBox",
    "SpecAxialResistance",
    "SpecCapacitance",
    "Sphere",
    "Status",
    "StdpDep",
    "StdpSynapse",
    "SteadyState",
    "SynapseType",
    "TimeCourse",
    "Transition",
    "UnnamedParameter",
    "VariableNamedParameter",
    "VariableParameter",
    "conductanceType",
    "polygonsType",
    "sizeType",
    "stateType",
    "table_settingsType"
    ]
